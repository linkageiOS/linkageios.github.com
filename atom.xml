<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[SmartArrow]]></title>
  <subtitle><![CDATA[技术文档]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://linkageios.github.io/"/>
  <updated>2014-12-11T06:00:27.521Z</updated>
  <id>http://linkageios.github.io/</id>
  
  <author>
    <name><![CDATA[SmartArrow]]></name>
    <email><![CDATA[stephenzhumail@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[SVPullToRefresh与下拉刷新]]></title>
    <link href="http://linkageios.github.io/2014/12/03/SVPullToRefresh%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://linkageios.github.io/2014/12/03/SVPullToRefresh深入理解/</id>
    <published>2014-12-03T07:59:00.000Z</published>
    <updated>2014-12-11T05:54:57.000Z</updated>
    <content type="html"><![CDATA[<p>SVPullToRefresh是iOS上实现下拉刷新和上提加载的一个组件。<br><a id="more"></a></p>
<h3 id="背景">背景</h3>
<p>使用场景仅限UIScrollView，只需要一行代码，就能添加下拉刷新的功能。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[tableView addPullToRefreshWithActionHandler:^{</div><div class="line">    <span class="comment">// 预加载数据到dataSource, 向tableview插入cell</span></div><div class="line">    <span class="comment">// 完成时调用[tableView.pullToRefreshView stopAnimating] </span></div><div class="line">}];</div></pre></td></tr></table></figure>

<p>准备研究之前google了一把SVPullToRefresh，发现除了github的官方地址，排在最前面的居然是我去年写的一篇<a href="http://blog.csdn.net/itenric/article/details/12391185" target="_blank" rel="external">博客</a>。重新看了一遍，发现自己当时讲的很浅，很多关键的东西都是一笔带过，没有讲清楚。所以今天重写一篇，深入地介绍一下这个优秀的组件。</p>
<h3 id="铺垫">铺垫</h3>
<h6 id="Associative（关联）">Associative（关联）</h6>
<p>一个不可修改的类，如果要增加方法，可以用Category；但如果要添加属性，Category就无能为力了，只能使用Associative。Associative和Category同属于Runtime的运用，只是Category属于语法级别的封装，而要使用Associative必须显示地引用头文件<objc runtime.h="">。<br>Associative一共包含三个方法：</objc></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置属性</span></div><div class="line"><span class="comment">//第一个参数是原始对象，第二个参数是关联对象的key，第三个参数是关联对象本身，第四个参数是关联的策略。</span></div><div class="line"><span class="comment">//如果第三个参数是nil，则清空当前关联。</span></div><div class="line">OBJC_EXPORT <span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy)</div><div class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);</div><div class="line"></div><div class="line"><span class="comment">//访问属性</span></div><div class="line"><span class="comment">//第一个参数是原始对象，第二个参数是关联对象的key</span></div><div class="line">OBJC_EXPORT <span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</div><div class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);</div><div class="line"></div><div class="line"><span class="comment">//移除所有属性</span></div><div class="line"><span class="comment">//参数是原始对象</span></div><div class="line"><span class="comment">//这个方法会把对象重置回初始状态，因为无法保证别的地方是否也为该对象设置为关联对象。</span></div><div class="line"><span class="comment">//所以在尽量使用objc_setAssociatedObject，并把第三个参数设成nil来替代。</span></div><div class="line">OBJC_EXPORT <span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object)</div><div class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);</div></pre></td></tr></table></figure>

<p>关联策略（objc_AssociationPolicy）一共有5种类型，参照Property的定义，应该不难理解它们之间的区别。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> {</div><div class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="javadoc">/**&lt; Specifies a weak reference to the associated object. */</span></div><div class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="javadoc">/**&lt; Specifies a strong reference to the associated object. </span></div><div class="line">                                            *   The association is not made atomically. */</div><div class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="javadoc">/**&lt; Specifies that the associated object is copied. </span></div><div class="line">                                            *   The association is not made atomically. */</div><div class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="javadoc">/**&lt; Specifies a strong reference to the associated object.</span></div><div class="line">                                            *   The association is made atomically. */</div><div class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="javadoc">/**&lt; Specifies that the associated object is copied.</span></div><div class="line">                                            *   The association is made atomically. */</div><div class="line">};</div></pre></td></tr></table></figure>

<p>  <a href="http://nshipster.cn/associated-objects/" target="_blank" rel="external">更多参考</a></p>
<h6 id="@dynamic属性声明">@dynamic属性声明</h6>
<p>正常的属性都是用@synthesize来声明的（XCode4.0之后不需要了，编译时会自动生成get、set方法）。但是有时候我们的get、set方法要在运行时才动态绑定，这时就要用@dynamic。</p>
<h6 id="KVO">KVO</h6>
<p>KVO是用来检测对象的某个属性是否发生变化的机制。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//加入观察者</span></div><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(NSKeyValueObservingOptions)options context:(<span class="keyword">void</span> *)context;</div><div class="line"></div><div class="line"><span class="comment">//移除观察者</span></div><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</div></pre></td></tr></table></figure>

<h3 id="PullToRefresh实现机制">PullToRefresh实现机制</h3>
<p>PullToRefresh就是在UIScrollView上面add了一个subview：PullToRefreshView。这个PullToRefreshView就是一个普通的View，宽度和UIScrollView相同，高度可以自定义，默认是60。</p>
<p>PullToRefreshView有四种状态：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, SVPullToRefreshState) {</div><div class="line"><span class="constant">    SVPullToRefreshStateStopped</span> = <span class="number">0</span>,</div><div class="line"><span class="constant">    SVPullToRefreshStateTriggered,</span></div><div class="line">    SVPullToRefreshStateLoading,</div><div class="line">    SVPullToRefreshStateAll = <span class="number">10</span></div><div class="line">};</div></pre></td></tr></table></figure>

<ul>
<li>SVPullToRefreshStateStopped：刷新停止状态，还没有触发刷新操作。</li>
<li>SVPullToRefreshStateTriggered：刷新操作被触发，但还没有开始发送请求（只要用户手还没松开，不会发送请求）</li>
<li>SVPullToRefreshStateLoading：已经发送请求，但数据还没回来，这时菊花一直在转。这时候UITableView的contentInset已经修改，使PullToRefreshView可见。</li>
<li>SVPullToRefreshStateAll：初始化的时候用的。</li>
</ul>
<p>如果不需要自定义，PullToRefreshView内置了一个默认版本，包含箭头、title、subtitle、time。</p>
<p>自定义也可以，在PullToRefreshView的viewForState数组中加入三中状态的视图，然后就可以显示自定义的UI了。</p>
<p>PullToRefreshView是UIScrollView的一个属性，这个属性是通过关联的方式绑定的。当用户滚动UIScrollView的时候，ContentOffset会发生变化，这时候UIScrollView的观察者PullToRefreshView就会收到通知，然后根据PullToRefreshView自身的状态和ContentOffset决定是否切换状态，并执行相应动画。</p>
<h3 id="自定义">自定义</h3>
<p>SVPullToRefresh自带的自定义功能比较鸡肋，就是根据不同的状态换不同的View。当你想做更多个性化的动画时，就比较捉急了。所以，我准备只保留其最核心的部分，比如关联、KVO、四个状态，然后整体的动画都重新写。效果图如下（话说这个动画设计的实在是low）：</p>
<p><img src="/images/16632-ba39e932e38e20d7.gif" alt="loading.gif"></p>
<p>动画分成两个阶段：</p>
<ul>
<li>第一个阶段是还没进入加载阶段，这时候随着下拉的高度，中间的图片逐渐变大，扇形区域也逐渐变大。</li>
<li>第二个阶段是加载过程中，中间的图片开始旋转，同时像两侧发射出几个小图，旋转的同时透明度也发生变化，并来回震荡，直到加载结束。</li>
</ul>
<p>代码是基于SVPullToRefresh修改的，把用不着的代码全删了。项目已上传：<a href="https://github.com/tenric/SVPullToRefreshDemo" target="_blank" rel="external">Github</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>SVPullToRefresh是iOS上实现下拉刷新和上提加载的一个组件。<br>]]>
    
    </summary>
    
      <category term="网络" scheme="http://linkageios.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
      <category term="AFNetworking" scheme="http://linkageios.github.io/categories/iOS/AFNetworking/"/>
    
      <category term="重构" scheme="http://linkageios.github.io/categories/iOS/AFNetworking/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sourceTree使用注意事项]]></title>
    <link href="http://linkageios.github.io/2014/12/03/sourceTree%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://linkageios.github.io/2014/12/03/sourceTree使用注意事项/</id>
    <published>2014-12-03T02:24:53.000Z</published>
    <updated>2014-12-03T02:58:53.000Z</updated>
    <content type="html"><![CDATA[<h1 id="sourceTree使用注意事项">sourceTree使用注意事项</h1>
<ul>
<li>更正上次文档《关于文档类工作输出要求》的错误，其中<code>其中图片必须使用本地相对路径![imag](../images/xxx.png)</code>应该为<code>其中图片必须使用本地相对路径![imag](/images/xxx.png)</code></li>
<li>点击list条目进入sourceTree工程页面<br><img src="/images/gitlist.png" alt="image"><br><br></li>
<li>点击顶部菜单栏的“抓取-fetch”，然后勾选<code>删除在所有远端都已经不存在的跟踪（tracking）分支</code><br><img src="/images/gitmenu.png" alt="image"><br><br></li>
</ul>
<p>这样就可以了同步本地的分支（服务器上已被删除而本地却有）了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="sourceTree使用注意事项">sourceTree使用注意事项</h1>
<ul>
<li>更正上次文档《关于文档类工作输出要求》的错误，其中<code>其中图片必须使用本地相对路径![imag](../images/xxx.png)</code>应该为<c]]>
    </summary>
    
      <category term="版本管理" scheme="http://linkageios.github.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[内存管理培训ppt]]></title>
    <link href="http://linkageios.github.io/2014/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://linkageios.github.io/2014/12/02/内存管理/</id>
    <published>2014-12-02T01:20:08.000Z</published>
    <updated>2014-12-03T02:51:28.000Z</updated>
    <content type="html"><![CDATA[<p><a id="more"></a></p>
<h1 id="内存管理培训ppt">内存管理培训ppt</h1>
<p><a href="/extr/内存管理.ppt">ppt</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>]]>
    
    </summary>
    
      <category term="内存" scheme="http://linkageios.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义控件说明]]></title>
    <link href="http://linkageios.github.io/2014/12/01/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E8%AF%B4%E6%98%8E/"/>
    <id>http://linkageios.github.io/2014/12/01/自定义控件说明/</id>
    <published>2014-12-01T07:59:00.000Z</published>
    <updated>2014-12-11T03:01:15.000Z</updated>
    <content type="html"><![CDATA[<p>自定义控件能满足快速迭代的需要，我把常用的控件整理出来，欢迎使用。<br><a id="more"></a></p>
<h4 id="1-PageControl">1.PageControl</h4>
<p>由于系统的PageControl控件的限制，不能修改颜色，更换图片，修改大小。所以开发了此控件。</p>
<p><img src="/images/77211-6b437f8229b8d900.gif" alt="pagecontrol.gif"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/*默认使用颜色填充,还有其他参数可以修改* /</div><div class="line"><span class="constant">_pageControl.numberOfPages</span> = <span class="number">5</span>;<span class="comment">//一共多少页</span></div><div class="line">[_pageControl setOffColor: [UIColor  whiteColor]];<span class="comment">//非当前页的圆点颜色</span></div><div class="line">[_pageControl setOnColor: [UIColor redColor]];<span class="comment">//当前页的圆点颜色</span></div><div class="line">[_pageControl setIndicatorDiameter: <span class="number">7.0</span>f] ;<span class="comment">//圆点的直径</span></div><div class="line">[_pageControl setIndicatorSpace: <span class="number">12.0</span>f] ;<span class="comment">//圆点之间的距离</span></div></pre></td></tr></table></figure>

<h4 id="2-倒计时控件">2.倒计时控件</h4>
<p>项目中经常用到获取验证码的控件，用NSTimer控制时间，刷新按钮等。整理出来，避免代码冗余，使逻辑清晰。</p>
<p><img src="/mages/77211-2a819e6b50a4e17f.gif" alt="倒计时.gif"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">IBOutlet</span> LCCountDownButton *_countDownButton;<span class="comment">//定义</span></div><div class="line">_countDownButton<span class="variable">.timeOut</span> = <span class="number">10</span>;<span class="comment">//设置时间，默认是60秒</span></div><div class="line"></div><div class="line">按钮点击事件方法中调用：</div><div class="line">[_countDownButton beginCountDown];<span class="comment">//开始计时</span></div></pre></td></tr></table></figure>

<h4 id="3-PlaceHolderTextView">3.PlaceHolderTextView</h4>
<p>系统的textview控件无法添加提示语，不能修改颜色，大小，对齐方式。提示语在没有内容时显示，填写的时候自动隐藏。<br><img src="/images/77211-b55d156a76bd77cc.gif" alt="textView.gif"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="constant">_textView.placeholder</span> = @<span class="string">"请输入你想说的话..."</span>;<span class="comment">//提示文本</span></div><div class="line"><span class="constant">_textView.placeholderColor</span> = [UIColor redColor];<span class="comment">//文本颜色</span></div><div class="line"><span class="comment">//_textView.placeHolderTextAlignment = NSTextAlignmentCenter;//对齐方式，默认左对齐</span></div></pre></td></tr></table></figure>

<h4 id="4-评分控件">4.评分控件</h4>
<p>此控件有两个功能：<br>1）仅仅显示评分，一份代表一颗星，总分可以设置。<br>2）点击评分功能。</p>
<p><img src="/images/77211-b59fc8ef654ca40a.gif" alt="starRating.gif"></p>
<h4 id="5-跑马灯效果">5.跑马灯效果</h4>
<p>项目中如果文字过长，由于屏幕宽度的限制，显示不完整，但是文本又不能截取。跑马灯是这种情况下最好的解决方案。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/77211-3c2a3f3fcd13cdcb.gif" alt="跑马灯.gif"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[_label setText:@<span class="string">"你发如雪 凄美了离别 我焚香感动了谁 邀明月 让回忆皎洁 爱在月光下完美"</span>];<span class="comment">//跑马灯文本</span></div><div class="line"><span class="constant">_label.backgroundColor</span> = [UIColor clearColor];</div><div class="line"><span class="constant">_label.subLabel.backgroundColor</span> = [UIColor clearColor];</div><div class="line"><span class="constant">_label.subLabel.textColor</span> = [UIColor redColor];<span class="comment">//文本颜色</span></div></pre></td></tr></table></figure>

<h4 id="6-标签TagView">6.标签TagView</h4>
<p>如下图所示。此控件经常用来显示个性标签。<br><img src="/images/77211-3c91a3611c9dc5e4.png" alt="tagView.png"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义标签的文本属性</span></div><div class="line">TagAttribute *attr = [[TagAttribute alloc] init];</div><div class="line">attr<span class="variable">.textBackgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];<span class="comment">//背景色</span></div><div class="line">attr<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.0</span> green:<span class="number">144.0</span>/<span class="number">255.0</span> blue:<span class="number">1.0</span> alpha:<span class="number">1.0</span>];<span class="comment">//文本颜色</span></div><div class="line">attr<span class="variable">.textFont</span> = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">12.0</span>];<span class="comment">//文本大小</span></div><div class="line">attr<span class="variable">.borderDisplay</span> = <span class="literal">YES</span>;<span class="comment">//是否显示边框</span></div><div class="line">attr<span class="variable">.borderColor</span> = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">140.0</span>/<span class="number">255.0</span> green:<span class="number">204.0</span>/<span class="number">255.0</span> blue:<span class="number">1.0</span> alpha:<span class="number">1.0</span>];<span class="comment">//文本框颜色</span></div><div class="line">attr<span class="variable">.horizotalPadding</span> = <span class="number">3.0</span>;<span class="comment">//间隔</span></div><div class="line">_tagView<span class="variable">.tagAttribute</span> = attr;</div><div class="line">    </div><div class="line"></div><div class="line">_tagView<span class="variable">.tags</span> = @[<span class="string">@"自驾游"</span>,<span class="string">@"爱吹牛"</span>,<span class="string">@"90后"</span>,<span class="string">@"王菲"</span>,<span class="string">@"爱我别走，如果你说"</span>,<span class="string">@"喜欢陶喆"</span>,<span class="string">@"发如雪，凄美"</span>];<span class="comment">//标签内容，用数组传递。自动计算</span></div><div class="line">[_tagView displayTags];<span class="comment">//开始绘制</span></div></pre></td></tr></table></figure>

<h4 id="7-segmentControl">7.segmentControl</h4>
<p>此控件的主要作用就是减少冗余重复代码，减少开发者重复的判断和多余的开发。<br>只需要在布局文件上把父view类换成SegmentControl类别，可以达到自动控制。<br><img src="http://upload-images.jianshu.io/upload_images/77211-af0166c1671a787d.gif" alt="segmentControl.gif"></p>
<p>此控件不需要写代码。仅仅连接把父类类别更改即可。</p>
<p>以上所有代码: <a href="https://github.com/angelacc1989/LCControlDemo" title="" target="_blank" rel="external"><br>LCControlDemo</a> </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>自定义控件能满足快速迭代的需要，我把常用的控件整理出来，欢迎使用。<br>]]>
    
    </summary>
    
      <category term="控件" scheme="http://linkageios.github.io/tags/%E6%8E%A7%E4%BB%B6/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
      <category term="控件" scheme="http://linkageios.github.io/categories/iOS/%E6%8E%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于文档类工作输出要求]]></title>
    <link href="http://linkageios.github.io/2014/12/01/%E5%85%B3%E4%BA%8E%E6%96%87%E6%A1%A3%E7%B1%BB%E5%B7%A5%E4%BD%9C%E8%BE%93%E5%87%BA%E8%A6%81%E6%B1%82/"/>
    <id>http://linkageios.github.io/2014/12/01/关于文档类工作输出要求/</id>
    <published>2014-12-01T05:24:53.000Z</published>
    <updated>2014-12-03T02:51:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="模板说明">模板说明</h2>
<ul>
<li>title 文档的标题</li>
<li>data 文档编写或修改的时间</li>
<li>categories 文档的类别，多个以半角逗号和方括号构成</li>
<li>tags 文档的tag，多个以半角逗号和方括号构成</li>
<li>分隔符—-这一行保留</li>
<li><code>&lt;!--more--&gt;</code>和分隔符<code>---</code>之间的内容为文档摘要</li>
<li>其中图片必须使用本地相对路径<code>![imag](/images/xxx.png)</code></li>
<li>文档提交地址<a href="http://172.16.128.161/ios/technology-blog.git" target="_blank" rel="external">http://172.16.128.161/ios/technology-blog.git</a></li>
<li>文档地址 ./source/_posts/*.md</li>
<li>图片地址 ./source/images/*.png</li>
<li>xxx 正文<br><a id="more"></a><h1 id="关于文档类工作输出要求">关于文档类工作输出要求</h1>
</li>
</ul>
<h2 id="模板">模板</h2>
<pre><code>title: iOS代码规范
date: 2014-11-07 13:38:14
categories: [iOS,执行文档]
tags: [效率]
---
# 代码规范的内容？
代码规范包含的范围十分广泛。从一个变量的命名到一个类的设计，我觉得都属于代码规范的范畴。从实践的角度，可以把代码规范分成两个部分：
第一部分是规则，即一定要这么做。这里面没有对错，但需要统一。包含变量的命名、函数的命名、模块的组织、代码块的组织、宏、枚举、常量的声明、函数的粒度。
第二部分是风格，即一种模式化的代码设计结构。我们实现某个功能时，往往不止一种实现方式。每一种实现    方式没有绝对的高低之分，不同角度的解读，就会有不同的偏好。所以这个层面上的代码规范，只能求同存异。但是不管怎样，每个人必须要有一致性的风格。就像不同的小区可以有不同的风格，但同一个小区只能有一种设计风格。风格包含代码设计中的抽象概念，比如接口、继承等等。
<span class="comment">&lt;!--more--&gt;</span>
xxxxxx
</code></pre><h2 id="模板说明-1">模板说明</h2>
<ul>
<li>title 文档的标题</li>
<li>data 文档编写或修改的时间</li>
<li>categories 文档的类别，多个以半角逗号和方括号构成</li>
<li>tags 文档的tag，多个以半角逗号和方括号构成</li>
<li>分隔符—-这一行保留</li>
<li><code>&lt;!--more--&gt;</code>和分隔符<code>---</code>之间的内容为文档摘要</li>
<li>其中图片必须使用本地相对路径<code>![imag](/images/xxx.png)</code></li>
<li>文档提交地址<a href="http://172.16.128.161/ios/technology-blog.git" target="_blank" rel="external">http://172.16.128.161/ios/technology-blog.git</a></li>
<li>文档地址 ./source/_posts/*.md</li>
<li>图片地址 ./source/images/*.png</li>
<li>xxx 正文</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="模板说明">模板说明</h2>
<ul>
<li>title 文档的标题</li>
<li>data 文档编写或修改的时间</li>
<li>categories 文档的类别，多个以半角逗号和方括号构成</li>
<li>tags 文档的tag，多个以半角逗号和方括号构成</li>
<li>分隔符—-这一行保留</li>
<li><code>&lt;!--more--&gt;</code>和分隔符<code>---</code>之间的内容为文档摘要</li>
<li>其中图片必须使用本地相对路径<code>![imag](/images/xxx.png)</code></li>
<li>文档提交地址<a href="http://172.16.128.161/ios/technology-blog.git" target="_blank" rel="external">http://172.16.128.161/ios/technology-blog.git</a></li>
<li>文档地址 ./source/_posts/*.md</li>
<li>图片地址 ./source/images/*.png</li>
<li>xxx 正文<br>]]>
    
    </summary>
    
      <category term="效率" scheme="http://linkageios.github.io/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
      <category term="执行文档" scheme="http://linkageios.github.io/categories/iOS/%E6%89%A7%E8%A1%8C%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[支付整合]]></title>
    <link href="http://linkageios.github.io/2014/11/30/%E6%94%AF%E4%BB%98%E6%95%B4%E5%90%88/"/>
    <id>http://linkageios.github.io/2014/11/30/支付整合/</id>
    <published>2014-11-30T07:59:00.000Z</published>
    <updated>2014-12-11T03:01:15.000Z</updated>
    <content type="html"><![CDATA[<p>对招行网页支付接口和银联支付sdk进行封装。<br><a id="more"></a></p>
<p>tips：根据安排整合支付模块</p>
<ul>
<li>结构说明</li>
</ul>
<p><img src="/images/79888-f225cd39b214aa91.png" alt="99042A97-1C41-4F22-A736-4EE199A32C6D.png"></p>
<p>LCPayManager 提供了支付方法和一个回掉查看支付结果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>orderPayMode:<span class="params">(<span class="variable">PayWay</span>)</span>payway orderInfo:<span class="params">(<span class="variable">LCPayBaseVo</span> *)</span>vo;</span></div></pre></td></tr></table></figure>

<p>其中PayWay是支付方式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, PayWay)</div><div class="line">{</div><div class="line"><span class="constant">    PayWayByAlipay</span>      = <span class="number">1</span>,</div><div class="line"><span class="constant">    PayWayByCMB</span>         = <span class="number">2</span>,</div><div class="line"><span class="constant">    PayWayByCash</span>        = <span class="number">3</span>,</div><div class="line"><span class="constant">    PayWayByUnionPay</span>    = <span class="number">4</span>,</div><div class="line">};</div></pre></td></tr></table></figure>

<p>vo 是一个存储支付相关信息的类，里面包含基本的商品信息</p>
<p>暂时直邮银联和招商两种支付方式，所以就提供了两种模式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">LCCMBPayMode</span></div><div class="line">LCUnionPayMode</div></pre></td></tr></table></figure>

<ul>
<li>使用<br>银联</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> LCPayUnionVo *<span class="variable">vo =</span> [[LCPayUnionVo alloc]init];</div><div class="line"> vo.<span class="variable">orderid =</span> backHead.tn;</div><div class="line"> vo.<span class="variable">viewController =</span> self;</div><div class="line">[LCPayManager sharedInstance].<span class="variable">delegate =</span> self;</div><div class="line">[[LCPayManager sharedInstance] orderPayMode:PayWayByUnionPay orderInfo:vo];</div></pre></td></tr></table></figure>

<p>招商</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">LCPayManager *<span class="variable">ma =</span> [LCPayManager sharedInstance];</div><div class="line">ma.<span class="variable">delegate =</span> self;</div><div class="line">LCPayCMBVo *<span class="variable">vo =</span> [[LCPayCMBVo alloc]init];</div><div class="line">vo.<span class="variable">branchId =</span> backHead.branchId;</div><div class="line">vo.<span class="variable">coNo =</span> backHead.coNo;</div><div class="line">vo.<span class="variable">orderid =</span> backHead.billNo;</div><div class="line">vo.<span class="variable">amount =</span> backHead.amount;</div><div class="line">vo.<span class="variable">date =</span> backHead.date;</div><div class="line">vo.<span class="variable">merchantUrl =</span> backHead.merchantUrl;</div><div class="line">vo.<span class="variable">merchantPara =</span> backHead.merchantPara;</div><div class="line">[ma orderPayMode:PayWayByCMB orderInfo:vo];</div></pre></td></tr></table></figure>

<p>所有的支付结果在中反回</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> - (<span class="type">void</span>)didFinishPayWithResult:(<span class="type">NSString</span> *)<span class="literal">result</span></div><div class="line">{</div><div class="line">    <span class="type">NSLog</span>(@<span class="string">"didFinishPayWithResult is %@"</span>,<span class="literal">result</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为CMB是跳外部浏览器的，所以在AppDelegate中也要做相应处理<br><code>- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation</code><br>添加[LCPayManager sharedInstance].mresult的赋值</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对招行网页支付接口和银联支付sdk进行封装。<br>]]>
    
    </summary>
    
      <category term="支付" scheme="http://linkageios.github.io/tags/%E6%94%AF%E4%BB%98/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
      <category term="SDK" scheme="http://linkageios.github.io/categories/iOS/SDK/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图片处理Demo]]></title>
    <link href="http://linkageios.github.io/2014/11/29/%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA/"/>
    <id>http://linkageios.github.io/2014/11/29/图片裁剪/</id>
    <published>2014-11-29T07:59:00.000Z</published>
    <updated>2014-12-11T03:01:15.000Z</updated>
    <content type="html"><![CDATA[<p>图片处理是iOS APP中一个常见的功能。<br><a id="more"></a></p>
<p>关于图片的裁剪，一般的需求是通过手势自定裁剪尺寸，如常见的美图软件。另外一种就是按照既定的比例裁剪，比如4：3， 16：9之类的。<br>这个demo主要做了两种裁剪方式。用法在demo已经写出。<br>主要看一下效果：</p>
<p><img src="/images/77211-f131390e450f1ea0.gif" alt="裁剪.gif"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>图片处理是iOS APP中一个常见的功能。<br>]]>
    
    </summary>
    
      <category term="图片" scheme="http://linkageios.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
      <category term="图片处理，剪裁" scheme="http://linkageios.github.io/categories/iOS/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%EF%BC%8C%E5%89%AA%E8%A3%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网络请求重构说明]]></title>
    <link href="http://linkageios.github.io/2014/11/28/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E9%87%8D%E6%9E%84%E8%AF%B4%E6%98%8E/"/>
    <id>http://linkageios.github.io/2014/11/28/网络请求重构说明/</id>
    <published>2014-11-28T07:59:00.000Z</published>
    <updated>2014-12-11T02:10:58.000Z</updated>
    <content type="html"><![CDATA[<p>这周主要在做网络请求的重构，在参考了很多开源的项目之后，做了一个基本的Demo。本文主要讲一下基本的使用方法，不涉及原理。<br><a id="more"></a></p>
<h3 id="背景">背景</h3>
<p>参考的项目有</p>
<ul>
<li><a href="https://github.com/Mantle/Mantle" target="_blank" rel="external">Mantle</a>：模型层的的封装框架，解决了json转object的问题。</li>
<li><a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="external">YTKNetwork</a>：网络请求的封装，基于AFNetworking，提供了普通请求，批量请求和依赖请求的处理。回调方法支持block和delegate两种模式。</li>
</ul>
<h3 id="用法">用法</h3>
<h6 id="如何创建一个请求">如何创建一个请求</h6>
<p>程序启动完成后先配置一下baseUrl：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LCNetworkConfig <span class="keyword">*</span>config = [LCNetworkConfig sharedInstance];</div><div class="line">config.baseUrl = <span class="comment">@"http://;</span></div></pre></td></tr></table></figure>

<p>创建请求首先要继承一个请求类，并声明初始化方法，初始化方法里面的参数就是请求要用到的参数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//.h文件</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UserLoginApi</span> : <span class="title">LCRequest</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithLoginName:(<span class="built_in">NSString</span> *)loginName</div><div class="line">               password:(<span class="built_in">NSString</span> *)password;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//.m文件</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UserLoginApi</span> </span>{</div><div class="line">    <span class="built_in">NSString</span> *_loginName;</div><div class="line">    <span class="built_in">NSString</span> *_password;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//初始化方法</span></div><div class="line">- (<span class="keyword">id</span>)initWithLoginName:(<span class="built_in">NSString</span> *)loginName</div><div class="line">               password:(<span class="built_in">NSString</span> *)password</div><div class="line">{</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) {</div><div class="line">        _loginName = loginName;</div><div class="line">        _password = password;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//请求的api，必须实现，如果有path类型的参数，需要从初始化方法里面把参数传进来，然后在这里拼装</span></div><div class="line">- (<span class="built_in">NSString</span> *)requestUrl {</div><div class="line">    <span class="keyword">return</span> <span class="string">@"/login"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//请求方法，必须实现</span></div><div class="line">- (LCRequestMethod)requestMethod {</div><div class="line">    <span class="keyword">return</span> LCRequestMethodPost;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//请求参数合成，如果没有请求参数，也可以不实现</span></div><div class="line">- (<span class="keyword">id</span>)requestArgument {</div><div class="line">    <span class="built_in">NSString</span>* tokenId = [USER_DEFAULT objectForKey:USERDEFAULTS_KEY_TOKENID];</div><div class="line">    <span class="built_in">NSString</span>* clientId = [USER_DEFAULT objectForKey:USERDEFAULTS_KEY_REGISTERID];</div><div class="line">    <span class="keyword">return</span> @{</div><div class="line">             <span class="string">@"loginName"</span>: _loginName,</div><div class="line">             <span class="string">@"password"</span>: _password,</div><div class="line">             <span class="string">@"source"</span>: <span class="string">@"iphone"</span>,</div><div class="line">             <span class="string">@"sign"</span>: <span class="string">@"ios"</span>,</div><div class="line">             <span class="string">@"versionNo"</span>: [LCSystemUtil appVersion],</div><div class="line">             <span class="string">@"iosTokenId"</span>: [LCStringUtil safeString:tokenId],</div><div class="line">             <span class="string">@"clientId"</span>: [LCStringUtil safeString:clientId]</div><div class="line">             };</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>实现了请求的Api对象之后，就可以发送请求了，发送请求有两种方式：Block和Delegate：<br>Block方式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CityQueryApi<span class="keyword">*</span> api = [[CityQueryApi alloc] init];</div><div class="line">[api startWithCompletionBlockWithSuccess:^(LCBaseRequest <span class="keyword">*</span>request) {</div><div class="line">       </div><div class="line">} failure:^(LCBaseRequest <span class="keyword">*</span>request) {</div><div class="line">   </div><div class="line">}];</div></pre></td></tr></table></figure>

<p>Delegate方式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="variable">CityQueryApi</span>* api = [[<span class="variable">CityQueryApi</span> alloc] init];</div><div class="line">api.delegate = self;</div><div class="line">[api start];</div><div class="line"></div><div class="line"><span class="pp">- <span class="params">(void)</span>requestFinished:<span class="params">(<span class="variable">LCBaseRequest</span> *)</span>request</span></div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line">- <span class="params">(void)</span>requestFailed:<span class="params">(<span class="variable">LCBaseRequest</span> *)</span>request</div><div class="line">{</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果一个页面只有一个请求，我觉得用Block比较直观，回调代码就在请求边上；如果有多个请求，用Delegate便于管理，因为回调处理代码都集中在一个地方。</p>
<h6 id="json转Model">json转Model</h6>
<p>json转Model使用了Mentle。原来转换起来比较麻烦，一是不能自定义属性名，接口返回json的key是什么，我们的属性就是什么；二是如果返回的对象是多层的，就需要手动的一层层解包，比较麻烦。</p>
<p>而Mentle完全解决了这些问题，并且提供了更多的功能（序列化什么的）。<br>首先，我们建立一个模型类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">json文件</div><div class="line">{</div><div class="line">    nickName = nmj;</div><div class="line">    phone = <span class="number">18512553387</span>;</div><div class="line">    photoUrl = <span class="string">"&lt;null&gt;"</span>;</div><div class="line">    state = <span class="string">"&lt;null&gt;"</span>;</div><div class="line">    userId = <span class="number">705363918947328</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//.h文件</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LoginUserModel</span> : <span class="title">MTLModel</span> &lt;<span class="title">MTLJSONSerializing</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSNumber</span> *userId;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *phone;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *nickName;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *avatarUrl;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *loginState;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//.m文件</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LoginUserModel</span></span></div><div class="line"></div><div class="line"><span class="comment">//此方法必须实现，用来标记本地属性名和接口key之间的匹配</span></div><div class="line"><span class="comment">//如果属性名和接口key完全一致，则返回nil，但方法一定要写。</span></div><div class="line">+ (<span class="built_in">NSDictionary</span> *)JSONKeyPathsByPropertyKey {</div><div class="line">    <span class="keyword">return</span> @{</div><div class="line">             <span class="string">@"avatarUrl"</span>: <span class="string">@"photoUrl"</span>,</div><div class="line">             <span class="string">@"loginState"</span>: <span class="string">@"state"</span></div><div class="line">             };</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>然后在请求的回调里面获得model</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSError *<span class="keyword">error</span> = nil;</div><div class="line">LoginUserModel* model = [MTLJSONAdapter modelOfClass:LoginUserModel.<span class="keyword">class</span> fromJSONDictionary:<span class="built_in">request</span>.responseJSONObject <span class="keyword">error</span>:&<span class="keyword">error</span>];</div></pre></td></tr></table></figure>

<p>如果是返回嵌套的对象，只需要增加一个方法，可以在CityGroupModel里面查到，它里面cityList对应的是一个数组，数组里面的每一个对象都是CityModel，Mantle会递归的进行解析，不用我们操心。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (NSValueTransformer *)cityListJSONTransformer</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> [NSValueTransformer mtl_JSONArrayTransformerWithModelClass:CityModel.<span class="keyword">class</span>];</div><div class="line">}</div></pre></td></tr></table></figure>

<h6 id="HUD">HUD</h6>
<p>HUD以前写起来比较麻烦，所以我把HUD的展示、消失、错误提示封装在请求里面了：一共两个属性，一个方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//是否展示HUD</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">BOOL</span> showHUD;</div><div class="line"></div><div class="line"><span class="comment">//hud的文字</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span>* HUDText;</div><div class="line"></div><div class="line"><span class="comment">//显示错去消息的方法</span></div><div class="line">- (<span class="keyword">void</span>)showHUDError:(<span class="built_in">NSString</span>*)msg;</div></pre></td></tr></table></figure>

<p>如果不需要显示HUD，那么请求的时候什么也不用做，否则需要设置以上两个属性。如果请求出错需要提示的话，就在failure的block里面提示一下。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">AACoinExchangeCodeApi* api = [[AACoinExchangeCodeApi alloc] initWithPayer:[UserInfoEntity shareEntity].phone tradeType:@<span class="string">"1"</span> accType:accType amount:amount];</div><div class="line">api.showHUD = YES;</div><div class="line">api.HUDText = NSLocalizedString(@<span class="string">"Obtaining verification code"</span>, nil);</div><div class="line">[api startWithCompletionBlockWithSuccess:^(LCBaseRequest *<span class="built_in">request</span>) {</div><div class="line">[self.getCodeButton beginCountDown];</div><div class="line">} failure:^(LCBaseRequest *<span class="built_in">request</span>) {</div><div class="line">[<span class="built_in">request</span> showHUDError:<span class="built_in">request</span>.errorMessage];</div><div class="line">}];</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>这周主要在做网络请求的重构，在参考了很多开源的项目之后，做了一个基本的Demo。本文主要讲一下基本的使用方法，不涉及原理。<br>]]>
    
    </summary>
    
      <category term="网络" scheme="http://linkageios.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
      <category term="AFNetworking" scheme="http://linkageios.github.io/categories/iOS/AFNetworking/"/>
    
      <category term="重构" scheme="http://linkageios.github.io/categories/iOS/AFNetworking/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FMDB简介及使用]]></title>
    <link href="http://linkageios.github.io/2014/11/27/FMDB%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://linkageios.github.io/2014/11/27/FMDB简介及使用/</id>
    <published>2014-11-27T05:38:14.000Z</published>
    <updated>2014-12-11T02:10:58.000Z</updated>
    <content type="html"><![CDATA[<p>FMDB是SQLite在oc下的封装，有三个主要的类。<br><a id="more"></a></p>
<h1 id="简介">简介</h1>
<p>FMDB是SQLite在oc下的封装，有三个主要的类<br>1.FMDatabase – 表示一个单独的SQLite数据库。 用来执行SQLite的命令。<br>2.FMResultSet – 表示FMDatabase执行查询后结果集<br>3.FMDatabaseQueue – 如果你想在多线程中执行多个查询或更新，你应该使用该类。这是线程安全的。</p>
<h1 id="使用">使用</h1>
<p>创建FMDatabase对象时参数为SQLite数据库文件路径。该路径可以是以下三种之一：<br>1.文件路径。该文件路径无需真实存在，如果不存在会自动创建。<br>2.空字符串@””。表示会在临时目录创建一个空的数据库，当FMDatabase 链接关闭时，文件也被删除。<br>3.NULL. 将创建一个in-memory数据库。同样的，当FMDatabase连接关闭时，数据会被销毁。</p>
<pre><code>
FMDatabase *db = [FMDatabase databaseWithPath:@"/tmp/tmp.db"];
</code></pre>
在和数据库交互 之前，数据库必须是打开的。如果资源或权限不足无法打开或创建数据库，都会导致打开失败。
<pre><code>
if (![db open]) {
[db release];
return;
}
</code></pre>
执行更新
一切不是SELECT命令的命令都视为更新。这包括  CREATE, UPDATE, INSERT,ALTER,COMMIT, BEGIN, DETACH, DELETE, DROP, END, EXPLAIN, VACUUM, and REPLACE  （等）。
简单来说，只要不是以SELECT开头的命令都是UPDATE命令。
执行更新返回一个BOOL值。YES表示执行成功，否则表示有那些错误 。你可以调用 -lastErrorMessage 和 -lastErrorCode方法来得到更多信息。

执行查询
SELECT命令就是查询，执行查询的方法是以 -excuteQuery开头的。

执行查询时，如果成功返回FMResultSet对象， 错误返回nil. 与执行更新相当，支持使用 NSError**参数。同时，你也可以使用 -lastErrorCode和-lastErrorMessage获知错误信息。

为了遍历查询结果，你可以使用while循环。你还需要知道怎么跳到下一个记录。使用FMDB，很简单，就像这样：
<pre><code>
FMResultSet *s = [db executeQuery:@"SELECT * FROM myTable"];
while ([s next]) {
//retrieve values for each record
}
</code></pre>


<p>FMResultSet  提供了很多方法来获得所需的格式的值：</p>
<pre><code>
- (int)intForColumn:(NSString*)columnName;
- (int)intForColumnIndex:(int)columnIdx;

- (long)longForColumn:(NSString*)columnName;
- (long)longForColumnIndex:(int)columnIdx;

- (long long int)longLongIntForColumn:(NSString*)columnName;
- (long long int)longLongIntForColumnIndex:(int)columnIdx;

- (unsigned long long int)unsignedLongLongIntForColumn:(NSString*)columnName;
- (unsigned long long int)unsignedLongLongIntForColumnIndex:(int)columnIdx;

- (BOOL)boolForColumn:(NSString*)columnName;
- (BOOL)boolForColumnIndex:(int)columnIdx;

- (double)doubleForColumn:(NSString*)columnName;
- (double)doubleForColumnIndex:(int)columnIdx;

- (NSString*)stringForColumn:(NSString*)columnName;
- (NSString*)stringForColumnIndex:(int)columnIdx;

- (NSDate*)dateForColumn:(NSString*)columnName;
- (NSDate*)dateForColumnIndex:(int)columnIdx;

- (NSData*)dataForColumn:(NSString*)columnName;
- (NSData*)dataForColumnIndex:(int)columnIdx;

- (const unsigned char *)UTF8StringForColumnIndex:(int)columnIdx;
- (const unsigned char *)UTF8StringForColumnName:(NSString*)columnName;

// returns one of NSNumber, NSString, NSData, or NSNull
- (id)objectForColumnName:(NSString*)columnName;
- (id)objectForColumnIndex:(int)columnIdx;
</code></pre>

<p>通常，你不需要调用[FMResultSet close]来关闭结果集，它会在自身deallocate或者父数据库关闭的时候自动关闭</p>
<p>使用FMDatabaseQueue 及线程安全<br>在多个线程中同时使用一个FMDatabase实例是不明智的。最好为每个线程创建一个FMDatabase对象。 不要让多个线程分享同一个实例，它无法在多个线程中同时使用。 如果你这么干了，会有不好的事发生，程序会时经常崩溃，或者发生异常，或者陨石会从天上掉下来砸到你Mac Pro（官方说法…）.  总之很崩溃。所以，不要初始化FMDatabase对象，然后在多个线程中使用。请使用 FMDatabaseQueue，它是你的朋友而且会帮助你。以下是使用方法<br><code><pre><br>FMDatabaseQueue <em>queue = [FMDatabaseQueue databaseQueueWithPath:aPath];<br>[queue inTransaction:^(FMDatabase 
</em>db, BOOL <em>rollback) {<br>[db executeUpdate:@”INSERT INTO myTable VALUES (?)”, [NSNumber numberWithInt:1]];<br>[db executeUpdate:@”INSERT INTO myTable VALUES (?)”, [NSNumber numberWithInt:2]];<br>[db executeUpdate:@”INSERT INTO myTable VALUES (?)”, [NSNumber numberWithInt:3]];<br>if (whoopsSomethingWrongHappened) {
</em>rollback = YES;<br>return;<br>}<br>// etc…<br>[db executeUpdate:@”INSERT INTO myTable VALUES (?)”, [NSNumber numberWithInt:4]];<br>}];<br></pre></code></p>
<p>FMDatabaseQueue  后台会建立GCD队列（依据类名），并执行你传给G-C-D队列的块。这意味着 你从多线程同时调用调用方法，GCD也会按它接收的块的顺序来执行</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>FMDB是SQLite在oc下的封装，有三个主要的类。<br>]]>
    
    </summary>
    
      <category term="FMDB" scheme="http://linkageios.github.io/tags/FMDB/"/>
    
      <category term="iOS,数据库" scheme="http://linkageios.github.io/categories/iOS-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UICollectionView简介]]></title>
    <link href="http://linkageios.github.io/2014/11/24/UICollectionView%E7%AE%80%E4%BB%8B/"/>
    <id>http://linkageios.github.io/2014/11/24/UICollectionView简介/</id>
    <published>2014-11-24T05:38:14.000Z</published>
    <updated>2014-12-11T02:10:58.000Z</updated>
    <content type="html"><![CDATA[<p>UICollectionView是iOS6添加的一个控件，是一种新的数据展示方式，简单来说可以把他理解成多列的UITableView，最简单的UICollectionView就是一个GridView，可以以多列的方式将数据进行展示。<br><a id="more"></a></p>
<h1 id="UICollectionView简介">UICollectionView简介</h1>
<p>标准的UICollectionView包含三个部分，它们都是UIView的子类：<br>Cells 用于展示内容的主体，对于不同的cell可以指定不同尺寸和不同的内容<br>Supplementary Views 追加视图，可以理解为每个Section的Header或者Footer，用来标记每个section的view<br>Decoration Views 装饰视图 这是每个section的背景</p>
<h1 id="实现一个简单的UICollectionView">实现一个简单的UICollectionView</h1>
<p>实现一个UICollectionView和实现一个UITableView基本没有什么大区别，它们都同样是datasource+delegate</p>
<p>￼￼￼￼基本的UICollectionViewDataSource提供</p>
<pre><code>
￼-numberOfSectionsInCollection:  //section的数量
￼-collectionView:numberOfItemsInSection:  //某个section里有多少个item
￼-collectionView:cellForItemAtIndexPath: // 对于某个位置应该显示什么样的cell 

-collectionView:viewForSupplementaryElementOfKind:atIndexPath: //提供Supplementary View
</code></pre>

<p>与UITableView中的情况一致，UICollectionView也需要对Cell进行重用，在iOS5中，Apple对UITableView的重用做了简化，以往要写类似这样的代码：</p>
<pre><code>
UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"MY_CELL_ID"];  
if (!cell) {     
cell = [[UITableViewCell alloc] init]; 
} 
//配置cell，blablabla 
return cell 
</code></pre>
在iOS5以后如果我们在TableView向数据源请求数据之前使用-registerNib:forCellReuseIdentifier:方法为@“MYCELLID"注册过nib的话，就可以省下每次判断并初始化cell的代码，要是在重用队列里没有可用的cell的话，runtime将自动帮我们生成并初始化一个可用的cell，还有以下类似方法
<pre><code>
- (void)registerNib:(UINib *)nib forCellReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(5_0);
- (void)registerClass:(Class)cellClass forCellReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(6_0);

- (void)registerNib:(UINib *)nib forHeaderFooterViewReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(6_0);
- (void)registerClass:(Class)aClass forHeaderFooterViewReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(6_0);
</code></pre>

<p>同样的 UICollectionView也有类似的方法</p>
<pre><code>
- (void)registerClass:(Class)cellClass forCellWithReuseIdentifier:(NSString *)identifier;
- (void)registerNib:(UINib *)nib forCellWithReuseIdentifier:(NSString *)identifier;

- (void)registerClass:(Class)viewClass forSupplementaryViewOfKind:(NSString *)elementKind withReuseIdentifier:(NSString *)identifier;
- (void)registerNib:(UINib *)nib forSupplementaryViewOfKind:(NSString *)kind withReuseIdentifier:(NSString *)identifier;
</code></pre>

<p>基本的UICollectionViewDelegate提供与数据无关的view的外形，用户交互之类：</p>
<p>cell的高亮<br>cell的选中状态<br>可以支持长按后的菜单<br>关于用户交互，UICollectionView也做了改进。每个cell现在有独立的高亮事件和选中事件的delegate，用户点击cell的时候，现在会按照以下流程向delegate进行询问：</p>
<pre><code>
-￼collectionView:shouldHighlightItemAtIndexPath: // 是否应该高亮？
-￼collectionView:didHighlightItemAtIndexPath:  //如果1答是，那么高亮
-￼collectionView:shouldSelectItemAtIndexPath:  //无论1结果如何，都询问是否可以被选中？
-collectionView:didUnhighlightItemAtIndexPath: // 如果1答是，那么现在取消高亮
-collectionView:didSelectItemAtIndexPath: // 如果3答是，那么选中cell
</code></pre>

<h3 id="Cell">Cell</h3>
<p>UICollectionViewCell结构比较简单， 由上至下<br>首先是cell本身作为容器view<br>然后是一个大小自动适应整个cell的backgroundView，用作cell平时的背景<br>再其上是selectedBackgroundView，是cell被选中时的背景<br>最后是一个contentView，自定义内容应被加在这个view上</p>
<h3 id="￼UICollectionViewLayout">￼UICollectionViewLayout</h3>
<p>这是UICollectionView和UITableView最大的不同。UICollectionViewLayout负责了将各个cell、Supplementary View和Decoration Views进行组织，为它们设定各自的属性。在展示之前，一般需要生成合适的UICollectionViewLayout子类对象，并将其赋予CollectionView的collectionViewLayout属性。<br>SDK为我们提供了一个最简单可能也是最常用的默认layout对象，￼￼￼UICollectionViewFlowLayout。Flow Layout简单说是一个直线对齐的layout，最常见的Grid View形式即为一种Flow Layout配置:</p>
<p>首先一个重要的属性是itemSize，它定义了每一个item的大小。通过设定itemSize可以全局地改变所有cell的尺寸，如果想要对某个cell制定尺寸，可以使用-collectionView:layout:sizeForItemAtIndexPath:方法。<br>间隔 可以指定item之间的间隔和每一行之间的间隔，和size类似，有全局属性，也可以对每一个item和每一个section做出设定：</p>
<p><pre><code><br>@property (CGSize) minimumInteritemSpacing<br>@property (CGSize) minimumLineSpacing<br>-collectionView:layout:minimumInteritemSpacingForSectionAtIndex:<br>-collectionView:layout:minimumLineSpacingForSectionAtIndex:<br></code></pre><br>滚动方向 由属性scrollDirection确定scroll view的方向，将影响Flow Layout的基本方向和由header及footer确定的section之间的宽度</p>
<p>UICollectionViewScrollDirectionVertical<br>UICollectionViewScrollDirectionHorizontal<br>Header和Footer尺寸 同样地分为全局和部分。需要注意根据滚动方向不同，header和footer的高和宽中只有一个会起作用。垂直滚动时section间宽度为该尺寸的高，而水平滚动时为宽度起作用，如图。</p>
<p><pre><code><br>@property (CGSize) headerReferenceSize<br>@property (CGSize) footerReferenceSize<br>-collectionView:layout:referenceSizeForHeaderInSection:<br>-collectionView:layout:referenceSizeForFooterInSection:<br></code></pre><br>缩进</p>
<p><pre><code><br>@property UIEdgeInsets sectionInset;<br>-collectionView:layout:insetForSectionAtIndex:<br></code></pre><br>通过自定义Layout可以实现各种nb布局，基本上常见的类似的第三方开源控件效果都可以实现，比如瀑布流、coverFlow，下面实现一个基本的瀑流效果</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>UICollectionView是iOS6添加的一个控件，是一种新的数据展示方式，简单来说可以把他理解成多列的UITableView，最简单的UICollectionView就是一个GridView，可以以多列的方式将数据进行展示。<br>]]>
    
    </summary>
    
      <category term="UICollectionView" scheme="http://linkageios.github.io/tags/UICollectionView/"/>
    
      <category term="iOS,瀑布流" scheme="http://linkageios.github.io/categories/iOS-%E7%80%91%E5%B8%83%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LCBaseViewController相关]]></title>
    <link href="http://linkageios.github.io/2014/11/07/LCBaseViewController%E7%9B%B8%E5%85%B3/"/>
    <id>http://linkageios.github.io/2014/11/07/LCBaseViewController相关/</id>
    <published>2014-11-07T05:38:14.000Z</published>
    <updated>2014-11-18T09:20:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2>
<p>该基类参考原先项目中BaseViewController等几个类 进行修改 功能暂时满足目前项目需求 日后更新会根据项目迭代中提出的需求在进行修改</p>
<h2 id="属性和函数说明">属性和函数说明</h2>
<p>LCViewControllerShowType：viewController出现的方式 具体分为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LCViewControllerShowTypePush                （<span class="keyword">pop</span>/<span class="keyword">push</span>方式）（默认）</div><div class="line">LCViewControllerShowTypePresent             （present/dismiss方式）</div><div class="line">LCViewControllerShowTypePresentBasic        （作为没有登录的情况下，登陆界面返回按钮 跳转到首页的凭据）</div></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="简介-1">简介</h2>
<p>该基类参考原先项目中BaseViewController等几个类 进行修改 功能暂时满足目前项目需求 日后更新会根据项目迭代中提出的需求在进行修改</p>
<h2 id="属性和函数说明-1">属性和函数说明</h2>
<p>LCViewControllerShowType：viewController出现的方式 具体分为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LCViewControllerShowTypePush                （<span class="keyword">pop</span>/<span class="keyword">push</span>方式）（默认）</div><div class="line">LCViewControllerShowTypePresent             （present/dismiss方式）</div><div class="line">LCViewControllerShowTypePresentBasic        （作为没有登录的情况下，登陆界面返回按钮 跳转到首页的凭据）</div></pre></td></tr></table></figure>

<p>LCNavigationBarStyle： navigationBar 的样式 主要是背景色</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">LCNavigationBarRed</span>             navigationBar 一级,红色背景</div></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/79888-d6fa0aed379b25d2.png" alt="LCNavigationBarRed"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">LCNavigationBarWhite</span>          navigationBar 二级,白色背景（默认）</div></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/79888-6225382ae2b09d27.png" alt="LCNavigationBarWhite"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">LCNavigationBarNull</span>             navigationBar 二级,隐藏navigaitonbar</div></pre></td></tr></table></figure>

<p>提供函数方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//设置导航栏背景图片</div><div class="line"><span class="pp">- <span class="params">(void)</span>configNavigationBarBgImage;</span></div><div class="line">//设置左边的返回按钮</div><div class="line">- <span class="params">(void)</span>setLeftBackButton;</div><div class="line">- <span class="params">(void)</span>setLeftBackButtonAction:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//设置左边的返回按钮<span class="params">(图片按钮)</span></div><div class="line">- <span class="params">(void)</span>setLeftButtonWithImageName:<span class="params">(<span class="variable">NSString</span>*)</span>imageName action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//设置左边的返回按钮<span class="params">(文字按钮)</span></div><div class="line">- <span class="params">(void)</span>setLeftButtonWithTitle:<span class="params">(<span class="variable">NSString</span>*)</span>title action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//设置左边的返回按钮<span class="params">(通用按钮)</span></div><div class="line">- <span class="params">(void)</span>setLeftButton:<span class="params">(<span class="variable">UIButton</span>*)</span>button action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//设置中间的文本标题</div><div class="line">- <span class="params">(void)</span>setTitleViewWithText:<span class="params">(<span class="variable">NSString</span>*)</span>text;</div><div class="line">//设置右边的按钮<span class="params">(文字按钮)</span></div><div class="line">- <span class="params">(void)</span>setRightButtonWithTitle:<span class="params">(<span class="variable">NSString</span>*)</span>title action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//设置右边的按钮<span class="params">(图片按钮)</span></div><div class="line">- <span class="params">(void)</span>setRightButtonWithImageName:<span class="params">(<span class="variable">NSString</span>*)</span>imageName action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">- <span class="params">(void)</span>setRightButtonWithNormarlImageName:<span class="params">(<span class="variable">NSString</span>*)</span>normarName highlightedImageName:<span class="params">(<span class="variable">NSString</span> *)</span>highlightedName action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//设置右边的按钮</div><div class="line">- <span class="params">(void)</span>setRightButton:<span class="params">(<span class="variable">UIButton</span>*)</span>button action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//多个按钮 分别有文字或图片 （btnStrs 中vo 为dic 具体参考下面栗子）</div><div class="line">- <span class="params">(void)</span>setRightButtons:<span class="params">(<span class="variable">NSArray</span> *)</span>btnStrs;</div><div class="line">- <span class="params">(void)</span>setRightButtonImages:<span class="params">(<span class="variable">NSArray</span> *)</span>images;</div><div class="line">- <span class="params">(void)</span>rightButtonAction:<span class="params">(id)</span>sender;</div><div class="line">//返回按钮的响应事件</div><div class="line">- <span class="params">(void)</span>backButtonPressed:<span class="params">(id)</span>sender;</div></pre></td></tr></table></figure>

<p>提供方法中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>setRightButtons:<span class="params">(<span class="variable">NSArray</span> *)</span>btnStrs;</span></div></pre></td></tr></table></figure>

<p>btnStrs为包含vo对象的一个数组</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">vo =</span> {</div><div class="line">@<span class="string">" title"</span>     : @<span class="string">"返回"</span>,</div><div class="line">@<span class="string">"normalImage"</span>:@<span class="string">"fanhui.png"</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>具体使用为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *rightbarButtonVos = @[@{<span class="string">@"title"</span>:<span class="string">@"第一个"</span>,<span class="string">@"normalImage"</span>:<span class="string">@"first.png"</span>},@{<span class="string">@"title"</span>:<span class="string">@"第二个"</span>,<span class="string">@"normalImage"</span>:<span class="string">@"second.png"</span>}];</div><div class="line">[<span class="keyword">self</span> setRightButtons: rightbarButtonVos];</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简介">简介</h2>
<p>该基类参考原先项目中BaseViewController等几个类 进行修改 功能暂时满足目前项目需求 日后更新会根据项目迭代中提出的需求在进行修改</p>
<h2 id="属性和函数说明">属性和函数说明</h2>
<p>LCViewControllerShowType：viewController出现的方式 具体分为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LCViewControllerShowTypePush                （<span class="keyword">pop</span>/<span class="keyword">push</span>方式）（默认）</div><div class="line">LCViewControllerShowTypePresent             （present/dismiss方式）</div><div class="line">LCViewControllerShowTypePresentBasic        （作为没有登录的情况下，登陆界面返回按钮 跳转到首页的凭据）</div></pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="LCBaseViewController" scheme="http://linkageios.github.io/tags/LCBaseViewController/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[测试Json效率和XML效率]]></title>
    <link href="http://linkageios.github.io/2014/11/07/%E6%B5%8B%E8%AF%95Json%E6%95%88%E7%8E%87%E5%92%8CXML%E6%95%88%E7%8E%87/"/>
    <id>http://linkageios.github.io/2014/11/07/测试Json效率和XML效率/</id>
    <published>2014-11-07T05:38:14.000Z</published>
    <updated>2014-12-03T02:50:04.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li><p>tips：把项目中的解析json的sbjson ,网上提到的JsonKit和apple提供的自带json解析方法进行比较<br>所解析的json是来自项目当中服务返回的商家列表信息<br>具体如下图</p>
<a id="more"></a>
</li>
<li><p>tips：把项目中的解析json的sbjson ,网上提到的JsonKit和apple提供的自带json解析方法进行比较<br>所解析的json是来自项目当中服务返回的商家列表信息<br>具体如下图<br><img src="/images/79888-1946ee461177aeca.png" alt="imag"><br>开始先去 请求 商家列表信息 ，请求成功之后 会有弹出框提示</p>
<a id="more"></a></li>
<li>tips：把项目中的解析json的sbjson ,网上提到的JsonKit和apple提供的自带json解析方法进行比较<br>所解析的json是来自项目当中服务返回的商家列表信息<br>具体如下图<br><img src="/images/79888-1946ee461177aeca.png" alt="imag"><br>开始先去 请求 商家列表信息 ，请求成功之后 会有弹出框提示</li>
</ul>
<p><img src="/images/79888-bd0e36d1d14085ea.png" alt="imag"><br>之后可以依次测试三种解析，具体看demo提示<br>结果：JSONKit 效率最接近苹果原生</p>
<ul>
<li>tips：针对项目中的车型xml文件，对比XMLDictionary和苹果自带xml解析的效率<br>解析的对象就是 项目当中的车型库文件</li>
</ul>
<p><img src="/images/79888-e567a1bfada45c8c.png" alt="imag"><br>每个解析方法 解析1000次 具体实现看demo<br>结果：XMLDictionary因为是 宽泛适应的解析 比demo中的针对特定文件写的解析是要慢些，但是今后将取消xml读取文件，这个也就没什么需要考虑的了</p>
]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><p>tips：把项目中的解析json的sbjson ,网上提到的JsonKit和apple提供的自带json解析方法进行比较<br>所解析的json是来自项目当中服务返回的商家列表信息<br>具体如下图</p>
<!--more-->
</li>
<li><p>tips：把项目中的解析json的sbjson ,网上提到的JsonKit和apple提供的自带json解析方法进行比较<br>所解析的json是来自项目当中服务返回的商家列表信息<br>具体如下图<br><img src="/images/79888-1946ee461177aeca.png" alt="imag"><br>开始先去 请求 商家列表信息 ，请求成功之后 会有弹出框提示</p>
]]>
    
    </summary>
    
      <category term="xml" scheme="http://linkageios.github.io/tags/xml/"/>
    
      <category term="json" scheme="http://linkageios.github.io/tags/json/"/>
    
      <category term="效率" scheme="http://linkageios.github.io/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS代码规范]]></title>
    <link href="http://linkageios.github.io/2014/11/07/iOS%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://linkageios.github.io/2014/11/07/iOS编码规范/</id>
    <published>2014-11-07T05:38:14.000Z</published>
    <updated>2014-11-18T10:26:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="为什么要有代码规范？">为什么要有代码规范？</h1>
<p>对于团队，如果代码风格不统一，阅读或修改同事的代码会非常困难，造成潜在的风险。</p>
<p>对于个人，代码规范是对自身编码习惯的一种监督，如果没有这种监督，有时候因为偷懒，会写出难看的代码，时间长了自己都看不懂。这样对于代码的维护性是不利的。</p>
<h1 id="代码规范的内容？">代码规范的内容？</h1>
<p>代码规范包含的范围十分广泛。从一个变量的命名到一个类的设计，我觉得都属于代码规范的范畴。从实践的角度，可以把代码规范分成两个部分：</p>
<p>第一部分是规则，即一定要这么做。这里面没有对错，但需要统一。包含变量的命名、函数的命名、模块的组织、代码块的组织、宏、枚举、常量的声明、函数的粒度。</p>
<p>第二部分是风格，即一种模式化的代码设计结构。我们实现某个功能时，往往不止一种实现方式。每一种实现方式没有绝对的高低之分，不同角度的解读，就会有不同的偏好。所以这个层面上的代码规范，只能求同存异。但是不管怎样，每个人必须要有一致性的风格。就像不同的小区可以有不同的风格，但同一个小区只能有一种设计风格。风格包含代码设计中的抽象概念，比如接口、继承等等。<br><a id="more"></a></p>
<h1 id="为什么要有代码规范？-1">为什么要有代码规范？</h1>
<p>对于团队，如果代码风格不统一，阅读或修改同事的代码会非常困难，造成潜在的风险。</p>
<p>对于个人，代码规范是对自身编码习惯的一种监督，如果没有这种监督，有时候因为偷懒，会写出难看的代码，时间长了自己都看不懂。这样对于代码的维护性是不利的。</p>
<h1 id="代码规范的内容？-1">代码规范的内容？</h1>
<p>代码规范包含的范围十分广泛。从一个变量的命名到一个类的设计，我觉得都属于代码规范的范畴。从实践的角度，可以把代码规范分成两个部分：</p>
<p>第一部分是规则，即一定要这么做。这里面没有对错，但需要统一。包含变量的命名、函数的命名、模块的组织、代码块的组织、宏、枚举、常量的声明、函数的粒度。</p>
<p>第二部分是风格，即一种模式化的代码设计结构。我们实现某个功能时，往往不止一种实现方式。每一种实现方式没有绝对的高低之分，不同角度的解读，就会有不同的偏好。所以这个层面上的代码规范，只能求同存异。但是不管怎样，每个人必须要有一致性的风格。就像不同的小区可以有不同的风格，但同一个小区只能有一种设计风格。风格包含代码设计中的抽象概念，比如接口、继承等等。</p>
<h1 id="代码的规则">代码的规则</h1>
<p>规则如同法律，尽管从心底里很多人不认可，但每个人都必须遵守。看起来大家都受了束缚，但是对整个社会以及每一个人都是利大于弊。</p>
<h2 id="变量命名">变量命名</h2>
<p>变量命名历史上产生过很多方法，比较著名的有匈牙利命名法、驼峰命名法、下划线命名法。</p>
<ul>
<li>匈牙利命名法：szUserName</li>
<li>驼峰命名法：userName</li>
<li>下划线命名法：user_name</li>
</ul>
<p>用Objective-C开发，我们就参考苹果的官方命名方式即可，苹果采用的是驼峰命名法。</p>
<p>苹果的变量命名方式常常被其它语言的开发者所吐槽，因为它的名有时候是在太长了！！！下面是3个最长的Objective-C属性名：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">automaticallyEnablesStillImageStabilizationWhenAvailable</span></div><div class="line">availableMediaCharacteristicsWithMediaSelectionOptions</div><div class="line">outputObscuredDueToInsufficientExternalProtection</div></pre></td></tr></table></figure>

<p>变量声明最重要的是清晰其次才考虑长短，如果为了简短而含糊不清，是不可取的。</p>
<p>拿现有代码举例</p>
<table>
<thead>
<tr>
<th style="text-align:left">变量含义</th>
<th style="text-align:left">Not Good</th>
<th style="text-align:left">Good</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">昵称输入框</td>
<td style="text-align:left">tfNickName</td>
<td style="text-align:left">nickNameTextField</td>
</tr>
<tr>
<td style="text-align:left">密码ImageView</td>
<td style="text-align:left">imvPass</td>
<td style="text-align:left">passwordImageView</td>
</tr>
<tr>
<td style="text-align:left">我的搜索条</td>
<td style="text-align:left">mysearchBar</td>
<td style="text-align:left">mySearchBar</td>
</tr>
</tbody>
</table>
<p><strong>类变量</strong><br>前面加下划线，和系统框架保持一致</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">@interface UIViewController : UIResponder &lt;NSCoding, UIAppearanceContainer&gt; </span></div><div class="line">{</div><div class="line">    UIView           <span class="keyword">*</span>_view;</div><div class="line">    UITabBarItem     <span class="keyword">*</span>_tabBarItem;</div><div class="line">    UINavigationItem <span class="keyword">*</span>_navigationItem;</div><div class="line">    NSArray          <span class="keyword">*</span>_toolbarItems;</div><div class="line">    NSString         <span class="keyword">*</span>_title;</div><div class="line">    NSString         <span class="keyword">*</span>_nibName;</div><div class="line">    NSBundle         <span class="keyword">*</span>_nibBundle;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现有的例子</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CouponListTableViewCell</span> : <span class="title">UITableViewCell</span></span></div><div class="line">{</div><div class="line">    <span class="built_in">UIImageView</span> *imageIcon;</div><div class="line">    <span class="built_in">UIImageView</span> *imageCollect;</div><div class="line">    <span class="built_in">UILabel</span> *labelName;</div><div class="line">    <span class="built_in">UILabel</span> *labelPriceSale;</div><div class="line">    <span class="built_in">UILabel</span> *labelPriceOrigin;</div><div class="line">    <span class="built_in">UILabel</span> *labelSaleNumber;</div><div class="line">    <span class="built_in">UIImageView</span> *imageArrow;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>类变量与属性</strong><br>属性是Objective-C的一种高级语法，属性可以完全替换类变量，并且提供更强大的访问控制（strong、weak、nonatomic、readonly…）,而且属性也只需要用一行就能搞定，所以为什么还要用类变量呢？<br>属性声明后不用写@synthesize，且会自动生成类变量。<br><!--
 [资料>](http://stackoverflow.com/questions/12119284/xcode-4-automatically-generates-ivars-when-using-property-where-can-i-find-the)
--></p>
<p><strong>例外</strong></p>
<ul>
<li>一些局部变量允许用最简单的方式命名：i、j、temp</li>
<li>一些常用的缩写可以不用驼峰：RMB，OBD</li>
</ul>
<h2 id="函数命名">函数命名</h2>
<p>Objective-C中的函数不同于其他语言，函数名是按参数隔开的。初看起来是有点怪，但是习惯了就会发现这样和命名方式可读性极好，就像一句话一样。所以当你的函数名不能流利的读出来的话，那么它的命名肯定就有问题。<br>还是先举系统的例子</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>willAnimateFirstHalfOfRotationToInterfaceOrientation:<span class="params">(<span class="variable">UIInterfaceOrientation</span>)</span>toInterfaceOrientation </span></div><div class="line">                                                    duration:<span class="params">(<span class="variable">NSTimeInterval</span>)</span>duration</div></pre></td></tr></table></figure>

<p>这里面值得注意的几点：</p>
<ul>
<li>最左边的（+、-）和返回类型的左括号之间有一个空格，返回类型的右括号与第一个参数之间没有空格；</li>
<li>函数名中每一段描述都以小写字母开头，描述的写法要考虑清晰明确，参考变量命名；</li>
<li>如果函数名过长，应该换行，按冒号对齐；</li>
<li>从描述中可以看出对应参数的意义。</li>
</ul>
<p>再看看我们自己的命名</p>
<ol>
<li>最后一个参数描述Selector首字母大写了</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (<span class="tag">UIButton</span> *)<span class="tag">createButton</span><span class="pseudo">:(MUButtonItemAttribute</span> *)<span class="tag">attr</span> </div><div class="line">               <span class="tag">target</span><span class="pseudo">:(id)target</span> </div><div class="line">             <span class="tag">Selector</span><span class="pseudo">:(SEL)sel</span>;</div></pre></td></tr></table></figure>

<ol>
<li>有一些多余的空格</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="addition">+ (AppDelegate *) appDelegate;</span></div><div class="line"><span class="deletion">- (void)hideTabbar :(BOOL)status;</span></div></pre></td></tr></table></figure>

<ol>
<li>加减号和括号之间要有空格</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>pushEvent:<span class="params">(<span class="variable">NSDictionary</span>*)</span>dictionary target:<span class="params">(id)</span>target;</span></div></pre></td></tr></table></figure>


<ol>
<li>参数名和参数要对应，含义清晰</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>setNavBackButton:<span class="params">(<span class="variable">NSString</span> *)</span>string;</span></div><div class="line">- <span class="params">(id)</span>init:<span class="params">(<span class="variable">NSString</span>*)</span>nickName phoneNumber:<span class="params">(<span class="variable">NSString</span> *)</span>phoneNumber;</div><div class="line">- <span class="params">(void)</span>setTextFieldBackGroud:<span class="params">(<span class="variable">CGRect</span>)</span>rect;</div><div class="line">- <span class="params">(id)</span>init:<span class="params">(<span class="variable">NSInteger</span>)</span>flag;</div><div class="line">- <span class="params">(void)</span>requestHealthRecord:<span class="params">(<span class="variable">NSString</span> *)</span>typeStr;</div></pre></td></tr></table></figure>

<ol>
<li>函数名过长要换行</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(id)</span>initWithStyle:<span class="params">(<span class="variable">UITableViewCellStyle</span>)</span>style</span></div><div class="line">    reuseIdentifier:<span class="params">(<span class="variable">NSString</span> *)</span>reuseIdentifier</div><div class="line">containingTableView:<span class="params">(<span class="variable">UITableView</span> *)</span>containingTableView</div><div class="line"> leftUtilityButtons:<span class="params">(<span class="variable">NSArray</span> *)</span>leftUtilityButtons </div><div class="line">rightUtilityButtons:<span class="params">(<span class="variable">NSArray</span> *)</span>rightUtilityButtons;</div></pre></td></tr></table></figure>

<ol>
<li>命名风格混乱</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (NSInteger)GetServerBack:(NSString *)serverName</div><div class="line">                path_Param:(NSMutableDictionary*)path_Param</div><div class="line">               query_Param:(NSMutableDictionary*)query_Param</div><div class="line">                body_Param:(NSMutableDictionary*)body_Param</div><div class="line">                    <span class="function"><span class="keyword">method</span>:</span>(NSInteger)<span class="function"><span class="keyword">method</span></span></div><div class="line">               <span class="title">returnValue</span>:(NSMutableDictionary*)returnValue;</div></pre></td></tr></table></figure>

<ol>
<li>参数之间用and、with，多此一举</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(id)</span>initWithFrame:<span class="params">(<span class="variable">CGRect</span>)</span>frame </span></div><div class="line">       andImageView:<span class="params">(<span class="variable">UIImageView</span>*)</span>imageView </div><div class="line">     withImageFrame:<span class="params">(<span class="variable">CGRect</span>)</span>imageInitFrame </div><div class="line">       withImageUrl:<span class="params">(<span class="variable">NSURL</span>*)</span>imageUrl;</div></pre></td></tr></table></figure>


<p><strong>命名很重要！！！</strong><br>良好的命名是写出高质量代码的前提，命名的时候除了符合以上的规范，还需要找到合适的单词来表达含义，不要为了一时之快用拼音，也千万不要出现数字。</p>
<h2 id="代码模块组织">代码模块组织</h2>
<p>这个代码模块的组织是指文件级别的，即我们应该如何划分包。<br>现有的包结构是有些问题的，导致我们找某个功能的实现文件比较麻烦。<br><a href="!--
参考[别人的经验](http://www.cocoachina.com/industry/20140225/7879.html)，个人觉得这样的划分还是不错的。
--">!--
参考[别人的经验](http://www.cocoachina.com/industry/20140225/7879.html)，个人觉得这样的划分还是不错的。
--</a></p>
<p><strong>文件的命名</strong><br>我们自己创建的文件，应该有统一的前缀。比如HJMainViewController，这也符合系统的命名规范。Objective-C没有namespace，所以这样做的好处是当你引用了第三方的代码时，防止重名。而且当我们自己的代码越来越大时，内部也会出现冲突。</p>
<p><strong>一个文件一个类</strong><br>好处：</p>
<ul>
<li>减少单个文件的长度</li>
<li>定位文件更方便</li>
<li>便于重用</li>
</ul>
<h2 id="代码块的组织">代码块的组织</h2>
<p>作为一个程序员，大部分时间实在看代码而不是在写。所以代码的可读性严重影响到我们的工作效率。<br>当你看到超过1000行的实现文件时，你还有看下去的欲望吗？<br>所以千万不要写出超过1000行的代码，有的话也得重构。<br><!--[重构掉](http://www.objc.io/issue-1/)。 --></p>
<p>当代码控制到1000行以内后，只是具备了可读的基本条件。我们的屏幕一般只能一次显示50行代码，从头看到尾就是20屏，常常会看了后面忘了前面。所以我们要把一个文件里面的所有函数有秩序的组织起来，让人不用重头看到尾，就能很快定位到想看的地方。<br>这里提供一个小办法：用#pragma mark宏根据功能区分开:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pragma mark - Life Circle</div><div class="line">pragma mark - <span class="keyword">Public</span> <span class="keyword">Interface</span></div><div class="line">pragma mark - UI Actions</div><div class="line">pragma mark - Business Logic</div><div class="line">pragma mark - UITableViewDataSource</div><div class="line">pragma mark - UITableViewDelegate</div><div class="line">pragma mark - UIScrollViewDelegate</div><div class="line">pragma mark - Notification Handle</div><div class="line">pragma mark - <span class="keyword">Private</span> <span class="function"><span class="keyword">Method</span></span></div></pre></td></tr></table></figure>

<h2 id="宏、枚举、常量的声明">宏、枚举、常量的声明</h2>
<p>宏的命名方式参考变量的命名方式，大写，用下划线分开</p>
<figure class="highlight TARGET_OS_IPHONE```"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">枚举也有很多写法，这里推荐系统的方式</div></pre></td></tr></table></figure>

<p>typedef NS_ENUM(NSInteger, NSTextAlignment)<br>{<br>    NSTextAlignmentLeft      = 0,    // Visually left aligned<br>    NSTextAlignmentRight     = 1,    // Visually right aligned<br>    NSTextAlignmentCenter    = 2,    // Visually centered<br>    NSTextAlignmentJustified = 3,    // Fully-justified. The last line in a paragraph is natural-aligned.<br>    NSTextAlignmentNatural   = 4,    // Indicates the default alignment for script<br>} </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">常量以k开头，系统命名风格</div></pre></td></tr></table></figure>

<p>extern NSString <em>const kAPNetworkDidSetupNotification;     // 建立连接<br>extern NSString </em>const kAPNetworkDidCloseNotification;     // 关闭连接<br>extern NSString <em>const kAPNetworkDidRegisterNotification;  // 注册成功<br>extern NSString </em>const kAPNetworkDidLoginNotification;     // 登录成功</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如果是数值常量，用宏的话，也可以用k开头</div></pre></td></tr></table></figure>

<h1 id="define_kDistancePoint_10-0f_//_圆点、标志和正文的间距">define kDistancePoint  10.0f   // 圆点、标志和正文的间距</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">## 函数的粒度</span></div><div class="line">知道我们现在最长的函数有多少行吗？<span class="number">655</span>行。</div></pre></td></tr></table></figure>

<ul>
<li>(void)getShopDetail</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">一个函数最好不超过一屏（50行），千万不能超过两屏（100行）。</div><div class="line">因为从设计的角度来说，一个函数只需要干一件事，所以50行一般是够的，超长的函数往往干了很多事情，或者干了一件很大的事（拆成多件小事，交给子函数去干）。</div><div class="line"></div><div class="line"><span class="comment">## 其它</span></div><div class="line"></div><div class="line">- <span class="keyword">*</span><span class="keyword">*</span>Log<span class="keyword">*</span><span class="keyword">*</span>：不要使用NSLog，提交了会因想到别人，而且最后打包删起来麻烦。需要找一个Log工具，MyNSLog功能不够。</div><div class="line">- <span class="keyword">*</span><span class="keyword">*</span>代码中尽量不要出现数字<span class="keyword">*</span><span class="keyword">*</span>：据上下文推测出来的，还是计算的出为好（现在界面里面很多地方确实要写死数字，适配iPhone6会很困难）</div></pre></td></tr></table></figure>

<p>_contentBkg = [[UIView alloc] initWithFrame:CGRectMake(0, 1 / [UIScreen mainScreen].scale, 320, 68 - 1)];</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">*</span><span class="keyword">*</span>避免复杂的表达式<span class="keyword">*</span><span class="keyword">*</span>：</div></pre></td></tr></table></figure>

<pre><code><span class="keyword">if</span> (tfPassword.<span class="keyword">text</span>!=nil &amp;&amp;
    ![tfPassword.<span class="keyword">text</span> isEqualToString:@<span class="string">""</span>] &amp;&amp;
    tfRequestNumber.<span class="keyword">text</span>!=nil &amp;&amp;
    ![tfRequestNumber.<span class="keyword">text</span> isEqualToString:@<span class="string">""</span>]
    )
{
;    
}
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">*</span><span class="keyword">*</span>一个变量不在多个函数中出现，不要作为类变量：<span class="keyword">*</span><span class="keyword">*</span></div></pre></td></tr></table></figure>

<p>MBProgressHUD* hudProgress;<br>int result;</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">*</span><span class="keyword">*</span>每个类的.h开头的地方要有注释，说明这个类是干嘛的<span class="keyword">*</span><span class="keyword">*</span></div><div class="line">-</div></pre></td></tr></table></figure>

<p>/**</p>
<ul>
<li>SDImageCache maintains a memory cache and an optional disk cache. Disk cache write operations are performed</li>
<li>asynchronous so it doesn’t add unnecessary latency to the UI.<br>*/<br>@interface SDImageCache : NSObject</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">*</span><span class="keyword">*</span>if后面的语句哪怕只有一行，都加括号<span class="keyword">*</span><span class="keyword">*</span></div></pre></td></tr></table></figure>

<p>if ([key rangeOfString:@”热”].location != NSNotFound)<br>{<br>    titleLabel.text = @”热门城市”;<br>}<br>else<br>{<br>    titleLabel.text = key;<br>}</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="preprocessor"># 代码的风格</span></div><div class="line"></div><div class="line">风格如同习俗，不同地区有不同的习俗。你觉得入乡随俗好，就入乡随俗，这样避免了一些无谓的麻烦；但是你若坚持原有的习俗，社会也是能接受的，毕竟这些东西都是发展变化的，没有固定的模式，只有更好的模式。</div><div class="line"></div><div class="line"><span class="preprocessor">## 接口</span></div><div class="line">这里的接口指的是一个类公开的一组方法，良好设计的类是高内聚低耦合的，所以接口必须是简洁的。</div></pre></td></tr></table></figure>

<p>@interface PaySucceedViewController : LCBaseViewController</p>
<p>@property (nonatomic,retain) NSString *isSuccess;</p>
<p>@property (nonatomic,retain) NSString *shopName;</p>
<p>@property (nonatomic,retain) NSString *detailinfo;</p>
<p>@property (nonatomic,retain) NSString *amount;</p>
<p>@property (nonatomic,retain) NSString *omsOrderId;</p>
<p>/*</p>
<ul>
<li>支付订单类型<br>*</li>
<li>@since<br>*/<br>@property (nonatomic) ORDER_CATEGORY mCategory;</li>
</ul>
<p>@end<br>```<br>上面的例子是一个ViewController，但是它暴露了太多属性，属性很零碎，传值的时候要一个一个传。其实这里属性应该属于一个叫订单Model的对象，把这些属性封装在OrderModel中，复用性和可维护性都会好很多。（但是现在代码整体结构没有Model层，这里需要很大的重构）</p>
<h2 id="继承">继承</h2>
<p>继承不是为了少写代码，它的目的是抽象，顺便少写了代码。<br>举NavigationBar的例子，用宏可以实现，用基类也可以实现，但基类抽象出了一个共有的接口，以后发生共性的变化够可以通过修改基类来实现，你可以在基类里加一组方法，而宏做不到。</p>
<h2 id="其它">其它</h2>
<p>代码规范的路还长着，先走出第一步吧！</p>
<h1 id="参考资料">参考资料</h1>
<p><a href="./CodingGuidelines.pdf">Apple代码规范</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="为什么要有代码规范？">为什么要有代码规范？</h1>
<p>对于团队，如果代码风格不统一，阅读或修改同事的代码会非常困难，造成潜在的风险。</p>
<p>对于个人，代码规范是对自身编码习惯的一种监督，如果没有这种监督，有时候因为偷懒，会写出难看的代码，时间长了自己都看不懂。这样对于代码的维护性是不利的。</p>
<h1 id="代码规范的内容？">代码规范的内容？</h1>
<p>代码规范包含的范围十分广泛。从一个变量的命名到一个类的设计，我觉得都属于代码规范的范畴。从实践的角度，可以把代码规范分成两个部分：</p>
<p>第一部分是规则，即一定要这么做。这里面没有对错，但需要统一。包含变量的命名、函数的命名、模块的组织、代码块的组织、宏、枚举、常量的声明、函数的粒度。</p>
<p>第二部分是风格，即一种模式化的代码设计结构。我们实现某个功能时，往往不止一种实现方式。每一种实现方式没有绝对的高低之分，不同角度的解读，就会有不同的偏好。所以这个层面上的代码规范，只能求同存异。但是不管怎样，每个人必须要有一致性的风格。就像不同的小区可以有不同的风格，但同一个小区只能有一种设计风格。风格包含代码设计中的抽象概念，比如接口、继承等等。<br>]]>
    
    </summary>
    
      <category term="规范" scheme="http://linkageios.github.io/tags/%E8%A7%84%E8%8C%83/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LCDataManager相关说明]]></title>
    <link href="http://linkageios.github.io/2014/11/07/LCDataManager%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"/>
    <id>http://linkageios.github.io/2014/11/07/LCDataManager相关说明/</id>
    <published>2014-11-07T05:38:14.000Z</published>
    <updated>2014-11-18T10:35:55.000Z</updated>
    <content type="html"><![CDATA[<h6 id="#_文章参照cucuz的数据存储Library"># 文章参照cucuz的数据存储Library</h6>
<p><strong>类 的目的</strong></p>
<p>方便项目当中数据的存储，提供简单的接口供使用,根据存储的位置划分可以分为缓存和本地存储，<br>其中包括</p>
<pre><code><span class="built_in">NSArray</span>, <span class="built_in">NSDictionary</span>, NSData,<span class="built_in">NSString</span>,<span class="built_in">UIImage</span> 等常用数据类型，自定义Object(自行实现NSCoding协议)
</code></pre><p><strong>类的函数介绍</strong></p>
<ul>
<li>类初始化(单例)</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">LCDataManager *dataManager </span>=<span class="string"> [LCDataManager shareManager];</span></div></pre></td></tr></table></figure>

<p>首先，我们创建一个对象，下文将以它作为存储的一个依据</p>
<h2 id="Cache_block">Cache block</h2>
<p><a id="more"></a></p>
<h6 id="#_文章参照cucuz的数据存储Library-1"># 文章参照cucuz的数据存储Library</h6>
<p><strong>类 的目的</strong></p>
<p>方便项目当中数据的存储，提供简单的接口供使用,根据存储的位置划分可以分为缓存和本地存储，<br>其中包括</p>
<pre><code><span class="built_in">NSArray</span>, <span class="built_in">NSDictionary</span>, NSData,<span class="built_in">NSString</span>,<span class="built_in">UIImage</span> 等常用数据类型，自定义Object(自行实现NSCoding协议)
</code></pre><p><strong>类的函数介绍</strong></p>
<ul>
<li>类初始化(单例)</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">LCDataManager *dataManager </span>=<span class="string"> [LCDataManager shareManager];</span></div></pre></td></tr></table></figure>

<p>首先，我们创建一个对象，下文将以它作为存储的一个依据</p>
<h2 id="Cache_block-1">Cache block</h2>
<ul>
<li>Cache的存储</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>putObject:<span class="params">(id)</span>object inKey:<span class="params">(<span class="variable">NSString</span> *)</span>key underType:<span class="params">(<span class="variable">LCCACHETYPE</span>)</span>type;</span></div></pre></td></tr></table></figure>

<p>函数用意是 把</p>
<figure class="highlight object```以关键字```key```存储到```type```类型下。其实，本身```dataManager"><figcaption><span>```中存在一个```MutbaleDictionary *cacheMutableDictionary``` ，它是以```LCCACHETYPE ```中的类别为关键字建立的字典，该存储函数中的```key```则是这个```cacheMutableDictionary ```中对应```type```下的关键字，简单说就是“字典中字典的关键字”。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="undefined">其中</span></div></pre></td></tr></table></figure>

<p>LCCACHETYPE</p>
<figure class="highlight 是提供的数据分类"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>

<p>typedef NS_ENUM(NSInteger, LCCACHETYPE)<br>{<br>LCCacheImage            =  0,<br>LCCacheData             =  1,<br>LCCacheFile             =  2,<br>LCCacheTmp              =  3,<br>LCCacheNeverRelease     =  4,<br>};</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

<p>putObject</p>
<figure class="highlight 用法"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>

<p>NSArray *CacheLists = @[@”老大”,@”老二”,@”老三”];<br>BOOL ret = [dataManager  putObject:CacheLists inKey:@”order” underType:LCCacheData];</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">其他类型以此类推</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="deletion">- Cache的获取</span></div></pre></td></tr></table></figure>

<ul>
<li>(id)getObjectForKey:(NSString *)key underType:(LCCACHETYPE)type;</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">这个就是上面存储函数对应的一个<span class="keyword">get</span>函数，他的参数和上面函数是一样的，不过多说明</div><div class="line"></div><div class="line">-</div></pre></td></tr></table></figure>

<p>getObjectForKey</p>
<figure class="highlight 用法"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="protobuf"><span class="constant">	NSArray *fetchCacheLists</span> = [dataManager getObjectForKey:@<span class="string">"order"</span>] 	underType: LCCacheData;</span></div><div class="line"></div><div class="line">其他类型以此类推</div><div class="line"></div><div class="line">- Cache的清除</div><div class="line"></div><div class="line">这里提供了<span class="number">3</span>个清除方法，是针对需要清除的模块的范围划分的:</div></pre></td></tr></table></figure>

<ul>
<li>(void)clearObjectForKey:(NSString *)key underType:(LCCACHETYPE)type;</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面这个方法是最细的一个清除，他是清除到类别下面的关键字对应的数据</div></pre></td></tr></table></figure>

<ul>
<li>(void)clearObjectsUnderType:(LCCACHETYPE)type;</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">上面这个方法清除的是一个类别下所有的关键字包含的数据</div></pre></td></tr></table></figure>

<ul>
<li>(void)clearAllCache;</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">上面这个方法顾名思义就是清空Cache</div><div class="line"><span class="deletion">- 清除用法</span></div></pre></td></tr></table></figure>

<p>[dataManager clearObjectForKey:@”order” underType: LCCacheData];<br>[dataManager clearObjectsUnderType: LCCacheData];<br>[dataManager clearAllCache];</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></div></pre></td></tr></table></figure>

<p>i’m 华 丽 的 分 割 线 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-<span class="ruby">----------------------------------------------------------------------------</span></div><div class="line">##disk block</div><div class="line">disk上的存储</div><div class="line">它包括了</div></pre></td></tr></table></figure>

<p>NSFileManager NSUserDefaults NSKeyedArchiver</p>
<figure class="highlight 对数据"><figcaption><span>的操作，目前除了对```UIImage```的存储位置放在```tmp```中，其他数据存储位置在```Library/Caches```中</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

<p>NSFileManager </p>
<figure class="highlight 上的操作"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

<p>NSFileManager </p>
<figure class="highlight 存数据"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>storeImage:<span class="params">(<span class="variable">UIImage</span> *)</span>image withFileName:<span class="params">(<span class="variable">NSString</span> *)</span>fileName;</span></div><div class="line">- <span class="params">(<span class="variable">BOOL</span>)</span>storeArray:<span class="params">(<span class="variable">NSArray</span> *)</span>array withFileName:<span class="params">(<span class="variable">NSString</span> *)</span>fileName;</div><div class="line">- <span class="params">(<span class="variable">BOOL</span>)</span>storeDictionary:<span class="params">(<span class="variable">NSDictionary</span> *)</span>dictionary withFileName:<span class="params">(<span class="variable">NSString</span> *)</span>fileName;</div><div class="line">- <span class="params">(<span class="variable">BOOL</span>)</span>storeData:<span class="params">(<span class="variable">NSData</span> *)</span>data withFileName:<span class="params">(<span class="variable">NSString</span> *)</span>fileName;</div></pre></td></tr></table></figure>

<p>它的用法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="constant">NSArray *diskLists</span> = @[@<span class="string">"disk_1"</span>,@<span class="string">"disk_2"</span>,@<span class="string">"disk_3"</span>];</div><div class="line"><span class="constant">BOOL ret</span> = [dataManager storeArray:diskLists withFileName:@<span class="string">"order"</span>];</div></pre></td></tr></table></figure>

<p>其他类型以此类推</p>
<ul>
<li><figure class="highlight NSFileManager"><figcaption><span>```取数据</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="code">```</span></div><div class="line"><span class="bullet">- </span>(UIImage <span class="emphasis">*)fetchImageNamedString:(NSString *</span>)name;</div><div class="line"><span class="bullet">- </span>(NSArray <span class="emphasis">*)fetchArrayNamedString:(NSString *</span>)name;</div><div class="line"><span class="bullet">- </span>(NSDictionary <span class="emphasis">*)fetchDictionaryNamedString:(NSString *</span>)name;</div><div class="line"><span class="bullet">- </span>(NSData <span class="emphasis">*)fetchDataNamedString:(NSString *</span>)name;</div></pre></td></tr></table></figure>

</li>
</ul>
<p>它的用法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="constant">NSArray *fetchDiskLists</span> = [dataManager fetchArrayNameString:@<span class="string">"order"</span>];</div></pre></td></tr></table></figure>

<p>其他类型以此类推</p>
<ul>
<li><figure class="highlight NSFileManager"><figcaption><span>```删数据</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>removeImageNamedString:<span class="params">(<span class="variable">NSString</span> *)</span>name;</span></div><div class="line">- <span class="params">(<span class="variable">BOOL</span>)</span>removeArrayNamedString:<span class="params">(<span class="variable">NSString</span> *)</span>name;</div><div class="line">- <span class="params">(<span class="variable">BOOL</span>)</span>removeDictionaryNamedString:<span class="params">(<span class="variable">NSString</span> *)</span>name;</div><div class="line">- <span class="params">(<span class="variable">BOOL</span>)</span>removeDataNamedString:<span class="params">(<span class="variable">NSString</span> *)</span>name;</div></pre></td></tr></table></figure>

</li>
</ul>
<p>它的用法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL <span class="keyword">ret</span> = [dataManager removeArrayNameStrin<span class="variable">g:</span>@<span class="string">"order"</span>];</div></pre></td></tr></table></figure>

<p>其他类型以此类推</p>
<ul>
<li><figure class="highlight NSFileManager"><figcaption><span>```清空</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">-<span class="ruby"> (<span class="constant">BOOL</span>)clearDiskUnderImages;</span></div><div class="line">-<span class="ruby"> (<span class="constant">BOOL</span>)clearDiskUnderDatas;</span></div><div class="line">-<span class="ruby"> (void)clearAllDataOnDisk;</span></div></pre></td></tr></table></figure>

</li>
</ul>
<p>它的用法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">BOOL ret </span>=<span class="string"> [dataManager clearDiskUnderDatas];</span></div></pre></td></tr></table></figure>

<p>其中</p>
<figure class="highlight clearDiskUnderDatas```是清除Data目录中所有数据；"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="escape">``</span><span class="escape">`c</span>learDiskUnderImages</div></pre></td></tr></table></figure>

<p>是清除Image目录中所有数据</p>
<figure class="highlight clearAllDataOnDisk```是清除Disk上所有数据"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

<p>NSFileManager </p>
<figure class="highlight 获取数据大小"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">-<span class="ruby"> (<span class="constant">NSString</span>*)imageOndiskSize;</span></div><div class="line">-<span class="ruby"> (<span class="constant">NSString</span>*)dataOndiskSize;</span></div><div class="line">-<span class="ruby"> (<span class="constant">NSString</span>*)tmpOndiskSize;</span></div></pre></td></tr></table></figure>

<ul>
<li><figure class="highlight NSUserDefaults"><figcaption><span>```上的操作</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

</li>
</ul>
<p>NSUserDefaults </p>
<figure class="highlight 存数据"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>storeValue:<span class="params">(id)</span>value keyValue:<span class="params">(<span class="variable">NSString</span>*)</span>key;</span></div></pre></td></tr></table></figure>

<ul>
<li><figure class="highlight NSUserDefaults"><figcaption><span>```取数据</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="pp">- <span class="params">(id)</span>fetchValueUnderKeyValue:<span class="params">(<span class="variable">NSString</span> *)</span>key;</span></div></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<figure class="highlight NSUserDefaults"><figcaption><span>```用法</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="constant">BOOL ret</span> = [dataManager storeValue:@<span class="string">"LinkAge"</span> keyValue:@<span class="string">"Co.,Ltd."</span>];</div><div class="line"><span class="constant">NSString *corp</span> = [dataManager fetchValueUnderKeyValue:@<span class="string">"Co.,Ltd."</span>];</div></pre></td></tr></table></figure>

<ul>
<li><figure class="highlight NSKeyedArchiver"><figcaption><span>```上的操作(对有序列化要求的数据提供存储方法)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

</li>
</ul>
<p>NSKeyedArchiver </p>
<figure class="highlight 存数据"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>storeObject:<span class="params">(id)</span>object withFileName:<span class="params">(<span class="variable">NSString</span> *)</span>fileName;</span></div></pre></td></tr></table></figure>

<ul>
<li><figure class="highlight NSKeyedArchiver"><figcaption><span>```取数据</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="pp">- <span class="params">(id)</span>fetchObjectNamedString:<span class="params">(<span class="variable">NSString</span> *)</span>name;</span></div></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<figure class="highlight NSKeyedArchiver"><figcaption><span>```删数据</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">放在</div></pre></td></tr></table></figure>

<p>NSFileManager </p>
<figure class="highlight 对Data操作一致"><figcaption><span>他们的存储目录一样</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

<p>NSKeyedArchiver </p>
<figure class="highlight 用法"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="built_in">NSDictionary</span> *dic ...{为后台返回回来的jsonDic}</div><div class="line"><span class="built_in">BOOL</span> ret = [dataManager storeObject:dic withFileName:<span class="string">@"washCarList"</span>];</div><div class="line"><span class="built_in">NSDictionary</span> *fetchDic = [dataManager fetchObjectNamedString:<span class="string">@"washCarList"</span>];</div></pre></td></tr></table></figure>

<p>其余自定义类需要调用函数的 完成NSCoding协议后在调用</p>
]]></content>
    <summary type="html">
    <![CDATA[<h6 id="#_文章参照cucuz的数据存储Library"># 文章参照cucuz的数据存储Library</h6>
<p><strong>类 的目的</strong></p>
<p>方便项目当中数据的存储，提供简单的接口供使用,根据存储的位置划分可以分为缓存和本地存储，<br>其中包括</p>
<pre><code><span class="built_in">NSArray</span>, <span class="built_in">NSDictionary</span>, NSData,<span class="built_in">NSString</span>,<span class="built_in">UIImage</span> 等常用数据类型，自定义Object(自行实现NSCoding协议)
</code></pre><p><strong>类的函数介绍</strong></p>
<ul>
<li>类初始化(单例)</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">LCDataManager *dataManager </span>=<span class="string"> [LCDataManager shareManager];</span></div></pre></td></tr></table></figure>

<p>首先，我们创建一个对象，下文将以它作为存储的一个依据</p>
<h2 id="Cache_block">Cache block</h2>
<p>]]>
    
    </summary>
    
      <category term="LCDataManager" scheme="http://linkageios.github.io/tags/LCDataManager/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于iConsole在项目中的应用]]></title>
    <link href="http://linkageios.github.io/2014/11/07/%E5%85%B3%E4%BA%8EiConsole%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://linkageios.github.io/2014/11/07/关于iConsole在项目中的应用/</id>
    <published>2014-11-07T05:38:14.000Z</published>
    <updated>2014-12-03T02:51:18.000Z</updated>
    <content type="html"><![CDATA[<p>tips：方便程序没有连着Xcode跑时定位bug(目前觉得没什么好写的就是)</p>
<ul>
<li>安装</li>
</ul>
<p><img src="/images/79888-d9f0841d3cfac40e.png" alt="imag"></p>
<p>下载iconsole代码，将其中这两个文件拖入现有代码中</p>
<ul>
<li>配置<br>添加头文件</li>
</ul>
<figure class="highlight #import"><figcaption><span>"iConsole.h"```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在使用其功能之前有一点要注意,需要将AppDelegate里初始的<span class="built_in">UIWindow</span>需要以iConsoleWindow来初始化,并添加</div></pre></td></tr></table></figure>

<p>iConsoleDelegate</p>
<figure class="highlight 协议"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在</div></pre></td></tr></table></figure>

<p>AppDelegate.h</p>
<figure class="highlight 中"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="xml"><span class="comment">&lt;!--more--&gt;</span></span></div><div class="line">tips：方便程序没有连着Xcode跑时定位bug(目前觉得没什么好写的就是)</div><div class="line"><span class="bullet">- </span>安装</div><div class="line"></div><div class="line">![<span class="link_label">imag</span>](<span class="link_url">/images/79888-d9f0841d3cfac40e.png</span>)</div><div class="line"></div><div class="line">下载iconsole代码，将其中这两个文件拖入现有代码中</div><div class="line"><span class="bullet">- </span>配置</div><div class="line">添加头文件</div></pre></td></tr></table></figure>

<h1 id="import_“iConsole-h”">import “iConsole.h”</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在使用其功能之前有一点要注意,需要将AppDelegate里初始的<span class="built_in">UIWindow</span>需要以iConsoleWindow来初始化,并添加</div></pre></td></tr></table></figure>

<p>iConsoleDelegate</p>
<figure class="highlight 协议"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在</div></pre></td></tr></table></figure>

<p>AppDelegate.h</p>
<figure class="highlight 中"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) iConsoleWindow *window;</div></pre></td></tr></table></figure>

<p>在</p>
<figure class="highlight AppDelegate.m```的```didFinishLaunchingWithOptions"><figcaption><span>```方法中添加</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="variable">_window =</span> [[iConsoleWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];</div><div class="line"><span class="comment">/*</span></div><div class="line">*  iconsole</div><div class="line">*/</div><div class="line">[iConsole sharedConsole].<span class="variable">delegate =</span> self;</div><div class="line">[iConsole sharedConsole].<span class="variable">logSubmissionEmail =</span> @<span class="string">"xxx@126.com"</span>;</div></pre></td></tr></table></figure>

<p>添加协议方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">*iconsole</div><div class="line">*@param command</div><div class="line">*/</div><div class="line">- (<span class="keyword">void</span>)handleConsoleCommand:(<span class="built_in">NSString</span> *)command</div><div class="line">{</div><div class="line"><span class="keyword">if</span> ([command isEqualToString:<span class="string">@"version"</span>])</div><div class="line">{</div><div class="line">[iConsole info:<span class="string">@"%@ version %@"</span>,</div><div class="line">[[<span class="built_in">NSBundle</span> mainBundle] objectForInfoDictionaryKey:<span class="string">@"CFBundleName"</span>],</div><div class="line">[[<span class="built_in">NSBundle</span> mainBundle] objectForInfoDictionaryKey:<span class="string">@"CFBundleVersion"</span>]];</div><div class="line">}</div><div class="line"><span class="keyword">else</span></div><div class="line">{</div><div class="line">[iConsole error:<span class="string">@"unrecognised command, try 'version' instead"</span>];</div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>iConsole提供了4种记录日程的方式,分别是:<br>1:信息         </p>
<figure class="highlight [iConsole"><figcaption><span>info:@"记录一条普通级"];```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2:警告</div></pre></td></tr></table></figure>

<p>[iConsole warn:@”记录一条警告级”];</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3:错误</div></pre></td></tr></table></figure>

<p>[iConsole error:@”记录一条错误级”];</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4:崩溃</div></pre></td></tr></table></figure>

<p>[iConsole crash:@”记录一条崩溃级”];</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">iConsole</span> 默认记录的日志条数是<span class="number">1000</span>条. 如果日志记录到上限时,会删除最早的一条,如此循环,可通过如下属性设置上下限:</div></pre></td></tr></table></figure>

<p>[[iConsole sharedConsole] setMaxLogItems:2000];  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当我们需要查看iConsole的控制台时,可以通过三种方式来启动控制台:</div><div class="line">1:主动调用</div></pre></td></tr></table></figure>

<p>[iConsole show];  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2:三跟手指由下往上滑动. 模拟器两根手指,  默认启动</div></pre></td></tr></table></figure>

<p>[iConsole sharedConsole].simulatorTouchesToShow = YES;<br>[iConsole sharedConsole].deviceTouchesToShow = YES;  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3:摇动手机启动  默认禁用</div></pre></td></tr></table></figure>

<p>[iConsole sharedConsole].deviceShakeToShow = YES; ``` </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>tips：方便程序没有连着Xcode跑时定位bug(目前觉得没什么好写的就是)</p>
<ul>
<li>安装</li>
</ul>
<p><img src="/images/79888-d9f0841d3cfac40e.png" alt="imag"></p>
<p>下载]]>
    </summary>
    
      <category term="iconsole" scheme="http://linkageios.github.io/tags/iconsole/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[地图开发总结]]></title>
    <link href="http://linkageios.github.io/2014/11/07/%E5%9C%B0%E5%9B%BE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>http://linkageios.github.io/2014/11/07/地图开发总结/</id>
    <published>2014-11-07T04:18:00.000Z</published>
    <updated>2014-11-18T10:27:25.000Z</updated>
    <content type="html"><![CDATA[<h3 id="坑爹的高德">坑爹的高德</h3>
<p>项目中地图原来用的高德sdk，其实我不知道当时为什么就用了高德，但既然用了，那么就在此基础上开发吧。可是写着写着，问题就来了： <a href="http://bbs.amap.com/thread-42153-1-1.html" target="_blank" rel="external">问题链接</a>。虽然这个问题不是什么太大的问题，但保不准以后还会遇到什么别的坑，而且以高德的效率，短期内肯定不会解决的。<br>那为什么还要用那个sdk呢？好像我们用到的功能苹果自带的MapKit都能实现啊，而且高德官网上的合作伙伴（携程、美团）也是用的原生的MapKit（从地图默认加载背景就可以看出来）。后来只花了一点点时间就切换到苹果的MapKit（API是一样的），目前还没发现什么bug。</p>
<h3 id="坐标转换之中国特色">坐标转换之中国特色</h3>
<p>因为不用高德了，所以当前位置经纬度就用CoreLocation来获取。可是当你把获取的经纬度放到MKMapView中显示，位置竟然有偏移，而且还不小。</p>
<p>这是苹果的bug吗？不是，是有关部门的功劳。我们只有一个地球，所以地球上每个点的经纬度是固定的，国际上有个通用标准，简称国际标准。CoreLocation取到的经纬度符合国际标准。</p>
<p>可是在国内，由于国家安全，有关部门制定了一套新的标准，简称国家标准。只要是在国内发行的地图（包括电子地图），都要按国家标准来，不然就是非法的。所以苹果手机中的国内地图肯定也是改良过的。</p>
<p>我拿着国际标准的经纬度放到改良过的符合国家标准的地图中，显然会发生偏移。</p>
<p>解决办法就是将国际标准的经纬度转换成国家标准的经纬度。<a href="https://gist.github.com/mithvv/5476132" target="_blank" rel="external">算法是现成的</a>（以前用高德sdk获取当前位置的经纬度本来就是国家标准的，所以没事。）<br><a id="more"></a></p>
<h3 id="坑爹的高德-1">坑爹的高德</h3>
<p>项目中地图原来用的高德sdk，其实我不知道当时为什么就用了高德，但既然用了，那么就在此基础上开发吧。可是写着写着，问题就来了： <a href="http://bbs.amap.com/thread-42153-1-1.html" target="_blank" rel="external">问题链接</a>。虽然这个问题不是什么太大的问题，但保不准以后还会遇到什么别的坑，而且以高德的效率，短期内肯定不会解决的。<br>那为什么还要用那个sdk呢？好像我们用到的功能苹果自带的MapKit都能实现啊，而且高德官网上的合作伙伴（携程、美团）也是用的原生的MapKit（从地图默认加载背景就可以看出来）。后来只花了一点点时间就切换到苹果的MapKit（API是一样的），目前还没发现什么bug。</p>
<h3 id="坐标转换之中国特色-1">坐标转换之中国特色</h3>
<p>因为不用高德了，所以当前位置经纬度就用CoreLocation来获取。可是当你把获取的经纬度放到MKMapView中显示，位置竟然有偏移，而且还不小。</p>
<p>这是苹果的bug吗？不是，是有关部门的功劳。我们只有一个地球，所以地球上每个点的经纬度是固定的，国际上有个通用标准，简称国际标准。CoreLocation取到的经纬度符合国际标准。</p>
<p>可是在国内，由于国家安全，有关部门制定了一套新的标准，简称国家标准。只要是在国内发行的地图（包括电子地图），都要按国家标准来，不然就是非法的。所以苹果手机中的国内地图肯定也是改良过的。</p>
<p>我拿着国际标准的经纬度放到改良过的符合国家标准的地图中，显然会发生偏移。</p>
<p>解决办法就是将国际标准的经纬度转换成国家标准的经纬度。<a href="https://gist.github.com/mithvv/5476132" target="_blank" rel="external">算法是现成的</a>（以前用高德sdk获取当前位置的经纬度本来就是国家标准的，所以没事。）</p>
<h3 id="怎么使用MapKit">怎么使用MapKit</h3>
<p>用苹果官方的framework最幸福了，因为有标准的文档可查，只要看就是了。目前我们对地图的使用非常简单，就是在地图上加地理位置标注，所以我要看的只有其中<a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/LocationAwarenessPG/AnnotatingMaps/AnnotatingMaps.html#//apple_ref/doc/uid/TP40009497-CH6-SW1" target="_blank" rel="external">一小段</a>。</p>
<p>要实现标注，必须要有以下3个对象：</p>
<ul>
<li>AnnotationObject(标注对象)</li>
<li>AnnotationView(标注视图)</li>
<li>AnnotationCalloutView(标注弹出视图，可看做是标注视图的一部分)</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/16632-ebb438364bb22eb8.png" alt="annotation.png" width="200px"></p>
<p>结合上面的图，AnnotationObject是标注的模型对象，AnnotationView就是大头针，AnnotationCallView就是弹出来的浮层。</p>
<h6 id="AnnotationObject">AnnotationObject</h6>
<p>AnnotationObject必须实现MKAnnotation协议：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MKAnnotation</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Center latitude and longitude of the annotation view.</span></div><div class="line"><span class="comment">// The implementation of this property must be KVO compliant.</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) CLLocationCoordinate2D coordinate;</div><div class="line"></div><div class="line"><span class="keyword">@optional</span></div><div class="line"></div><div class="line"><span class="comment">// Title and subtitle for use by selection UI.</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *title;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *subtitle;</div><div class="line"></div><div class="line"><span class="comment">// Called as a result of dragging an annotation view.</span></div><div class="line">- (<span class="keyword">void</span>)setCoordinate:(CLLocationCoordinate2D)newCoordinate NS_AVAILABLE(<span class="number">10</span>_9, <span class="number">4</span>_0);</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>框架默认提供了一个MKPointAnnotation，只有coordinate、title、subtitle，如果要求不高，这个类也够用了。但更多的情况就需要我们自定义MKAnnotation。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HJGasStationAnnotation</span> : <span class="title">NSObject</span>&lt;<span class="title">MKAnnotation</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">//经纬度</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) CLLocationCoordinate2D coordinate;</div><div class="line"><span class="comment">//标题</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>* title;</div><div class="line"><span class="comment">//地址</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>* address;</div><div class="line"><span class="comment">//电话</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>* tel;</div><div class="line"></div><div class="line">- (instancetype)initWithLocation:(CLLocationCoordinate2D)coordinate;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>里面的title、address、tel都是我随便加的，只要有需求，加任何东西都可以，但官方文档中也说了，AnnotationObject不能太大，不然地图上标注一多，效率会有问题。</p>
<p>想一下，为什么要有AnnotationObject这个对象？我看到之前的代码没么有自定义什么AnnotationObject，所有的标注都用MKPointAnnotation，然后所有其他的属性都封装成另外一个对象（ObjectB，这个ObjectB也是从项目的其他地方拿来的）都放到AnnotationView去。</p>
<p>这样造成的后果就是AnnotationView中既有AnnotationObject，又有ObjectB（而且ObjectB不够纯粹，有很多冗余的属性），导致AnnotationView代码耦合性较大。而子类话AnnotationObject，就能消除这种耦合，把ObjectB中有用的属性封装到SubAnnotationObject中即可，这样对于AnnotationView而言，只需要知道AnnotationObject，管它什么ObjectB呢！</p>
<h6 id="AnnotationView">AnnotationView</h6>
<p>框架提供了默认的MKPinAnnotationView，就是一个大头针。因为不够美观，我们可能要换成其它图片或者自定义视图。</p>
<p>怎么自定义呢？只要继承一下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HJGasStationAnnotationView</span> : <span class="title">MKAnnotationView</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) HJGasStationCalloutView *calloutView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HJGasStationAnnotationView</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithAnnotation:(<span class="keyword">id</span>&lt;MKAnnotation&gt;)annotation reuseIdentifier:(<span class="built_in">NSString</span> *)reuseIdentifier</div><div class="line">{</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithAnnotation:annotation reuseIdentifier:reuseIdentifier];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)</div><div class="line">    {</div><div class="line">        <span class="keyword">self</span><span class="variable">.bounds</span> = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">23</span>, <span class="number">35</span>);</div><div class="line">        <span class="keyword">self</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];</div><div class="line">        <span class="keyword">self</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"map_location.png"</span>];</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>上面的自定义非常简单，只是换了张图片，如果有更复杂的需求，直接在里面加子控件或者重写drewRect都可。</p>
<h6 id="AnnotationCalloutView">AnnotationCalloutView</h6>
<p>框架里有标准的AnnotationCalloutView，只需要设置AnnotationView的属性canShowCallout为YES，就能展示默认的CalloutView；如果需要自定义CalloutView的话就必须将canShowCallout设为NO，这样就不会弹出默认的CalloutView。</p>
<p>自定义的CalloutView就是一个普通的View，爱怎么写就怎么写。它展示和消失的逻辑是由AnnotationView来控制的，所以说CalloutView其实是AnnotationView的一部分。</p>
<p>交互的逻辑就是重写两个方法，而且必须要重写，变量名根据实际情况会变，但方法逻辑结构就不需要动。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(UIEvent *)event</div><div class="line">{</div><div class="line">    <span class="built_in">BOOL</span> inside = [<span class="keyword">super</span> pointInside:point withEvent:event];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!inside && <span class="keyword">self</span><span class="variable">.selected</span>)</div><div class="line">    {</div><div class="line">        inside = [<span class="keyword">self</span><span class="variable">.calloutView</span> pointInside:[<span class="keyword">self</span> convertPoint:point toView:<span class="keyword">self</span><span class="variable">.calloutView</span>] withEvent:event];</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> inside;</div><div class="line">}</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setSelected:(<span class="built_in">BOOL</span>)selected</div><div class="line">{</div><div class="line">    [<span class="keyword">super</span> setSelected:selected];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(selected)</div><div class="line">    {</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.calloutView</span> == <span class="literal">nil</span>) {</div><div class="line">            <span class="keyword">self</span><span class="variable">.calloutView</span> = [[HJGasStationCalloutView alloc] initWithFrame:CGRectMake(<span class="number">0</span>, <span class="number">0</span>, kCalloutWidth, kCalloutHeight)];</div><div class="line">            [<span class="keyword">self</span><span class="variable">.calloutView</span><span class="variable">.telButton</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(telButtonPressed:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">            [<span class="keyword">self</span><span class="variable">.calloutView</span><span class="variable">.navButton</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(navButtonPressed:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">            <span class="keyword">self</span><span class="variable">.calloutView</span><span class="variable">.center</span> = CGPointMake(CGRectGetWidth(<span class="keyword">self</span><span class="variable">.bounds</span>) / <span class="number">2.</span>f + <span class="keyword">self</span><span class="variable">.calloutOffset</span><span class="variable">.x</span>,(-CGRectGetHeight(<span class="keyword">self</span><span class="variable">.calloutView</span><span class="variable">.bounds</span>) / <span class="number">2.</span>f + <span class="keyword">self</span><span class="variable">.calloutOffset</span><span class="variable">.y</span>));</div><div class="line">        }</div><div class="line">        [<span class="keyword">self</span> bindDataToUI];</div><div class="line">        [<span class="keyword">self</span> addSubview:<span class="keyword">self</span><span class="variable">.calloutView</span>];</div><div class="line">    }</div><div class="line">    <span class="keyword">else</span></div><div class="line">    {</div><div class="line">        [<span class="keyword">self</span><span class="variable">.calloutView</span> removeFromSuperview];</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="展现逻辑">展现逻辑</h3>
<p>像MapView添加标注</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.mapView <span class="symbol">addAnnotation:</span><span class="keyword">self</span>.annotation];</div></pre></td></tr></table></figure>

<p> 在MapView的代理方法中生成AnnotationView</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (MKAnnotationView *)mapView:(<span class="built_in">MKMapView</span> *)mapView viewForAnnotation:(<span class="keyword">id</span>&lt;MKAnnotation&gt;)annotation</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> ([annotation isKindOfClass:[HJGasStationAnnotation class]]) {</div><div class="line">        </div><div class="line">        <span class="keyword">static</span> <span class="built_in">NSString</span> *customReuseIndetifier = <span class="string">@"HJGasStationAnnotation"</span>;</div><div class="line">        HJGasStationAnnotationView *annotationView = (HJGasStationAnnotationView*)[mapView dequeueReusableAnnotationViewWithIdentifier:customReuseIndetifier];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (annotationView == <span class="literal">nil</span>)</div><div class="line">        {</div><div class="line">            annotationView = [[HJGasStationAnnotationView alloc] initWithAnnotation:annotation reuseIdentifier:customReuseIndetifier];</div><div class="line">            annotationView<span class="variable">.canShowCallout</span> = <span class="literal">NO</span>;</div><div class="line">            annotationView<span class="variable">.draggable</span> = <span class="literal">NO</span>;</div><div class="line">            annotationView<span class="variable">.calloutOffset</span> = CGPointMake(<span class="number">0</span>, -<span class="number">5</span>);</div><div class="line">            annotationView<span class="variable">.selected</span> = <span class="literal">YES</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span> {</div><div class="line">            annotationView<span class="variable">.annotation</span> = annotation;</div><div class="line">        }</div><div class="line">        </div><div class="line">        [annotationView bindDataToUI];</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> annotationView;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h3 id="坑爹的高德">坑爹的高德</h3>
<p>项目中地图原来用的高德sdk，其实我不知道当时为什么就用了高德，但既然用了，那么就在此基础上开发吧。可是写着写着，问题就来了： <a href="http://bbs.amap.com/thread-42153-1-1.html" target="_blank" rel="external">问题链接</a>。虽然这个问题不是什么太大的问题，但保不准以后还会遇到什么别的坑，而且以高德的效率，短期内肯定不会解决的。<br>那为什么还要用那个sdk呢？好像我们用到的功能苹果自带的MapKit都能实现啊，而且高德官网上的合作伙伴（携程、美团）也是用的原生的MapKit（从地图默认加载背景就可以看出来）。后来只花了一点点时间就切换到苹果的MapKit（API是一样的），目前还没发现什么bug。</p>
<h3 id="坐标转换之中国特色">坐标转换之中国特色</h3>
<p>因为不用高德了，所以当前位置经纬度就用CoreLocation来获取。可是当你把获取的经纬度放到MKMapView中显示，位置竟然有偏移，而且还不小。</p>
<p>这是苹果的bug吗？不是，是有关部门的功劳。我们只有一个地球，所以地球上每个点的经纬度是固定的，国际上有个通用标准，简称国际标准。CoreLocation取到的经纬度符合国际标准。</p>
<p>可是在国内，由于国家安全，有关部门制定了一套新的标准，简称国家标准。只要是在国内发行的地图（包括电子地图），都要按国家标准来，不然就是非法的。所以苹果手机中的国内地图肯定也是改良过的。</p>
<p>我拿着国际标准的经纬度放到改良过的符合国家标准的地图中，显然会发生偏移。</p>
<p>解决办法就是将国际标准的经纬度转换成国家标准的经纬度。<a href="https://gist.github.com/mithvv/5476132" target="_blank" rel="external">算法是现成的</a>（以前用高德sdk获取当前位置的经纬度本来就是国家标准的，所以没事。）<br>]]>
    
    </summary>
    
      <category term="地图" scheme="http://linkageios.github.io/tags/%E5%9C%B0%E5%9B%BE/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[POP框架初探]]></title>
    <link href="http://linkageios.github.io/2014/11/06/POP%E6%A1%86%E6%9E%B6%E5%88%9D%E6%8E%A2/"/>
    <id>http://linkageios.github.io/2014/11/06/POP框架初探/</id>
    <published>2014-11-06T10:05:14.000Z</published>
    <updated>2014-12-03T02:52:45.000Z</updated>
    <content type="html"><![CDATA[<p>合适的动画效果是提高用户体验最直观的方式，我们项目中的动画应用也不少，主要是使用的UIKit的动画扩展，还有少量用CoreAnimation实现。现在Facebook开源了POP，我们又多了一种强大好用的选择。与CoreAnimation相比，api用法相似，POP提供了更多方便生动的动画效果，主要是弹簧（SpringAnimation）和衰减（DecayAnimation）效果。</p>
<h1 id="使用方法">使用方法</h1>
<p>POP的使用跟CoreAnimation比较相似，基本的步骤如下：</p>
<ul>
<li>选择一种动画效果<br>1.POPBasicAnimation 基本的动画效果，我们常用的EaseInOut、Linenear的动画效果都可以用这种方式实现</li>
</ul>
<p>2.POPSpringAnimation 弹簧效果，如下图</p>
<p><img src="/images/pop.gif" alt="pop.gif"></p>
<pre><code>
POPSpringAnimation *springAnimation = [POPSpringAnimation animation];
springAnimation.springBounciness=14;    // 弹簧弹力 取值范围为[0, 20]，默认值为4
springAnimation.springSpeed=3;     // 弹簧速度，速度越快，动画时间越短 [0, 20]，默认为12，和springBounciness一起决定着弹簧动画的效果

<a id="more"></a>



合适的动画效果是提高用户体验最直观的方式，我们项目中的动画应用也不少，主要是使用的UIKit的动画扩展，还有少量用CoreAnimation实现。现在Facebook开源了POP，我们又多了一种强大好用的选择。与CoreAnimation相比，api用法相似，POP提供了更多方便生动的动画效果，主要是弹簧（SpringAnimation）和衰减（DecayAnimation）效果。
# 使用方法
POP的使用跟CoreAnimation比较相似，基本的步骤如下：
- 选择一种动画效果
1.POPBasicAnimation 基本的动画效果，我们常用的EaseInOut、Linenear的动画效果都可以用这种方式实现

<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="constant">POPBasicAnimation *basicAnimation</span> = [POPBasicAnimation animation];</div><div class="line">basicAnimation.timingFunction=[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];</div><div class="line"><span class="comment">// kCAMediaTimingFunctionLinear  kCAMediaTimingFunctionEaseIn  kCAMediaTimingFunctionEaseOut  kCAMediaTimingFunctionEaseInEaseOut</span></div></pre></td></tr></table></figure>

2.POPSpringAnimation 弹簧效果，如下图

![pop.gif](/images/pop.gif)

<pre><code>
POPSpringAnimation *springAnimation = [POPSpringAnimation animation];
springAnimation.springBounciness=14;    // 弹簧弹力 取值范围为[0, 20]，默认值为4
springAnimation.springSpeed=3;     // 弹簧速度，速度越快，动画时间越短 [0, 20]，默认为12，和springBounciness一起决定着弹簧动画的效果
// 还有：dynamicsTension 弹簧的张力 dynamicsFriction 弹簧摩擦 dynamicsMass 质量 。张力，摩擦，质量这三者可以从更细的粒度上替代springBounciness和springSpeed控制弹簧动画的效果
</code></pre>
3.POPDecayAnimation 衰减效果，参考UIScrollView滑动松手后的减速
<pre><code>
POPDecayAnimation *decayAnimation=[POPDecayAnimation animation];
decayAnimation.velocity=@(233); //值的变化速率
</code></pre>

<ul>
<li>选择生成动画的Property<br>View Properties，包含以下定义<br>kPOPViewAlpha  kPOPViewBackgroundColor kPOPViewBounds kPOPViewCenter kPOPViewFrame kPOPViewScaleXY  kPOPViewSize</li>
</ul>
<p>Layer Properties<br>kPOPLayerBackgroundColor kPOPLayerBounds kPOPLayerScaleXY kPOPLayerSize kPOPLayerOpacity kPOPLayerPosition kPOPLayerPositionX kPOPLayerPositionY  kPOPLayerRotation kPOPLayerBackgroundColor</p>
<ul>
<li><p>设置对应的.toValue<br>例如</p>
<pre><code>
// 设置alpha
POPBasicAnimation *basicAnimation = [POPBasicAnimation animation];
basicAnimation.property = [POPAnimatableProperty propertyWithName:kPOPViewAlpha];
basicAnimation.toValue= @(0);
// 设置BackgroundColor
POPSpringAnimation *basicAnimation = [POPSpringAnimation animation];
basicAnimation.property = [POPAnimatableProperty propertyWithName: kPOPLayerBackgroundColor];
basicAnimation.toValue= [UIColor redColor];
</code></pre>
</li>
<li><p>为动画设置name和delegate<br><pre><code><br>basicAnimation.name=@”POPAnimation”;<br>basicAnimation.delegate=self;<br></code></pre><br>delegate方法如下</p>
</li>
</ul>
<pre><code>
- (void)pop_animationDidStart:(POPAnimation *)anim;
- (void)pop_animationDidStop:(POPAnimation *)anim finished:(BOOL)finished;
- (void)pop_animationDidReachToValue:(POPAnimation *)anim;

</code></pre>
- 将animation添加到对象上
<pre><code>
[self.tableView pop_addAnimation:basicAnimation forKey:@"POPAnimation"];
</code></pre>

<h1 id="完整例子">完整例子</h1>
<pre><code>
POPSpringAnimation *basicAnimation = [POPSpringAnimation animation];
basicAnimation.property = [POPAnimatableProperty propertyWithName:kPOPViewFrame];
basicAnimation.toValue=[NSValue valueWithCGRect:CGRectMake(0, 0, 90, 190)];
basicAnimation.name=@"SomeAnimationNameYouChoose";
basicAnimation.delegate=self;
[self.tableView pop_addAnimation:basicAnimation forKey:@"POPAnimation"];
</code></pre></code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>合适的动画效果是提高用户体验最直观的方式，我们项目中的动画应用也不少，主要是使用的UIKit的动画扩展，还有少量用CoreAnimation实现。现在Facebook开源了POP，我们又多了一种强大好用的选择。与CoreAnimation相比，api用法相似，POP提供了更多方便生动的动画效果，主要是弹簧（SpringAnimation）和衰减（DecayAnimation）效果。</p>
<h1 id="使用方法">使用方法</h1>
<p>POP的使用跟CoreAnimation比较相似，基本的步骤如下：</p>
<ul>
<li>选择一种动画效果<br>1.POPBasicAnimation 基本的动画效果，我们常用的EaseInOut、Linenear的动画效果都可以用这种方式实现</li>
</ul>
<p>2.POPSpringAnimation 弹簧效果，如下图</p>
<p><img src="/images/pop.gif" alt="pop.gif"></p>
<pre><code>
POPSpringAnimation *springAnimation = [POPSpringAnimation animation];
springAnimation.springBounciness=14;    // 弹簧弹力 取值范围为[0, 20]，默认值为4
springAnimation.springSpeed=3;     // 弹簧速度，速度越快，动画时间越短 [0, 20]，默认为12，和springBounciness一起决定着弹簧动画的效果

]]>
    
    </summary>
    
      <category term="POP" scheme="http://linkageios.github.io/tags/POP/"/>
    
      <category term="动画" scheme="http://linkageios.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LCMenuView简介]]></title>
    <link href="http://linkageios.github.io/2014/11/05/LCMenuView%E7%AE%80%E4%BB%8B/"/>
    <id>http://linkageios.github.io/2014/11/05/LCMenuView简介/</id>
    <published>2014-11-05T08:43:14.000Z</published>
    <updated>2014-11-18T10:31:02.000Z</updated>
    <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>筛选功能在慧驾项目中用的比较多，所以抽取出来，以便简化代码，便于维护</p>
<h1 id="类与方法说明">类与方法说明</h1>
<p>LCMenuView<br>菜单标题相关，与此次迭代UI相同，以后根据UI的变更进行修改，提供方法和属性如下：</p>
<pre><code>
- (id)initWithFrame:(CGRect)frame       //
segmentWidths:(NSArray *)widths   // 每个segment的宽度，类型NSNumber
segmentTitles:(NSArray *)titles   // 标题，类型NSString
popups:(NSArray *)popups   // 弹出菜单，类型LCMenuPopupView
parentView:(UIView *)parent;   // menu的parentView

<a id="more"></a>

# 简介
筛选功能在慧驾项目中用的比较多，所以抽取出来，以便简化代码，便于维护

# 类与方法说明
LCMenuView
菜单标题相关，与此次迭代UI相同，以后根据UI的变更进行修改，提供方法和属性如下：
<pre><code>
- (id)initWithFrame:(CGRect)frame       //
segmentWidths:(NSArray *)widths   // 每个segment的宽度，类型NSNumber
segmentTitles:(NSArray *)titles   // 标题，类型NSString
popups:(NSArray *)popups   // 弹出菜单，类型LCMenuPopupView
parentView:(UIView *)parent;   // menu的parentView

- (void)setSegmentTitle:(NSString *)title index:(NSInteger)index;   // 设置标题
- (NSString *)segmentTitleAtIndex:(NSInteger)index;                 // 标题

- (BOOL)showPopup:(BOOL)show index:(NSInteger)index animate:(BOOL)animate;  // 显示或隐藏菜单
- (void)hideAllPopup:(BOOL)animate; //隐藏所有菜单

@property (nonatomic, weak, readonly) UIView *parent;
@property (nonatomic, strong, readonly) UIView *maskView;

@property (nonatomic, assign, readonly) NSInteger popedIndex;   // 当前显示菜单index
</code></pre>

<p>LCMenuPopupView<br>弹出菜单相关，主要封装了菜单的弹出收起动画，提供方法和属性如下：</p>
<pre><code>
// 初始化方法 arrowBtmCenterX是箭头X轴位置
- (id)initWithFrame:(CGRect)frame
ContentView:(UIView *)contentView
arrowPosition:(CGFloat)arrowBtmCenterX;

@property (nonatomic, strong, readwrite) UIView *contentView;

@property (nonatomic, assign, readonly) CGFloat arrowBtmCenterX;

// 显示或隐藏内容
@property (nonatomic, assign, getter=isShow) BOOL show;
- (void)show:(BOOL)show animate:(BOOL)animate;
</code></pre>

<h1 id="使用方法">使用方法</h1>
<p>创建UIView子类，封装弹出菜单的内容，本次封装的是LCMenuContentView</p>
<pre><code>
LCMenuContentView *t0 = [[LCMenuContentView alloc] initWithFrame:CGRectMake(0, 0, 320, 40 * arrayPopInfoMile.count) titles:arrayPopInfoMile selectRow:0];
t0.shopPopViewDelegate = self;
LCMenuPopupView *p0 = [[LCMenuPopupView alloc] initWithFrame:CGRectMake(0, 0, 320, 40 * arrayPopInfoMile.count) ContentView:t0 arrowPosition:53];

NSInteger index = -1;
index = [arrayPopInfoKind indexOfObject:self.stringTitle];
LCMenuContentView *t1 = [[LCMenuContentView alloc] initWithFrame:CGRectMake(0, 0, 320, 40 * arrayPopInfoKind.count) titles:arrayPopInfoKind selectRow:index];
t1.shopPopViewDelegate = self;
LCMenuPopupView *p1 = [[LCMenuPopupView alloc] initWithFrame:CGRectMake(0, 0, 320, 40 * arrayPopInfoKind.count) ContentView:t1 arrowPosition:160];


LCMenuContentView *t2 = [[LCMenuContentView alloc] initWithFrame:CGRectMake(0, 0, 320, 40 * arrayPopInfoComment.count) titles:arrayPopInfoComment selectRow:-1];
t2.shopPopViewDelegate = self;
LCMenuPopupView *p2 = [[LCMenuPopupView alloc] initWithFrame:CGRectMake(0, 0, 320, 40 * arrayPopInfoComment.count) ContentView:t2 arrowPosition:320 - 53];

LCMenuView *view = [[LCMenuView alloc] initWithFrame:CGRectMake(0, 0, 320, 50)
segmentWidths:@[@(106), @(108), @(106)]
segmentTitles:@[arrayPopInfoMile[0], self.stringTitle, @"智能"]
popups:@[p0, p1, p2]
parentView:self.view];
[self.view addSubview:view];
</code></pre>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="简介">简介</h1>
<p>筛选功能在慧驾项目中用的比较多，所以抽取出来，以便简化代码，便于维护</p>
<h1 id="类与方法说明">类与方法说明</h1>
<p>LCMenuView<br>菜单标题相关，与此次迭代UI相同，以后根据UI的变更进行修改，提供方法和属性如下：</p>
<pre><code>
- (id)initWithFrame:(CGRect)frame       //
segmentWidths:(NSArray *)widths   // 每个segment的宽度，类型NSNumber
segmentTitles:(NSArray *)titles   // 标题，类型NSString
popups:(NSArray *)popups   // 弹出菜单，类型LCMenuPopupView
parentView:(UIView *)parent;   // menu的parentView

]]>
    
    </summary>
    
      <category term="LCMenuView" scheme="http://linkageios.github.io/tags/LCMenuView/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高德地图sdk分析]]></title>
    <link href="http://linkageios.github.io/2014/11/03/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BEsdk%E5%88%86%E6%9E%90/"/>
    <id>http://linkageios.github.io/2014/11/03/高德地图sdk分析/</id>
    <published>2014-11-03T07:27:00.000Z</published>
    <updated>2014-11-18T10:27:43.000Z</updated>
    <content type="html"><![CDATA[<p>高德地图sdk是目前国内使用比较多的地图类sdk（还有百度地图也不错），目前项目中也用到了，但是相关封装还是不够清晰。为了做好这一层封装，首先需要把高德地图sdk研究一下。</p>
<p>高德地图有各种语言版本的sdk，其中iOS的sdk就包含基本sdk、云图sdk，导航sdk。后两个sdk暂时用不到，而基本sdk中又包含2d（栅格地图）和3d（矢量地图）两个版本的库以及搜索的库。今天要分析的就是2d和搜索的framework，最新的sdk版本是2.4.0。<br><a id="more"></a></p>
<p>高德地图sdk是目前国内使用比较多的地图类sdk（还有百度地图也不错），目前项目中也用到了，但是相关封装还是不够清晰。为了做好这一层封装，首先需要把高德地图sdk研究一下。</p>
<p>高德地图有各种语言版本的sdk，其中iOS的sdk就包含基本sdk、云图sdk，导航sdk。后两个sdk暂时用不到，而基本sdk中又包含2d（栅格地图）和3d（矢量地图）两个版本的库以及搜索的库。今天要分析的就是2d和搜索的framework，最新的sdk版本是2.4.0。</p>
<h3 id="几个核心类说明">几个核心类说明</h3>
<h6 id="MAMapView">MAMapView</h6>
<p>地图视图类，sdk中最重要的一个类，用来负责地图的展示，该类直接从UIView继承而来。</p>
<p>1、属性visibleMapRect</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">self.mapView.visibleMapRect </span>=<span class="string"> MAMapRectMake(220880104, 101476980, 272496, 466656);</span></div></pre></td></tr></table></figure>

<p>它定义了地图的可见范围，如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/16632-3c72c4c2f1c5ff9b.png" alt="mamap_2.png"><br>我们如果改变visibleMapRect的大小，地图就会显示不同的区域。</p>
<p>2、属性mapType<br>地图类型，有两种类型： 普通地图和卫星地图，我们经常用到的就是普通地图</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> NS_ENUM(<span class="built_in">NSInteger</span>, MAMapType)</div><div class="line">{</div><div class="line">    MAMapTypeStandard,  <span class="comment">// 普通地图</span></div><div class="line">    MAMapTypeSatellite  <span class="comment">// 卫星地图</span></div><div class="line">};</div></pre></td></tr></table></figure>

<p>3、属性showTraffic<br>是否展示路况拥堵信息，默认是不展示的，一般也用不到。</p>
<p>4、属性scrollEnabled和zoomEnabled<br>MAMapView虽然不是UIScrollView，但自身也实现了滚动和缩放功能（UIWebView同理）。这两个属性可以控制缩放和滚动的开关，默认都是打开的。</p>
<p>5、属性logoCenter和logoSize<br>高德的logo位置和大小，这个logo是需要显示出来的，不能隐藏不能遮挡（尊重知识产权）</p>
<p>6、属性showsCompass、compassOrigin、compassSize<br>地图的罗盘是否展示，展示的位置和大小</p>
<p>7、属性showsScale、scaleOrigin、scaleSize<br>地图的比例尺是否展示，展示的位置和大小</p>
<p>8、属性centerCoordinate<br>地图中心点的经纬度，改变它不会影响缩放比例。</p>
<p>9、属性showsUserLocation、userLocation、userTrackingMode<br>是否显示用户位置，用户位置的数据、用户追踪的模式。</p>
<p>10、属性annotations<br>地图上的标注，显示对应位置有什么东西，比较常用。</p>
<p>11、属性overlays<br>地图上的覆盖图形，能够在地图指定位置绘制自定义的图层，比较常用。</p>
<p>12、属性distanceFilter、desiredAccuracy、headingFilter<br>最小更新距离，定位精度，最小更新角度。</p>
<p>13、协议，MAMapViewDelegate，作为一个自定义的视图，当其数据对应数据发生变化时，肯定会有一些函数回调来改变自身。这些方法都被集中在MAMapViewDelegate中。一共有18个方法，大致可以分为4类：地图区域改变、用户位置发生变化、标注的创建和事件响应已经覆盖层的一些逻辑。个人觉得这个协议太大了，不符合接口分离原则 。</p>
<h6 id="AMapSearchAPI">AMapSearchAPI</h6>
<p>AMapSearchAPI是一个NSObject，代表高德地图的搜索功能。</p>
<p>1、属性timeOut。<br>搜索请求超时时间，默认是20秒。</p>
<p>2、查询接口，不同的查询类型有不同的查询接口。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//<span class="variable">POI</span>查询接口函数，即根据 <span class="variable">POI</span> 参数选项进行 <span class="variable">POI</span> 查询。</div><div class="line"><span class="pp">- <span class="params">(void)</span>AMapPlaceSearch:<span class="params">(<span class="variable">AMapPlaceSearchRequest</span> *)</span>request;</span></div><div class="line"></div><div class="line">//路径规划查询接口。</div><div class="line">- <span class="params">(void)</span>AMapNavigationSearch:<span class="params">(<span class="variable">AMapNavigationSearchRequest</span> *)</span>request;</div><div class="line"></div><div class="line">//输入提示查询接口。</div><div class="line">- <span class="params">(void)</span>AMapInputTipsSearch:<span class="params">(<span class="variable">AMapInputTipsSearchRequest</span> *)</span>request;</div><div class="line"></div><div class="line">//地址编码查询接口。</div><div class="line">- <span class="params">(void)</span>AMapGeocodeSearch:<span class="params">(<span class="variable">AMapGeocodeSearchRequest</span> *)</span>request;</div><div class="line"></div><div class="line">//逆地址编码查询接口。</div><div class="line">- <span class="params">(void)</span>AMapReGoecodeSearch:<span class="params">(<span class="variable">AMapReGeocodeSearchRequest</span> *)</span>request;</div><div class="line"></div><div class="line">//公交线路查询接口。</div><div class="line">- <span class="params">(void)</span>AMapBusLineSearch:<span class="params">(<span class="variable">AMapBusLineSearchRequest</span> *)</span>request;</div><div class="line"></div><div class="line">//公交车站查询接口。</div><div class="line">- <span class="params">(void)</span>AMapBusStopSearch:<span class="params">(<span class="variable">AMapBusStopSearchRequest</span> *)</span>request;</div></pre></td></tr></table></figure>

<p>3、协议AMapSearchDelegate，包含对各种请求接口成功失败的回调。</p>
<h3 id="可以实现的功能">可以实现的功能</h3>
<h6 id="自定义用户坐标点">自定义用户坐标点</h6>
<p>如果起用了定位，如下的方法会被调用到，因为自身打点也是一个Annotation，但这个Annotation的类型是MAUserLocation。然后通过设置MAUserLocationRepresentation，就可以将用户坐标点进行自定义。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)mapView:(MAMapView *)mapView didAddAnnotationViews:(NSArray *)views</div><div class="line">{</div><div class="line">    MAAnnotationView *<span class="variable">view =</span> views[<span class="number">0</span>];</div><div class="line"></div><div class="line">    // 放到该方法中用以保证userlocation的annotationView已经添加到地图上了。</div><div class="line">    <span class="keyword">if</span> ([view.annotation isKindOfClass:[MAUserLocation class]])</div><div class="line">    {</div><div class="line">        MAUserLocationRepresentation *<span class="variable">pre =</span> [[MAUserLocationRepresentation alloc] init];</div><div class="line">        pre.<span class="variable">fillColor =</span> [UIColor colorWithRed:<span class="number">0.9</span> green:<span class="number">0.1</span> blue:<span class="number">0.1</span> alpha:<span class="number">0.3</span>];</div><div class="line">        pre.<span class="variable">strokeColor =</span> [UIColor colorWithRed:<span class="number">0.1</span> green:<span class="number">0.1</span> blue:<span class="number">0.9</span> alpha:<span class="number">1.0</span>];</div><div class="line">        pre.<span class="variable">image =</span> [UIImage imageNamed:@<span class="string">"location.png"</span>];</div><div class="line">        pre.<span class="variable">lineWidth =</span> <span class="number">3</span>;</div><div class="line">        pre.<span class="variable">lineDashPattern =</span> @[@<span class="number">6</span>, @<span class="number">3</span>];</div><div class="line"></div><div class="line">        [self.mapView updateUserLocationRepresentation:pre];</div><div class="line"></div><div class="line">        view.<span class="variable">calloutOffset =</span> CGPointMake(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    }  </div><div class="line">}</div></pre></td></tr></table></figure>

<h6 id="用户手势">用户手势</h6>
<p>缩放和滚动有属性直接控制，单击双击也能够支持，但是为了和AnnotationView进行区分，需要用下面的方法进行过滤。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>gestureRecognizer:<span class="params">(<span class="variable">UIGestureRecognizer</span> *)</span>gestureRecognizer shouldReceiveTouch:<span class="params">(<span class="variable">UITouch</span> *)</span>touch</span></div></pre></td></tr></table></figure>

<h6 id="添加浮层">添加浮层</h6>
<p>浮层对象是遵循MAOverlay协议的对象，可以是圆、折线和多边形。在高德sdk中，MACircle、MAPolyline、MAPolygon都是浮层对象。<br>然后通过</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>addOverlays:<span class="params">(<span class="variable">NSArray</span> *)</span>overlays;</span></div></pre></td></tr></table></figure>

<p>将浮层对象添加到MapView中。</p>
<h6 id="自定义浮层">自定义浮层</h6>
<p>可以自定义浮层对象，只要符合MAOverlay协议即可。然后在绘制图层的代理方法中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(<span class="variable">MAOverlayRenderer</span> *)</span>mapView:<span class="params">(<span class="variable">MAMapView</span> *)</span>mapView viewForOverlay:<span class="params">(id &lt;<span class="variable">MAOverlay</span>&gt;)</span>overlay</span></div></pre></td></tr></table></figure>

<p>子类话一个MAOverlayRenderer并返回，该子类只要重写方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>drawMapRect:<span class="params">(<span class="variable">MAMapRect</span>)</span>mapRect zoomScale:<span class="params">(<span class="variable">MAZoomScale</span>)</span>zoomScale inContext:<span class="params">(<span class="variable">CGContextRef</span>)</span>context</span></div></pre></td></tr></table></figure>

<p>该方法就如果UIView的drawRect，可以随心所欲的在上面画任何东西。</p>
<p>Overlay可以直接贴图，使用MAGroundOverlay类。虽然这个功能用自定义Overlay的方式也能实现，但比较麻烦。用MAGroundOverlay就很简单。</p>
<p>Overlay还支持大地曲线：MAGeodesicPolyline，图片tiles：MATileOverlay。</p>
<h6 id="打点标记">打点标记</h6>
<p>Annotaion就是在地图上标记一个位置，然后展示出来。展示的视图就是用MAAnnotationView。<br>像MapView插入Annotation的方法是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>addAnnotation:<span class="params">(id &lt;<span class="variable">MAAnnotation</span>&gt;)</span>annotation;</span></div></pre></td></tr></table></figure>

<p>类似UITableView，MAAnnotationView的创建实在代理方法中实现的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(<span class="variable">MAAnnotationView</span> *)</span>mapView:<span class="params">(<span class="variable">MAMapView</span> *)</span>mapView viewForAnnotation:<span class="params">(id&lt;<span class="variable">MAAnnotation</span>&gt;)</span>annotation</span></div></pre></td></tr></table></figure>

<p>MAAnnotationView可以自定义，可以有更好的显示效果；Annotation还支持动画，让显示的点动起来。</p>
<h3 id="搜索接口">搜索接口</h3>
<h6 id="POI搜索">POI搜索</h6>
<p>POI(Point of Interest)，信息点，一家餐馆就是一个信息点。POI搜索可以根据ID、关键字、中心点搜索周边、指定范围搜索等搜索方式来满足不同的需求。代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 根据ID来搜索POI. */</span></div><div class="line">- (void)searchPoiByID</div><div class="line">{</div><div class="line">    AMapPlaceSearchRequest *<span class="variable">request =</span> [[AMapPlaceSearchRequest alloc] init];</div><div class="line">    //    B000A80WBJ    hotel</div><div class="line">    //    B00141IEZK    dining</div><div class="line">    //    B000A876EH    cinema</div><div class="line">    //    B000A7O1CU    scenic</div><div class="line">    request.<span class="variable">searchType          =</span> AMapSearchType_PlaceID;</div><div class="line">    request.<span class="variable">uid                 =</span> @<span class="string">"B000A07060"</span>;</div><div class="line">    request.<span class="variable">requireExtension    =</span> YES;</div><div class="line">    </div><div class="line">    [self.search AMapPlaceSearch:request];</div><div class="line">    </div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* 根据关键字来搜索POI. */</span></div><div class="line">- (void)searchPoiByKeyword</div><div class="line">{</div><div class="line">    AMapPlaceSearchRequest *<span class="variable">request =</span> [[AMapPlaceSearchRequest alloc] init];</div><div class="line">    </div><div class="line">    request.<span class="variable">searchType          =</span> AMapSearchType_PlaceKeyword;</div><div class="line">    request.<span class="variable">keywords            =</span> @<span class="string">"肯德基"</span>;</div><div class="line">    request.<span class="variable">city                =</span> @[@<span class="string">"010"</span>];</div><div class="line">    request.<span class="variable">requireExtension    =</span> YES;</div><div class="line">    [self.search AMapPlaceSearch:request];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* 根据中心点坐标来搜周边的POI. */</span></div><div class="line">- (void)searchPoiByCenterCoordinate</div><div class="line">{</div><div class="line">    AMapPlaceSearchRequest *<span class="variable">request =</span> [[AMapPlaceSearchRequest alloc] init];</div><div class="line">    </div><div class="line">    request.<span class="variable">searchType          =</span> AMapSearchType_PlaceAround;</div><div class="line">    request.<span class="variable">location            =</span> [AMapGeoPoint locationWithLatitude:<span class="number">39.990459</span> longitude:<span class="number">116.481476</span>];</div><div class="line">    request.<span class="variable">keywords            =</span> @<span class="string">"餐饮"</span>;</div><div class="line">    <span class="comment">/* 按照距离排序. */</span></div><div class="line">    request.<span class="variable">sortrule            =</span> <span class="number">1</span>;</div><div class="line">    request.<span class="variable">requireExtension    =</span> YES;</div><div class="line">    </div><div class="line">    <span class="comment">/* 添加搜索结果过滤 */</span></div><div class="line">    AMapPlaceSearchFilter *<span class="variable">filter =</span> [[AMapPlaceSearchFilter alloc] init];</div><div class="line">    filter.<span class="variable">costFilter =</span> @[@<span class="string">"100"</span>, @<span class="string">"200"</span>];</div><div class="line">    filter.<span class="variable">requireFilter =</span> AMapRequireGroupbuy;</div><div class="line">    request.<span class="variable">searchFilter =</span> filter;</div><div class="line">    </div><div class="line">    [self.search AMapPlaceSearch:request];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* 在指定的范围内搜索POI. */</span></div><div class="line">- (void)searchPoiByPolygon</div><div class="line">{</div><div class="line">    NSArray *<span class="variable">points =</span> [NSArray arrayWithObjects:</div><div class="line">                       [AMapGeoPoint locationWithLatitude:<span class="number">39.990459</span> longitude:<span class="number">116.481476</span>],</div><div class="line">                       [AMapGeoPoint locationWithLatitude:<span class="number">39.890459</span> longitude:<span class="number">116.581476</span>],</div><div class="line">                       nil];</div><div class="line">    AMapGeoPolygon *<span class="variable">polygon =</span> [AMapGeoPolygon polygonWithPoints:points];</div><div class="line">    </div><div class="line">    AMapPlaceSearchRequest *<span class="variable">request =</span> [[AMapPlaceSearchRequest alloc] init];</div><div class="line">    </div><div class="line">    request.<span class="variable">searchType          =</span> AMapSearchType_PlacePolygon;</div><div class="line">    request.<span class="variable">polygon             =</span> polygon;</div><div class="line">    request.<span class="variable">keywords            =</span> @<span class="string">"Apple"</span>;</div><div class="line">    request.<span class="variable">requireExtension    =</span> YES;</div><div class="line">    </div><div class="line">    [self.search AMapPlaceSearch:request];</div><div class="line">}</div></pre></td></tr></table></figure>

<h6 id="地理编码">地理编码</h6>
<p>输入提示查询</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="constant">AMapInputTipsSearchRequest</span> *tips = [[<span class="constant">AMapInputTipsSearchRequest</span> alloc] init];</div><div class="line">tips.keywords = @<span class="string">"关键字"</span>;</div><div class="line">[<span class="keyword">self</span>.search <span class="constant">AMapInputTipsSearch</span><span class="symbol">:tips</span>];</div></pre></td></tr></table></figure>

<p>输入提示回调</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)onInputTipsSearchDone:(AMapInputTipsSearchRequest *)<span class="built_in">request</span> <span class="built_in">response</span>:(AMapInputTipsSearchResponse *)<span class="built_in">response</span></div><div class="line">{</div><div class="line">    [self.tips setArray:<span class="built_in">response</span>.tips];</div><div class="line">    </div><div class="line">    [self.displayController.searchResultsTableView reloadData];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>搜索地理编码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="constant">AMapGeocodeSearchRequest</span> *geo = [[<span class="constant">AMapGeocodeSearchRequest</span> alloc] init];</div><div class="line">geo.address = key;</div><div class="line">    </div><div class="line"><span class="input"><span class="prompt">if (adcode.length &gt;</span> <span class="number">0</span>)</span></div><div class="line">{</div><div class="line">    geo.city = @[adcode];</div><div class="line">}</div><div class="line">    </div><div class="line">[<span class="keyword">self</span>.search <span class="constant">AMapGeocodeSearch</span><span class="symbol">:geo</span>];</div></pre></td></tr></table></figure>

<p>地理编码回调，得到一个地点的经纬度信息</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>onGeocodeSearchDone:<span class="params">(<span class="variable">AMapGeocodeSearchRequest</span> *)</span>request response:<span class="params">(<span class="variable">AMapGeocodeSearchResponse</span> *)</span>response</span></div><div class="line">{</div><div class="line">}</div></pre></td></tr></table></figure>

<h6 id="逆地理编码">逆地理编码</h6>
<p>逆地理编码与地理编码正好相反，是通过经纬度来查询文字描述的位置信息。<br>发起逆地理编码查询</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AMapReGeocodeSearchRequest *regeo = [[AMapReGeocodeSearchRequest alloc] init];</div><div class="line">    </div><div class="line"><span class="filename">regeo.location = [AMapGeoPoint locationWithLatitude</span>:<span class="filename">coordinate.latitude longitude</span>:<span class="filename">coordinate.longitude];</span></div><div class="line">regeo.requireExtension = YES;</div><div class="line">    </div><div class="line">[self.search AMapReGoecodeSearch:regeo];</div></pre></td></tr></table></figure>

<p>逆地理编码回调</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)onReGeocodeSearchDone:(AMapReGeocodeSearchRequest *)<span class="built_in">request</span> <span class="built_in">response</span>:(AMapReGeocodeSearchResponse *)<span class="built_in">response</span></div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">response</span>.regeocode != nil)</div><div class="line">    {</div><div class="line">        CLLocationCoordinate2D coordinate = CLLocationCoordinate2DMake(<span class="built_in">request</span>.location.latitude, <span class="built_in">request</span>.location.longitude);</div><div class="line">        ReGeocodeAnnotation *reGeocodeAnnotation = [[ReGeocodeAnnotation alloc] initWithCoordinate:coordinate</div><div class="line">                                                                                         reGeocode:<span class="built_in">response</span>.regeocode];</div><div class="line">        </div><div class="line">        [self.mapView addAnnotation:reGeocodeAnnotation];</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>除了以上的搜索，还有导航、搜索公交路线、公交站，这些再一般的应用中不会用到，就不介绍了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>高德地图sdk是目前国内使用比较多的地图类sdk（还有百度地图也不错），目前项目中也用到了，但是相关封装还是不够清晰。为了做好这一层封装，首先需要把高德地图sdk研究一下。</p>
<p>高德地图有各种语言版本的sdk，其中iOS的sdk就包含基本sdk、云图sdk，导航sdk。后两个sdk暂时用不到，而基本sdk中又包含2d（栅格地图）和3d（矢量地图）两个版本的库以及搜索的库。今天要分析的就是2d和搜索的framework，最新的sdk版本是2.4.0。<br>]]>
    
    </summary>
    
      <category term="高德" scheme="http://linkageios.github.io/tags/%E9%AB%98%E5%BE%B7/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个简单的分享框架]]></title>
    <link href="http://linkageios.github.io/2014/10/29/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E4%BA%AB%E6%A1%86%E6%9E%B6/"/>
    <id>http://linkageios.github.io/2014/10/29/一个简单的分享框架/</id>
    <published>2014-10-29T02:33:00.000Z</published>
    <updated>2014-11-18T10:28:21.000Z</updated>
    <content type="html"><![CDATA[<h3 id="背景">背景</h3>
<p>分享，是APP中一个基础功能，可以为APP提供传播渠道。APP中分享功能的开发主要有两种形式：</p>
<ul>
<li>集成各个分享平台提供的sdk。<br> 常用的社交软件，如微信、微博，都有各自的开放平台，提供各种语言的sdk。使用sdk，我们可以快速的将分享功能加到应用中。</li>
<li>使用分享集成框架。<br>虽然使用sdk开发已经很快了，但是不同的分享平台有不同的特点，一个一个去集成研究还是要花费一定时间。而分享功能在展现形式和交互流程上又有共通性，所以技术上也存在整合的可行性。因此，市场上出现了如友盟等第三方分享平台，开发者只需要加很少的代码，就能集成几乎所有的分享渠道。</li>
</ul>
<p>既然友盟等已经做的这么好了，为什么还要自己做分享框架呢？</p>
<p>首先，技术上的不可控性。我们依赖友盟，友盟再依赖原生sdk，环节越多，中间的风险就越多。<br>其次，展现上的雷同。用友盟等工具的APP基本上是一样的展现形式，如果你做的只是一款大陆货，那没问题；但想做好，雷同就是首先要避免的。<br>最后，确实有时间做这个。做这个东西，集成了微信、微博、短信、邮件，总共花了三天。<br><a id="more"></a></p>
<h3 id="背景-1">背景</h3>
<p>分享，是APP中一个基础功能，可以为APP提供传播渠道。APP中分享功能的开发主要有两种形式：</p>
<ul>
<li>集成各个分享平台提供的sdk。<br> 常用的社交软件，如微信、微博，都有各自的开放平台，提供各种语言的sdk。使用sdk，我们可以快速的将分享功能加到应用中。</li>
<li>使用分享集成框架。<br>虽然使用sdk开发已经很快了，但是不同的分享平台有不同的特点，一个一个去集成研究还是要花费一定时间。而分享功能在展现形式和交互流程上又有共通性，所以技术上也存在整合的可行性。因此，市场上出现了如友盟等第三方分享平台，开发者只需要加很少的代码，就能集成几乎所有的分享渠道。</li>
</ul>
<p>既然友盟等已经做的这么好了，为什么还要自己做分享框架呢？</p>
<p>首先，技术上的不可控性。我们依赖友盟，友盟再依赖原生sdk，环节越多，中间的风险就越多。<br>其次，展现上的雷同。用友盟等工具的APP基本上是一样的展现形式，如果你做的只是一款大陆货，那没问题；但想做好，雷同就是首先要避免的。<br>最后，确实有时间做这个。做这个东西，集成了微信、微博、短信、邮件，总共花了三天。</p>
<h3 id="实现">实现</h3>
<ul>
<li><p>准备工作<br>因为目前我们要用的分享渠道只有微信朋友圈、微信好友、新浪微博、短信、邮件。所以需要准备的sdk只有微信和新浪，把sdk大概看一遍，跑一下Demo，就可以进行设计了。</p>
</li>
<li><p>接口<br>分享框架的客户是公司内部的iOS程序员，别人没有义务了解你的sdk究竟是怎么做的。以前用的友盟一行代码就能搞定，所以这个框架也必须要足够简单。因此，我还是参照了友盟的接口，设计了该框架唯一的分享接口。</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//LCShareSDK.h</span></div><div class="line">+ (<span class="keyword">void</span>)presentShareMenu:(<span class="built_in">NSArray</span>*)menu</div><div class="line">        inViewController:(<span class="built_in">UIViewController</span>*)viewController</div><div class="line">               shareItem:(LCShareItem*)item</div><div class="line">                delegate:(<span class="keyword">id</span>&lt;LCShareDelegate&gt;)delegate;</div></pre></td></tr></table></figure>

<ul>
<li>实现<br>主要是采用了单例模式来开发。虽然能够覆盖现有的使用场景，但不支持多线程，而且设计模式中最鄙视单例模式，这是一种让人懒惰的模式（个人观点）。<br>最上层给用户看到只有一个叫LCShareSDK的类，只有一个类方法。中间层分别对新浪微博、微信sdk进行封装，分别提供一个Manager类，也是单例。短信和邮件比较简单，逻辑处理就在LCShareSDK类里面实现。最下层是微信和新浪微博的sdk。<br>此外，新浪微博我用的不是最新的sdk，是有代码的。这样我就可以在程序内部进行分享，而且可以自定义授权页面和分享界面，灵活性很好。所以作为框架的一部分，还有授权和分享两个ViewController。<br>以下是结构图<br><img src="http://upload-images.jianshu.io/upload_images/16632-f852fef3b1f23475.png" alt="share.png"></li>
</ul>
<p>新浪微博里面默认的授权页面是弹出式的页面，弹出框还没有网页打，我觉得比较丑，就用自己写的LCShareOauthViewController替换了原有的View（这就是老版本sdk的好处，最新sdk只有静态库了）。</p>
<h3 id="使用">使用</h3>
<p>使用非常简单，在ViewController(非必须，但参数中是需要ViewController的)里面如下调用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LCShareItem* <span class="variable">shareItem =</span> [LCShareItem new];</div><div class="line">shareItem.<span class="variable">title =</span> @<span class="string">"XXXX"</span>;</div><div class="line">shareItem.<span class="variable">desc =</span> @<span class="string">"YYYY"</span>;</div><div class="line">shareItem.<span class="variable">image =</span> [UIImage imageNamed:SHARE_ICON];</div><div class="line">shareItem.<span class="variable">url =</span> @<span class="string">"http://www.qq.com"</span>;</div><div class="line">        </div><div class="line">[LCShareSDK presentShareMenu:@[@(WXMoments),@(WXFriend),@(Weibo),@(SMS),@(Mail)]</div><div class="line">            inViewController:self</div><div class="line">                   shareItem:shareItem</div><div class="line">                    delegate:self];</div></pre></td></tr></table></figure>

<p>然后就会弹出分享菜单：<br><img src="http://upload-images.jianshu.io/upload_images/16632-137ada9d0cca3657.png" alt="share_menu2.png"></p>
<p>如果之前没有授权过，下一步是打开授权页面，如果已安装微博，就会进行SSO授权。<br><img src="http://upload-images.jianshu.io/upload_images/16632-e60aaae234179c63.png" alt="share_oauth.png"></p>
<p>最后出现分享界面，点击发送即可分享。<br><img src="http://upload-images.jianshu.io/upload_images/16632-9db4f6b115712302.png" alt="share_content2.png"></p>
<p>除了那个分享接口，我们还提供了两个代理方法，用来判断用户点了哪个渠道，哪个渠道的分享结果。当然，这两个方法不是必须要实现的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">LCShareDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@optional</span></div><div class="line"></div><div class="line"><span class="comment">//点完了某个分享渠道按钮</span></div><div class="line">- (<span class="keyword">void</span>)didSelectShareWithSource:(LCShareSource)source;</div><div class="line"></div><div class="line"><span class="comment">//分享结果回调（成功或失败）</span></div><div class="line">- (<span class="keyword">void</span>)didFinishShareWithResponse:(LCShareResponse*)response;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>还有在AppDelegate里面要做些初始化工作，比如在程序启动时注册微信：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">[LCShareSDK registerWXApp:kWeiXinAppId]</span><span class="comment">;</span></div></pre></td></tr></table></figure>

<p>从微信或微博返回APP时的处理：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application openURL:(<span class="built_in">NSURL</span> *)url sourceApplication:(<span class="built_in">NSString</span> *)sourceApplication annotation:(<span class="keyword">id</span>)annotation</div><div class="line">{ </div><div class="line">    <span class="keyword">return</span> [LCShareSDK handleOpenUrl:url];</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h3 id="背景">背景</h3>
<p>分享，是APP中一个基础功能，可以为APP提供传播渠道。APP中分享功能的开发主要有两种形式：</p>
<ul>
<li>集成各个分享平台提供的sdk。<br> 常用的社交软件，如微信、微博，都有各自的开放平台，提供各种语言的sdk。使用sdk，我们可以快速的将分享功能加到应用中。</li>
<li>使用分享集成框架。<br>虽然使用sdk开发已经很快了，但是不同的分享平台有不同的特点，一个一个去集成研究还是要花费一定时间。而分享功能在展现形式和交互流程上又有共通性，所以技术上也存在整合的可行性。因此，市场上出现了如友盟等第三方分享平台，开发者只需要加很少的代码，就能集成几乎所有的分享渠道。</li>
</ul>
<p>既然友盟等已经做的这么好了，为什么还要自己做分享框架呢？</p>
<p>首先，技术上的不可控性。我们依赖友盟，友盟再依赖原生sdk，环节越多，中间的风险就越多。<br>其次，展现上的雷同。用友盟等工具的APP基本上是一样的展现形式，如果你做的只是一款大陆货，那没问题；但想做好，雷同就是首先要避免的。<br>最后，确实有时间做这个。做这个东西，集成了微信、微博、短信、邮件，总共花了三天。<br>]]>
    
    </summary>
    
      <category term="分享" scheme="http://linkageios.github.io/tags/%E5%88%86%E4%BA%AB/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
</feed>
