<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[SmartArrow]]></title>
  <subtitle><![CDATA[技术文档]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://linkageios.github.io/"/>
  <updated>2014-12-01T05:27:20.922Z</updated>
  <id>http://linkageios.github.io/</id>
  
  <author>
    <name><![CDATA[SmartArrow]]></name>
    <email><![CDATA[stephenzhumail@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[关于文档类工作输出要求]]></title>
    <link href="http://linkageios.github.io/2014/12/01/%E5%85%B3%E4%BA%8E%E6%96%87%E6%A1%A3%E7%B1%BB%E5%B7%A5%E4%BD%9C%E8%BE%93%E5%87%BA%E8%A6%81%E6%B1%82/"/>
    <id>http://linkageios.github.io/2014/12/01/关于文档类工作输出要求/</id>
    <published>2014-12-01T05:24:53.000Z</published>
    <updated>2014-12-01T05:25:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="模板说明">模板说明</h2>
<ul>
<li>title 文档的标题</li>
<li>data 文档编写或修改的时间</li>
<li>categories 文档的类别，多个以半角逗号和方括号构成</li>
<li>tags 文档的tag，多个以半角逗号和方括号构成</li>
<li>分隔符—-这一行保留</li>
<li><code>&lt;!--more--&gt;</code>和分隔符<code>---</code>之间的内容为文档摘要</li>
<li>其中图片必须使用本地相对路径<code>![imag](../images/xxx.png)</code></li>
<li>文档提交地址<a href="http://172.16.128.161/ios/technology-blog.git" target="_blank" rel="external">http://172.16.128.161/ios/technology-blog.git</a></li>
<li>文档地址 ./source/_posts/*.md</li>
<li>图片地址 ./source/images/*.png</li>
<li>xxx 正文<br><a id="more"></a><h1 id="关于文档类工作输出要求">关于文档类工作输出要求</h1>
</li>
</ul>
<h2 id="模板">模板</h2>
<pre><code>title: iOS代码规范
date: 2014-11-07 13:38:14
categories: [iOS,执行文档]
tags: [效率]
---
# 代码规范的内容？
代码规范包含的范围十分广泛。从一个变量的命名到一个类的设计，我觉得都属于代码规范的范畴。从实践的角度，可以把代码规范分成两个部分：
第一部分是规则，即一定要这么做。这里面没有对错，但需要统一。包含变量的命名、函数的命名、模块的组织、代码块的组织、宏、枚举、常量的声明、函数的粒度。
第二部分是风格，即一种模式化的代码设计结构。我们实现某个功能时，往往不止一种实现方式。每一种实现    方式没有绝对的高低之分，不同角度的解读，就会有不同的偏好。所以这个层面上的代码规范，只能求同存异。但是不管怎样，每个人必须要有一致性的风格。就像不同的小区可以有不同的风格，但同一个小区只能有一种设计风格。风格包含代码设计中的抽象概念，比如接口、继承等等。
<span class="comment">&lt;!--more--&gt;</span>
xxxxxx
</code></pre><h2 id="模板说明-1">模板说明</h2>
<ul>
<li>title 文档的标题</li>
<li>data 文档编写或修改的时间</li>
<li>categories 文档的类别，多个以半角逗号和方括号构成</li>
<li>tags 文档的tag，多个以半角逗号和方括号构成</li>
<li>分隔符—-这一行保留</li>
<li><code>&lt;!--more--&gt;</code>和分隔符<code>---</code>之间的内容为文档摘要</li>
<li>其中图片必须使用本地相对路径<code>![imag](../images/xxx.png)</code></li>
<li>文档提交地址<a href="http://172.16.128.161/ios/technology-blog.git" target="_blank" rel="external">http://172.16.128.161/ios/technology-blog.git</a></li>
<li>文档地址 ./source/_posts/*.md</li>
<li>图片地址 ./source/images/*.png</li>
<li>xxx 正文</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="模板说明">模板说明</h2>
<ul>
<li>title 文档的标题</li>
<li>data 文档编写或修改的时间</li>
<li>categories 文档的类别，多个以半角逗号和方括号构成</li>
<li>tags 文档的tag，多个以半角逗号和方括号构成</li>
<li>分隔符—-这一行保留</li>
<li><code>&lt;!--more--&gt;</code>和分隔符<code>---</code>之间的内容为文档摘要</li>
<li>其中图片必须使用本地相对路径<code>![imag](../images/xxx.png)</code></li>
<li>文档提交地址<a href="http://172.16.128.161/ios/technology-blog.git" target="_blank" rel="external">http://172.16.128.161/ios/technology-blog.git</a></li>
<li>文档地址 ./source/_posts/*.md</li>
<li>图片地址 ./source/images/*.png</li>
<li>xxx 正文<br>]]>
    
    </summary>
    
      <category term="效率" scheme="http://linkageios.github.io/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
      <category term="执行文档" scheme="http://linkageios.github.io/categories/iOS/%E6%89%A7%E8%A1%8C%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LCBaseViewController相关]]></title>
    <link href="http://linkageios.github.io/2014/11/07/LCBaseViewController%E7%9B%B8%E5%85%B3/"/>
    <id>http://linkageios.github.io/2014/11/07/LCBaseViewController相关/</id>
    <published>2014-11-07T05:38:14.000Z</published>
    <updated>2014-11-18T09:20:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2>
<p>该基类参考原先项目中BaseViewController等几个类 进行修改 功能暂时满足目前项目需求 日后更新会根据项目迭代中提出的需求在进行修改</p>
<h2 id="属性和函数说明">属性和函数说明</h2>
<p>LCViewControllerShowType：viewController出现的方式 具体分为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LCViewControllerShowTypePush                （<span class="keyword">pop</span>/<span class="keyword">push</span>方式）（默认）</div><div class="line">LCViewControllerShowTypePresent             （present/dismiss方式）</div><div class="line">LCViewControllerShowTypePresentBasic        （作为没有登录的情况下，登陆界面返回按钮 跳转到首页的凭据）</div></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="简介-1">简介</h2>
<p>该基类参考原先项目中BaseViewController等几个类 进行修改 功能暂时满足目前项目需求 日后更新会根据项目迭代中提出的需求在进行修改</p>
<h2 id="属性和函数说明-1">属性和函数说明</h2>
<p>LCViewControllerShowType：viewController出现的方式 具体分为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LCViewControllerShowTypePush                （<span class="keyword">pop</span>/<span class="keyword">push</span>方式）（默认）</div><div class="line">LCViewControllerShowTypePresent             （present/dismiss方式）</div><div class="line">LCViewControllerShowTypePresentBasic        （作为没有登录的情况下，登陆界面返回按钮 跳转到首页的凭据）</div></pre></td></tr></table></figure>

<p>LCNavigationBarStyle： navigationBar 的样式 主要是背景色</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">LCNavigationBarRed</span>             navigationBar 一级,红色背景</div></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/79888-d6fa0aed379b25d2.png" alt="LCNavigationBarRed"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">LCNavigationBarWhite</span>          navigationBar 二级,白色背景（默认）</div></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/79888-6225382ae2b09d27.png" alt="LCNavigationBarWhite"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">LCNavigationBarNull</span>             navigationBar 二级,隐藏navigaitonbar</div></pre></td></tr></table></figure>

<p>提供函数方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//设置导航栏背景图片</div><div class="line"><span class="pp">- <span class="params">(void)</span>configNavigationBarBgImage;</span></div><div class="line">//设置左边的返回按钮</div><div class="line">- <span class="params">(void)</span>setLeftBackButton;</div><div class="line">- <span class="params">(void)</span>setLeftBackButtonAction:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//设置左边的返回按钮<span class="params">(图片按钮)</span></div><div class="line">- <span class="params">(void)</span>setLeftButtonWithImageName:<span class="params">(<span class="variable">NSString</span>*)</span>imageName action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//设置左边的返回按钮<span class="params">(文字按钮)</span></div><div class="line">- <span class="params">(void)</span>setLeftButtonWithTitle:<span class="params">(<span class="variable">NSString</span>*)</span>title action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//设置左边的返回按钮<span class="params">(通用按钮)</span></div><div class="line">- <span class="params">(void)</span>setLeftButton:<span class="params">(<span class="variable">UIButton</span>*)</span>button action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//设置中间的文本标题</div><div class="line">- <span class="params">(void)</span>setTitleViewWithText:<span class="params">(<span class="variable">NSString</span>*)</span>text;</div><div class="line">//设置右边的按钮<span class="params">(文字按钮)</span></div><div class="line">- <span class="params">(void)</span>setRightButtonWithTitle:<span class="params">(<span class="variable">NSString</span>*)</span>title action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//设置右边的按钮<span class="params">(图片按钮)</span></div><div class="line">- <span class="params">(void)</span>setRightButtonWithImageName:<span class="params">(<span class="variable">NSString</span>*)</span>imageName action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">- <span class="params">(void)</span>setRightButtonWithNormarlImageName:<span class="params">(<span class="variable">NSString</span>*)</span>normarName highlightedImageName:<span class="params">(<span class="variable">NSString</span> *)</span>highlightedName action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//设置右边的按钮</div><div class="line">- <span class="params">(void)</span>setRightButton:<span class="params">(<span class="variable">UIButton</span>*)</span>button action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//多个按钮 分别有文字或图片 （btnStrs 中vo 为dic 具体参考下面栗子）</div><div class="line">- <span class="params">(void)</span>setRightButtons:<span class="params">(<span class="variable">NSArray</span> *)</span>btnStrs;</div><div class="line">- <span class="params">(void)</span>setRightButtonImages:<span class="params">(<span class="variable">NSArray</span> *)</span>images;</div><div class="line">- <span class="params">(void)</span>rightButtonAction:<span class="params">(id)</span>sender;</div><div class="line">//返回按钮的响应事件</div><div class="line">- <span class="params">(void)</span>backButtonPressed:<span class="params">(id)</span>sender;</div></pre></td></tr></table></figure>

<p>提供方法中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>setRightButtons:<span class="params">(<span class="variable">NSArray</span> *)</span>btnStrs;</span></div></pre></td></tr></table></figure>

<p>btnStrs为包含vo对象的一个数组</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">vo =</span> {</div><div class="line">@<span class="string">" title"</span>     : @<span class="string">"返回"</span>,</div><div class="line">@<span class="string">"normalImage"</span>:@<span class="string">"fanhui.png"</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>具体使用为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *rightbarButtonVos = @[@{<span class="string">@"title"</span>:<span class="string">@"第一个"</span>,<span class="string">@"normalImage"</span>:<span class="string">@"first.png"</span>},@{<span class="string">@"title"</span>:<span class="string">@"第二个"</span>,<span class="string">@"normalImage"</span>:<span class="string">@"second.png"</span>}];</div><div class="line">[<span class="keyword">self</span> setRightButtons: rightbarButtonVos];</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简介">简介</h2>
<p>该基类参考原先项目中BaseViewController等几个类 进行修改 功能暂时满足目前项目需求 日后更新会根据项目迭代中提出的需求在进行修改</p>
<h2 id="属性和函数说明">属性和函数说明</h2>
<p>LCViewControllerShowType：viewController出现的方式 具体分为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LCViewControllerShowTypePush                （<span class="keyword">pop</span>/<span class="keyword">push</span>方式）（默认）</div><div class="line">LCViewControllerShowTypePresent             （present/dismiss方式）</div><div class="line">LCViewControllerShowTypePresentBasic        （作为没有登录的情况下，登陆界面返回按钮 跳转到首页的凭据）</div></pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="LCBaseViewController" scheme="http://linkageios.github.io/tags/LCBaseViewController/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS代码规范]]></title>
    <link href="http://linkageios.github.io/2014/11/07/iOS%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://linkageios.github.io/2014/11/07/iOS编码规范/</id>
    <published>2014-11-07T05:38:14.000Z</published>
    <updated>2014-11-18T10:26:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="为什么要有代码规范？">为什么要有代码规范？</h1>
<p>对于团队，如果代码风格不统一，阅读或修改同事的代码会非常困难，造成潜在的风险。</p>
<p>对于个人，代码规范是对自身编码习惯的一种监督，如果没有这种监督，有时候因为偷懒，会写出难看的代码，时间长了自己都看不懂。这样对于代码的维护性是不利的。</p>
<h1 id="代码规范的内容？">代码规范的内容？</h1>
<p>代码规范包含的范围十分广泛。从一个变量的命名到一个类的设计，我觉得都属于代码规范的范畴。从实践的角度，可以把代码规范分成两个部分：</p>
<p>第一部分是规则，即一定要这么做。这里面没有对错，但需要统一。包含变量的命名、函数的命名、模块的组织、代码块的组织、宏、枚举、常量的声明、函数的粒度。</p>
<p>第二部分是风格，即一种模式化的代码设计结构。我们实现某个功能时，往往不止一种实现方式。每一种实现方式没有绝对的高低之分，不同角度的解读，就会有不同的偏好。所以这个层面上的代码规范，只能求同存异。但是不管怎样，每个人必须要有一致性的风格。就像不同的小区可以有不同的风格，但同一个小区只能有一种设计风格。风格包含代码设计中的抽象概念，比如接口、继承等等。<br><a id="more"></a></p>
<h1 id="为什么要有代码规范？-1">为什么要有代码规范？</h1>
<p>对于团队，如果代码风格不统一，阅读或修改同事的代码会非常困难，造成潜在的风险。</p>
<p>对于个人，代码规范是对自身编码习惯的一种监督，如果没有这种监督，有时候因为偷懒，会写出难看的代码，时间长了自己都看不懂。这样对于代码的维护性是不利的。</p>
<h1 id="代码规范的内容？-1">代码规范的内容？</h1>
<p>代码规范包含的范围十分广泛。从一个变量的命名到一个类的设计，我觉得都属于代码规范的范畴。从实践的角度，可以把代码规范分成两个部分：</p>
<p>第一部分是规则，即一定要这么做。这里面没有对错，但需要统一。包含变量的命名、函数的命名、模块的组织、代码块的组织、宏、枚举、常量的声明、函数的粒度。</p>
<p>第二部分是风格，即一种模式化的代码设计结构。我们实现某个功能时，往往不止一种实现方式。每一种实现方式没有绝对的高低之分，不同角度的解读，就会有不同的偏好。所以这个层面上的代码规范，只能求同存异。但是不管怎样，每个人必须要有一致性的风格。就像不同的小区可以有不同的风格，但同一个小区只能有一种设计风格。风格包含代码设计中的抽象概念，比如接口、继承等等。</p>
<h1 id="代码的规则">代码的规则</h1>
<p>规则如同法律，尽管从心底里很多人不认可，但每个人都必须遵守。看起来大家都受了束缚，但是对整个社会以及每一个人都是利大于弊。</p>
<h2 id="变量命名">变量命名</h2>
<p>变量命名历史上产生过很多方法，比较著名的有匈牙利命名法、驼峰命名法、下划线命名法。</p>
<ul>
<li>匈牙利命名法：szUserName</li>
<li>驼峰命名法：userName</li>
<li>下划线命名法：user_name</li>
</ul>
<p>用Objective-C开发，我们就参考苹果的官方命名方式即可，苹果采用的是驼峰命名法。</p>
<p>苹果的变量命名方式常常被其它语言的开发者所吐槽，因为它的名有时候是在太长了！！！下面是3个最长的Objective-C属性名：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">automaticallyEnablesStillImageStabilizationWhenAvailable</span></div><div class="line">availableMediaCharacteristicsWithMediaSelectionOptions</div><div class="line">outputObscuredDueToInsufficientExternalProtection</div></pre></td></tr></table></figure>

<p>变量声明最重要的是清晰其次才考虑长短，如果为了简短而含糊不清，是不可取的。</p>
<p>拿现有代码举例</p>
<table>
<thead>
<tr>
<th style="text-align:left">变量含义</th>
<th style="text-align:left">Not Good</th>
<th style="text-align:left">Good</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">昵称输入框</td>
<td style="text-align:left">tfNickName</td>
<td style="text-align:left">nickNameTextField</td>
</tr>
<tr>
<td style="text-align:left">密码ImageView</td>
<td style="text-align:left">imvPass</td>
<td style="text-align:left">passwordImageView</td>
</tr>
<tr>
<td style="text-align:left">我的搜索条</td>
<td style="text-align:left">mysearchBar</td>
<td style="text-align:left">mySearchBar</td>
</tr>
</tbody>
</table>
<p><strong>类变量</strong><br>前面加下划线，和系统框架保持一致</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">@interface UIViewController : UIResponder &lt;NSCoding, UIAppearanceContainer&gt; </span></div><div class="line">{</div><div class="line">    UIView           <span class="keyword">*</span>_view;</div><div class="line">    UITabBarItem     <span class="keyword">*</span>_tabBarItem;</div><div class="line">    UINavigationItem <span class="keyword">*</span>_navigationItem;</div><div class="line">    NSArray          <span class="keyword">*</span>_toolbarItems;</div><div class="line">    NSString         <span class="keyword">*</span>_title;</div><div class="line">    NSString         <span class="keyword">*</span>_nibName;</div><div class="line">    NSBundle         <span class="keyword">*</span>_nibBundle;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现有的例子</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CouponListTableViewCell</span> : <span class="title">UITableViewCell</span></span></div><div class="line">{</div><div class="line">    <span class="built_in">UIImageView</span> *imageIcon;</div><div class="line">    <span class="built_in">UIImageView</span> *imageCollect;</div><div class="line">    <span class="built_in">UILabel</span> *labelName;</div><div class="line">    <span class="built_in">UILabel</span> *labelPriceSale;</div><div class="line">    <span class="built_in">UILabel</span> *labelPriceOrigin;</div><div class="line">    <span class="built_in">UILabel</span> *labelSaleNumber;</div><div class="line">    <span class="built_in">UIImageView</span> *imageArrow;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>类变量与属性</strong><br>属性是Objective-C的一种高级语法，属性可以完全替换类变量，并且提供更强大的访问控制（strong、weak、nonatomic、readonly…）,而且属性也只需要用一行就能搞定，所以为什么还要用类变量呢？<br>属性声明后不用写@synthesize，且会自动生成类变量。<br><!--
 [资料>](http://stackoverflow.com/questions/12119284/xcode-4-automatically-generates-ivars-when-using-property-where-can-i-find-the)
--></p>
<p><strong>例外</strong></p>
<ul>
<li>一些局部变量允许用最简单的方式命名：i、j、temp</li>
<li>一些常用的缩写可以不用驼峰：RMB，OBD</li>
</ul>
<h2 id="函数命名">函数命名</h2>
<p>Objective-C中的函数不同于其他语言，函数名是按参数隔开的。初看起来是有点怪，但是习惯了就会发现这样和命名方式可读性极好，就像一句话一样。所以当你的函数名不能流利的读出来的话，那么它的命名肯定就有问题。<br>还是先举系统的例子</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>willAnimateFirstHalfOfRotationToInterfaceOrientation:<span class="params">(<span class="variable">UIInterfaceOrientation</span>)</span>toInterfaceOrientation </span></div><div class="line">                                                    duration:<span class="params">(<span class="variable">NSTimeInterval</span>)</span>duration</div></pre></td></tr></table></figure>

<p>这里面值得注意的几点：</p>
<ul>
<li>最左边的（+、-）和返回类型的左括号之间有一个空格，返回类型的右括号与第一个参数之间没有空格；</li>
<li>函数名中每一段描述都以小写字母开头，描述的写法要考虑清晰明确，参考变量命名；</li>
<li>如果函数名过长，应该换行，按冒号对齐；</li>
<li>从描述中可以看出对应参数的意义。</li>
</ul>
<p>再看看我们自己的命名</p>
<ol>
<li>最后一个参数描述Selector首字母大写了</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (<span class="tag">UIButton</span> *)<span class="tag">createButton</span><span class="pseudo">:(MUButtonItemAttribute</span> *)<span class="tag">attr</span> </div><div class="line">               <span class="tag">target</span><span class="pseudo">:(id)target</span> </div><div class="line">             <span class="tag">Selector</span><span class="pseudo">:(SEL)sel</span>;</div></pre></td></tr></table></figure>

<ol>
<li>有一些多余的空格</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="addition">+ (AppDelegate *) appDelegate;</span></div><div class="line"><span class="deletion">- (void)hideTabbar :(BOOL)status;</span></div></pre></td></tr></table></figure>

<ol>
<li>加减号和括号之间要有空格</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>pushEvent:<span class="params">(<span class="variable">NSDictionary</span>*)</span>dictionary target:<span class="params">(id)</span>target;</span></div></pre></td></tr></table></figure>


<ol>
<li>参数名和参数要对应，含义清晰</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>setNavBackButton:<span class="params">(<span class="variable">NSString</span> *)</span>string;</span></div><div class="line">- <span class="params">(id)</span>init:<span class="params">(<span class="variable">NSString</span>*)</span>nickName phoneNumber:<span class="params">(<span class="variable">NSString</span> *)</span>phoneNumber;</div><div class="line">- <span class="params">(void)</span>setTextFieldBackGroud:<span class="params">(<span class="variable">CGRect</span>)</span>rect;</div><div class="line">- <span class="params">(id)</span>init:<span class="params">(<span class="variable">NSInteger</span>)</span>flag;</div><div class="line">- <span class="params">(void)</span>requestHealthRecord:<span class="params">(<span class="variable">NSString</span> *)</span>typeStr;</div></pre></td></tr></table></figure>

<ol>
<li>函数名过长要换行</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(id)</span>initWithStyle:<span class="params">(<span class="variable">UITableViewCellStyle</span>)</span>style</span></div><div class="line">    reuseIdentifier:<span class="params">(<span class="variable">NSString</span> *)</span>reuseIdentifier</div><div class="line">containingTableView:<span class="params">(<span class="variable">UITableView</span> *)</span>containingTableView</div><div class="line"> leftUtilityButtons:<span class="params">(<span class="variable">NSArray</span> *)</span>leftUtilityButtons </div><div class="line">rightUtilityButtons:<span class="params">(<span class="variable">NSArray</span> *)</span>rightUtilityButtons;</div></pre></td></tr></table></figure>

<ol>
<li>命名风格混乱</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (NSInteger)GetServerBack:(NSString *)serverName</div><div class="line">                path_Param:(NSMutableDictionary*)path_Param</div><div class="line">               query_Param:(NSMutableDictionary*)query_Param</div><div class="line">                body_Param:(NSMutableDictionary*)body_Param</div><div class="line">                    <span class="function"><span class="keyword">method</span>:</span>(NSInteger)<span class="function"><span class="keyword">method</span></span></div><div class="line">               <span class="title">returnValue</span>:(NSMutableDictionary*)returnValue;</div></pre></td></tr></table></figure>

<ol>
<li>参数之间用and、with，多此一举</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(id)</span>initWithFrame:<span class="params">(<span class="variable">CGRect</span>)</span>frame </span></div><div class="line">       andImageView:<span class="params">(<span class="variable">UIImageView</span>*)</span>imageView </div><div class="line">     withImageFrame:<span class="params">(<span class="variable">CGRect</span>)</span>imageInitFrame </div><div class="line">       withImageUrl:<span class="params">(<span class="variable">NSURL</span>*)</span>imageUrl;</div></pre></td></tr></table></figure>


<p><strong>命名很重要！！！</strong><br>良好的命名是写出高质量代码的前提，命名的时候除了符合以上的规范，还需要找到合适的单词来表达含义，不要为了一时之快用拼音，也千万不要出现数字。</p>
<h2 id="代码模块组织">代码模块组织</h2>
<p>这个代码模块的组织是指文件级别的，即我们应该如何划分包。<br>现有的包结构是有些问题的，导致我们找某个功能的实现文件比较麻烦。<br><a href="!--
参考[别人的经验](http://www.cocoachina.com/industry/20140225/7879.html)，个人觉得这样的划分还是不错的。
--">!--
参考[别人的经验](http://www.cocoachina.com/industry/20140225/7879.html)，个人觉得这样的划分还是不错的。
--</a></p>
<p><strong>文件的命名</strong><br>我们自己创建的文件，应该有统一的前缀。比如HJMainViewController，这也符合系统的命名规范。Objective-C没有namespace，所以这样做的好处是当你引用了第三方的代码时，防止重名。而且当我们自己的代码越来越大时，内部也会出现冲突。</p>
<p><strong>一个文件一个类</strong><br>好处：</p>
<ul>
<li>减少单个文件的长度</li>
<li>定位文件更方便</li>
<li>便于重用</li>
</ul>
<h2 id="代码块的组织">代码块的组织</h2>
<p>作为一个程序员，大部分时间实在看代码而不是在写。所以代码的可读性严重影响到我们的工作效率。<br>当你看到超过1000行的实现文件时，你还有看下去的欲望吗？<br>所以千万不要写出超过1000行的代码，有的话也得重构。<br><!--[重构掉](http://www.objc.io/issue-1/)。 --></p>
<p>当代码控制到1000行以内后，只是具备了可读的基本条件。我们的屏幕一般只能一次显示50行代码，从头看到尾就是20屏，常常会看了后面忘了前面。所以我们要把一个文件里面的所有函数有秩序的组织起来，让人不用重头看到尾，就能很快定位到想看的地方。<br>这里提供一个小办法：用#pragma mark宏根据功能区分开:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pragma mark - Life Circle</div><div class="line">pragma mark - <span class="keyword">Public</span> <span class="keyword">Interface</span></div><div class="line">pragma mark - UI Actions</div><div class="line">pragma mark - Business Logic</div><div class="line">pragma mark - UITableViewDataSource</div><div class="line">pragma mark - UITableViewDelegate</div><div class="line">pragma mark - UIScrollViewDelegate</div><div class="line">pragma mark - Notification Handle</div><div class="line">pragma mark - <span class="keyword">Private</span> <span class="function"><span class="keyword">Method</span></span></div></pre></td></tr></table></figure>

<h2 id="宏、枚举、常量的声明">宏、枚举、常量的声明</h2>
<p>宏的命名方式参考变量的命名方式，大写，用下划线分开</p>
<figure class="highlight TARGET_OS_IPHONE```"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">枚举也有很多写法，这里推荐系统的方式</div></pre></td></tr></table></figure>

<p>typedef NS_ENUM(NSInteger, NSTextAlignment)<br>{<br>    NSTextAlignmentLeft      = 0,    // Visually left aligned<br>    NSTextAlignmentRight     = 1,    // Visually right aligned<br>    NSTextAlignmentCenter    = 2,    // Visually centered<br>    NSTextAlignmentJustified = 3,    // Fully-justified. The last line in a paragraph is natural-aligned.<br>    NSTextAlignmentNatural   = 4,    // Indicates the default alignment for script<br>} </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">常量以k开头，系统命名风格</div></pre></td></tr></table></figure>

<p>extern NSString <em>const kAPNetworkDidSetupNotification;     // 建立连接<br>extern NSString </em>const kAPNetworkDidCloseNotification;     // 关闭连接<br>extern NSString <em>const kAPNetworkDidRegisterNotification;  // 注册成功<br>extern NSString </em>const kAPNetworkDidLoginNotification;     // 登录成功</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如果是数值常量，用宏的话，也可以用k开头</div></pre></td></tr></table></figure>

<h1 id="define_kDistancePoint_10-0f_//_圆点、标志和正文的间距">define kDistancePoint  10.0f   // 圆点、标志和正文的间距</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">## 函数的粒度</span></div><div class="line">知道我们现在最长的函数有多少行吗？<span class="number">655</span>行。</div></pre></td></tr></table></figure>

<ul>
<li>(void)getShopDetail</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">一个函数最好不超过一屏（50行），千万不能超过两屏（100行）。</div><div class="line">因为从设计的角度来说，一个函数只需要干一件事，所以50行一般是够的，超长的函数往往干了很多事情，或者干了一件很大的事（拆成多件小事，交给子函数去干）。</div><div class="line"></div><div class="line"><span class="comment">## 其它</span></div><div class="line"></div><div class="line">- <span class="keyword">*</span><span class="keyword">*</span>Log<span class="keyword">*</span><span class="keyword">*</span>：不要使用NSLog，提交了会因想到别人，而且最后打包删起来麻烦。需要找一个Log工具，MyNSLog功能不够。</div><div class="line">- <span class="keyword">*</span><span class="keyword">*</span>代码中尽量不要出现数字<span class="keyword">*</span><span class="keyword">*</span>：据上下文推测出来的，还是计算的出为好（现在界面里面很多地方确实要写死数字，适配iPhone6会很困难）</div></pre></td></tr></table></figure>

<p>_contentBkg = [[UIView alloc] initWithFrame:CGRectMake(0, 1 / [UIScreen mainScreen].scale, 320, 68 - 1)];</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">*</span><span class="keyword">*</span>避免复杂的表达式<span class="keyword">*</span><span class="keyword">*</span>：</div></pre></td></tr></table></figure>

<pre><code><span class="keyword">if</span> (tfPassword.<span class="keyword">text</span>!=nil &amp;&amp;
    ![tfPassword.<span class="keyword">text</span> isEqualToString:@<span class="string">""</span>] &amp;&amp;
    tfRequestNumber.<span class="keyword">text</span>!=nil &amp;&amp;
    ![tfRequestNumber.<span class="keyword">text</span> isEqualToString:@<span class="string">""</span>]
    )
{
;    
}
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">*</span><span class="keyword">*</span>一个变量不在多个函数中出现，不要作为类变量：<span class="keyword">*</span><span class="keyword">*</span></div></pre></td></tr></table></figure>

<p>MBProgressHUD* hudProgress;<br>int result;</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">*</span><span class="keyword">*</span>每个类的.h开头的地方要有注释，说明这个类是干嘛的<span class="keyword">*</span><span class="keyword">*</span></div><div class="line">-</div></pre></td></tr></table></figure>

<p>/**</p>
<ul>
<li>SDImageCache maintains a memory cache and an optional disk cache. Disk cache write operations are performed</li>
<li>asynchronous so it doesn’t add unnecessary latency to the UI.<br>*/<br>@interface SDImageCache : NSObject</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">*</span><span class="keyword">*</span>if后面的语句哪怕只有一行，都加括号<span class="keyword">*</span><span class="keyword">*</span></div></pre></td></tr></table></figure>

<p>if ([key rangeOfString:@”热”].location != NSNotFound)<br>{<br>    titleLabel.text = @”热门城市”;<br>}<br>else<br>{<br>    titleLabel.text = key;<br>}</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="preprocessor"># 代码的风格</span></div><div class="line"></div><div class="line">风格如同习俗，不同地区有不同的习俗。你觉得入乡随俗好，就入乡随俗，这样避免了一些无谓的麻烦；但是你若坚持原有的习俗，社会也是能接受的，毕竟这些东西都是发展变化的，没有固定的模式，只有更好的模式。</div><div class="line"></div><div class="line"><span class="preprocessor">## 接口</span></div><div class="line">这里的接口指的是一个类公开的一组方法，良好设计的类是高内聚低耦合的，所以接口必须是简洁的。</div></pre></td></tr></table></figure>

<p>@interface PaySucceedViewController : LCBaseViewController</p>
<p>@property (nonatomic,retain) NSString *isSuccess;</p>
<p>@property (nonatomic,retain) NSString *shopName;</p>
<p>@property (nonatomic,retain) NSString *detailinfo;</p>
<p>@property (nonatomic,retain) NSString *amount;</p>
<p>@property (nonatomic,retain) NSString *omsOrderId;</p>
<p>/*</p>
<ul>
<li>支付订单类型<br>*</li>
<li>@since<br>*/<br>@property (nonatomic) ORDER_CATEGORY mCategory;</li>
</ul>
<p>@end<br>```<br>上面的例子是一个ViewController，但是它暴露了太多属性，属性很零碎，传值的时候要一个一个传。其实这里属性应该属于一个叫订单Model的对象，把这些属性封装在OrderModel中，复用性和可维护性都会好很多。（但是现在代码整体结构没有Model层，这里需要很大的重构）</p>
<h2 id="继承">继承</h2>
<p>继承不是为了少写代码，它的目的是抽象，顺便少写了代码。<br>举NavigationBar的例子，用宏可以实现，用基类也可以实现，但基类抽象出了一个共有的接口，以后发生共性的变化够可以通过修改基类来实现，你可以在基类里加一组方法，而宏做不到。</p>
<h2 id="其它">其它</h2>
<p>代码规范的路还长着，先走出第一步吧！</p>
<h1 id="参考资料">参考资料</h1>
<p><a href="./CodingGuidelines.pdf">Apple代码规范</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="为什么要有代码规范？">为什么要有代码规范？</h1>
<p>对于团队，如果代码风格不统一，阅读或修改同事的代码会非常困难，造成潜在的风险。</p>
<p>对于个人，代码规范是对自身编码习惯的一种监督，如果没有这种监督，有时候因为偷懒，会写出难看的代码，时间长了自己都看不懂。这样对于代码的维护性是不利的。</p>
<h1 id="代码规范的内容？">代码规范的内容？</h1>
<p>代码规范包含的范围十分广泛。从一个变量的命名到一个类的设计，我觉得都属于代码规范的范畴。从实践的角度，可以把代码规范分成两个部分：</p>
<p>第一部分是规则，即一定要这么做。这里面没有对错，但需要统一。包含变量的命名、函数的命名、模块的组织、代码块的组织、宏、枚举、常量的声明、函数的粒度。</p>
<p>第二部分是风格，即一种模式化的代码设计结构。我们实现某个功能时，往往不止一种实现方式。每一种实现方式没有绝对的高低之分，不同角度的解读，就会有不同的偏好。所以这个层面上的代码规范，只能求同存异。但是不管怎样，每个人必须要有一致性的风格。就像不同的小区可以有不同的风格，但同一个小区只能有一种设计风格。风格包含代码设计中的抽象概念，比如接口、继承等等。<br>]]>
    
    </summary>
    
      <category term="规范" scheme="http://linkageios.github.io/tags/%E8%A7%84%E8%8C%83/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[测试Json效率和XML效率]]></title>
    <link href="http://linkageios.github.io/2014/11/07/%E6%B5%8B%E8%AF%95Json%E6%95%88%E7%8E%87%E5%92%8CXML%E6%95%88%E7%8E%87/"/>
    <id>http://linkageios.github.io/2014/11/07/测试Json效率和XML效率/</id>
    <published>2014-11-07T05:38:14.000Z</published>
    <updated>2014-11-18T10:27:06.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li><p>tips：把项目中的解析json的sbjson ,网上提到的JsonKit和apple提供的自带json解析方法进行比较<br>所解析的json是来自项目当中服务返回的商家列表信息<br>具体如下图</p>
<a id="more"></a>
</li>
<li><p>tips：把项目中的解析json的sbjson ,网上提到的JsonKit和apple提供的自带json解析方法进行比较<br>所解析的json是来自项目当中服务返回的商家列表信息<br>具体如下图<br><img src="../images/79888-1946ee461177aeca.png" alt="imag"><br>开始先去 请求 商家列表信息 ，请求成功之后 会有弹出框提示</p>
<a id="more"></a></li>
<li>tips：把项目中的解析json的sbjson ,网上提到的JsonKit和apple提供的自带json解析方法进行比较<br>所解析的json是来自项目当中服务返回的商家列表信息<br>具体如下图<br><img src="../images/79888-1946ee461177aeca.png" alt="imag"><br>开始先去 请求 商家列表信息 ，请求成功之后 会有弹出框提示</li>
</ul>
<p><img src="../images/79888-bd0e36d1d14085ea.png" alt="imag"><br>之后可以依次测试三种解析，具体看demo提示<br>结果：JSONKit 效率最接近苹果原生</p>
<ul>
<li>tips：针对项目中的车型xml文件，对比XMLDictionary和苹果自带xml解析的效率<br>解析的对象就是 项目当中的车型库文件</li>
</ul>
<p><img src="../images/79888-e567a1bfada45c8c.png" alt="imag"><br>每个解析方法 解析1000次 具体实现看demo<br>结果：XMLDictionary因为是 宽泛适应的解析 比demo中的针对特定文件写的解析是要慢些，但是今后将取消xml读取文件，这个也就没什么需要考虑的了</p>
]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><p>tips：把项目中的解析json的sbjson ,网上提到的JsonKit和apple提供的自带json解析方法进行比较<br>所解析的json是来自项目当中服务返回的商家列表信息<br>具体如下图</p>
<!--more-->
</li>
<li><p>tips：把项目中的解析json的sbjson ,网上提到的JsonKit和apple提供的自带json解析方法进行比较<br>所解析的json是来自项目当中服务返回的商家列表信息<br>具体如下图<br><img src="../images/79888-1946ee461177aeca.png" alt="imag"><br>开始先去 请求 商家列表信息 ，请求成功之后 会有弹出框提示</p>
]]>
    
    </summary>
    
      <category term="xml" scheme="http://linkageios.github.io/tags/xml/"/>
    
      <category term="json" scheme="http://linkageios.github.io/tags/json/"/>
    
      <category term="效率" scheme="http://linkageios.github.io/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于iConsole在项目中的应用]]></title>
    <link href="http://linkageios.github.io/2014/11/07/%E5%85%B3%E4%BA%8EiConsole%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://linkageios.github.io/2014/11/07/关于iConsole在项目中的应用/</id>
    <published>2014-11-07T05:38:14.000Z</published>
    <updated>2014-11-18T10:28:05.000Z</updated>
    <content type="html"><![CDATA[<p>tips：方便程序没有连着Xcode跑时定位bug(目前觉得没什么好写的就是)</p>
<ul>
<li>安装</li>
</ul>
<p><img src="../images/79888-d9f0841d3cfac40e.png" alt="imag"></p>
<p>下载iconsole代码，将其中这两个文件拖入现有代码中</p>
<ul>
<li>配置<br>添加头文件</li>
</ul>
<figure class="highlight #import"><figcaption><span>"iConsole.h"```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在使用其功能之前有一点要注意,需要将AppDelegate里初始的<span class="built_in">UIWindow</span>需要以iConsoleWindow来初始化,并添加</div></pre></td></tr></table></figure>

<p>iConsoleDelegate</p>
<figure class="highlight 协议"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在</div></pre></td></tr></table></figure>

<p>AppDelegate.h</p>
<figure class="highlight 中"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="xml"><span class="comment">&lt;!--more--&gt;</span></span></div><div class="line">tips：方便程序没有连着Xcode跑时定位bug(目前觉得没什么好写的就是)</div><div class="line"><span class="bullet">- </span>安装</div><div class="line"></div><div class="line">![<span class="link_label">imag</span>](<span class="link_url">../images/79888-d9f0841d3cfac40e.png</span>)</div><div class="line"></div><div class="line">下载iconsole代码，将其中这两个文件拖入现有代码中</div><div class="line"><span class="bullet">- </span>配置</div><div class="line">添加头文件</div></pre></td></tr></table></figure>

<h1 id="import_“iConsole-h”">import “iConsole.h”</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在使用其功能之前有一点要注意,需要将AppDelegate里初始的<span class="built_in">UIWindow</span>需要以iConsoleWindow来初始化,并添加</div></pre></td></tr></table></figure>

<p>iConsoleDelegate</p>
<figure class="highlight 协议"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在</div></pre></td></tr></table></figure>

<p>AppDelegate.h</p>
<figure class="highlight 中"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) iConsoleWindow *window;</div></pre></td></tr></table></figure>

<p>在</p>
<figure class="highlight AppDelegate.m```的```didFinishLaunchingWithOptions"><figcaption><span>```方法中添加</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="variable">_window =</span> [[iConsoleWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];</div><div class="line"><span class="comment">/*</span></div><div class="line">*  iconsole</div><div class="line">*/</div><div class="line">[iConsole sharedConsole].<span class="variable">delegate =</span> self;</div><div class="line">[iConsole sharedConsole].<span class="variable">logSubmissionEmail =</span> @<span class="string">"xxx@126.com"</span>;</div></pre></td></tr></table></figure>

<p>添加协议方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">*iconsole</div><div class="line">*@param command</div><div class="line">*/</div><div class="line">- (<span class="keyword">void</span>)handleConsoleCommand:(<span class="built_in">NSString</span> *)command</div><div class="line">{</div><div class="line"><span class="keyword">if</span> ([command isEqualToString:<span class="string">@"version"</span>])</div><div class="line">{</div><div class="line">[iConsole info:<span class="string">@"%@ version %@"</span>,</div><div class="line">[[<span class="built_in">NSBundle</span> mainBundle] objectForInfoDictionaryKey:<span class="string">@"CFBundleName"</span>],</div><div class="line">[[<span class="built_in">NSBundle</span> mainBundle] objectForInfoDictionaryKey:<span class="string">@"CFBundleVersion"</span>]];</div><div class="line">}</div><div class="line"><span class="keyword">else</span></div><div class="line">{</div><div class="line">[iConsole error:<span class="string">@"unrecognised command, try 'version' instead"</span>];</div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>iConsole提供了4种记录日程的方式,分别是:<br>1:信息         </p>
<figure class="highlight [iConsole"><figcaption><span>info:@"记录一条普通级"];```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2:警告</div></pre></td></tr></table></figure>

<p>[iConsole warn:@”记录一条警告级”];</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3:错误</div></pre></td></tr></table></figure>

<p>[iConsole error:@”记录一条错误级”];</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4:崩溃</div></pre></td></tr></table></figure>

<p>[iConsole crash:@”记录一条崩溃级”];</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">iConsole</span> 默认记录的日志条数是<span class="number">1000</span>条. 如果日志记录到上限时,会删除最早的一条,如此循环,可通过如下属性设置上下限:</div></pre></td></tr></table></figure>

<p>[[iConsole sharedConsole] setMaxLogItems:2000];  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当我们需要查看iConsole的控制台时,可以通过三种方式来启动控制台:</div><div class="line">1:主动调用</div></pre></td></tr></table></figure>

<p>[iConsole show];  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2:三跟手指由下往上滑动. 模拟器两根手指,  默认启动</div></pre></td></tr></table></figure>

<p>[iConsole sharedConsole].simulatorTouchesToShow = YES;<br>[iConsole sharedConsole].deviceTouchesToShow = YES;  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3:摇动手机启动  默认禁用</div></pre></td></tr></table></figure>

<p>[iConsole sharedConsole].deviceShakeToShow = YES; ``` </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>tips：方便程序没有连着Xcode跑时定位bug(目前觉得没什么好写的就是)</p>
<ul>
<li>安装</li>
</ul>
<p><img src="../images/79888-d9f0841d3cfac40e.png" alt="imag"></p>
<p>]]>
    </summary>
    
      <category term="iconsole" scheme="http://linkageios.github.io/tags/iconsole/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LCDataManager相关说明]]></title>
    <link href="http://linkageios.github.io/2014/11/07/LCDataManager%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"/>
    <id>http://linkageios.github.io/2014/11/07/LCDataManager相关说明/</id>
    <published>2014-11-07T05:38:14.000Z</published>
    <updated>2014-11-18T10:35:55.000Z</updated>
    <content type="html"><![CDATA[<h6 id="#_文章参照cucuz的数据存储Library"># 文章参照cucuz的数据存储Library</h6>
<p><strong>类 的目的</strong></p>
<p>方便项目当中数据的存储，提供简单的接口供使用,根据存储的位置划分可以分为缓存和本地存储，<br>其中包括</p>
<pre><code><span class="built_in">NSArray</span>, <span class="built_in">NSDictionary</span>, NSData,<span class="built_in">NSString</span>,<span class="built_in">UIImage</span> 等常用数据类型，自定义Object(自行实现NSCoding协议)
</code></pre><p><strong>类的函数介绍</strong></p>
<ul>
<li>类初始化(单例)</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">LCDataManager *dataManager </span>=<span class="string"> [LCDataManager shareManager];</span></div></pre></td></tr></table></figure>

<p>首先，我们创建一个对象，下文将以它作为存储的一个依据</p>
<h2 id="Cache_block">Cache block</h2>
<p><a id="more"></a></p>
<h6 id="#_文章参照cucuz的数据存储Library-1"># 文章参照cucuz的数据存储Library</h6>
<p><strong>类 的目的</strong></p>
<p>方便项目当中数据的存储，提供简单的接口供使用,根据存储的位置划分可以分为缓存和本地存储，<br>其中包括</p>
<pre><code><span class="built_in">NSArray</span>, <span class="built_in">NSDictionary</span>, NSData,<span class="built_in">NSString</span>,<span class="built_in">UIImage</span> 等常用数据类型，自定义Object(自行实现NSCoding协议)
</code></pre><p><strong>类的函数介绍</strong></p>
<ul>
<li>类初始化(单例)</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">LCDataManager *dataManager </span>=<span class="string"> [LCDataManager shareManager];</span></div></pre></td></tr></table></figure>

<p>首先，我们创建一个对象，下文将以它作为存储的一个依据</p>
<h2 id="Cache_block-1">Cache block</h2>
<ul>
<li>Cache的存储</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>putObject:<span class="params">(id)</span>object inKey:<span class="params">(<span class="variable">NSString</span> *)</span>key underType:<span class="params">(<span class="variable">LCCACHETYPE</span>)</span>type;</span></div></pre></td></tr></table></figure>

<p>函数用意是 把</p>
<figure class="highlight object```以关键字```key```存储到```type```类型下。其实，本身```dataManager"><figcaption><span>```中存在一个```MutbaleDictionary *cacheMutableDictionary``` ，它是以```LCCACHETYPE ```中的类别为关键字建立的字典，该存储函数中的```key```则是这个```cacheMutableDictionary ```中对应```type```下的关键字，简单说就是“字典中字典的关键字”。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="undefined">其中</span></div></pre></td></tr></table></figure>

<p>LCCACHETYPE</p>
<figure class="highlight 是提供的数据分类"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>

<p>typedef NS_ENUM(NSInteger, LCCACHETYPE)<br>{<br>LCCacheImage            =  0,<br>LCCacheData             =  1,<br>LCCacheFile             =  2,<br>LCCacheTmp              =  3,<br>LCCacheNeverRelease     =  4,<br>};</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

<p>putObject</p>
<figure class="highlight 用法"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>

<p>NSArray *CacheLists = @[@”老大”,@”老二”,@”老三”];<br>BOOL ret = [dataManager  putObject:CacheLists inKey:@”order” underType:LCCacheData];</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">其他类型以此类推</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="deletion">- Cache的获取</span></div></pre></td></tr></table></figure>

<ul>
<li>(id)getObjectForKey:(NSString *)key underType:(LCCACHETYPE)type;</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">这个就是上面存储函数对应的一个<span class="keyword">get</span>函数，他的参数和上面函数是一样的，不过多说明</div><div class="line"></div><div class="line">-</div></pre></td></tr></table></figure>

<p>getObjectForKey</p>
<figure class="highlight 用法"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="protobuf"><span class="constant">	NSArray *fetchCacheLists</span> = [dataManager getObjectForKey:@<span class="string">"order"</span>] 	underType: LCCacheData;</span></div><div class="line"></div><div class="line">其他类型以此类推</div><div class="line"></div><div class="line">- Cache的清除</div><div class="line"></div><div class="line">这里提供了<span class="number">3</span>个清除方法，是针对需要清除的模块的范围划分的:</div></pre></td></tr></table></figure>

<ul>
<li>(void)clearObjectForKey:(NSString *)key underType:(LCCACHETYPE)type;</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面这个方法是最细的一个清除，他是清除到类别下面的关键字对应的数据</div></pre></td></tr></table></figure>

<ul>
<li>(void)clearObjectsUnderType:(LCCACHETYPE)type;</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">上面这个方法清除的是一个类别下所有的关键字包含的数据</div></pre></td></tr></table></figure>

<ul>
<li>(void)clearAllCache;</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">上面这个方法顾名思义就是清空Cache</div><div class="line"><span class="deletion">- 清除用法</span></div></pre></td></tr></table></figure>

<p>[dataManager clearObjectForKey:@”order” underType: LCCacheData];<br>[dataManager clearObjectsUnderType: LCCacheData];<br>[dataManager clearAllCache];</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></div></pre></td></tr></table></figure>

<p>i’m 华 丽 的 分 割 线 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-<span class="ruby">----------------------------------------------------------------------------</span></div><div class="line">##disk block</div><div class="line">disk上的存储</div><div class="line">它包括了</div></pre></td></tr></table></figure>

<p>NSFileManager NSUserDefaults NSKeyedArchiver</p>
<figure class="highlight 对数据"><figcaption><span>的操作，目前除了对```UIImage```的存储位置放在```tmp```中，其他数据存储位置在```Library/Caches```中</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

<p>NSFileManager </p>
<figure class="highlight 上的操作"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

<p>NSFileManager </p>
<figure class="highlight 存数据"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>storeImage:<span class="params">(<span class="variable">UIImage</span> *)</span>image withFileName:<span class="params">(<span class="variable">NSString</span> *)</span>fileName;</span></div><div class="line">- <span class="params">(<span class="variable">BOOL</span>)</span>storeArray:<span class="params">(<span class="variable">NSArray</span> *)</span>array withFileName:<span class="params">(<span class="variable">NSString</span> *)</span>fileName;</div><div class="line">- <span class="params">(<span class="variable">BOOL</span>)</span>storeDictionary:<span class="params">(<span class="variable">NSDictionary</span> *)</span>dictionary withFileName:<span class="params">(<span class="variable">NSString</span> *)</span>fileName;</div><div class="line">- <span class="params">(<span class="variable">BOOL</span>)</span>storeData:<span class="params">(<span class="variable">NSData</span> *)</span>data withFileName:<span class="params">(<span class="variable">NSString</span> *)</span>fileName;</div></pre></td></tr></table></figure>

<p>它的用法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="constant">NSArray *diskLists</span> = @[@<span class="string">"disk_1"</span>,@<span class="string">"disk_2"</span>,@<span class="string">"disk_3"</span>];</div><div class="line"><span class="constant">BOOL ret</span> = [dataManager storeArray:diskLists withFileName:@<span class="string">"order"</span>];</div></pre></td></tr></table></figure>

<p>其他类型以此类推</p>
<ul>
<li><figure class="highlight NSFileManager"><figcaption><span>```取数据</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="code">```</span></div><div class="line"><span class="bullet">- </span>(UIImage <span class="emphasis">*)fetchImageNamedString:(NSString *</span>)name;</div><div class="line"><span class="bullet">- </span>(NSArray <span class="emphasis">*)fetchArrayNamedString:(NSString *</span>)name;</div><div class="line"><span class="bullet">- </span>(NSDictionary <span class="emphasis">*)fetchDictionaryNamedString:(NSString *</span>)name;</div><div class="line"><span class="bullet">- </span>(NSData <span class="emphasis">*)fetchDataNamedString:(NSString *</span>)name;</div></pre></td></tr></table></figure>

</li>
</ul>
<p>它的用法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="constant">NSArray *fetchDiskLists</span> = [dataManager fetchArrayNameString:@<span class="string">"order"</span>];</div></pre></td></tr></table></figure>

<p>其他类型以此类推</p>
<ul>
<li><figure class="highlight NSFileManager"><figcaption><span>```删数据</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>removeImageNamedString:<span class="params">(<span class="variable">NSString</span> *)</span>name;</span></div><div class="line">- <span class="params">(<span class="variable">BOOL</span>)</span>removeArrayNamedString:<span class="params">(<span class="variable">NSString</span> *)</span>name;</div><div class="line">- <span class="params">(<span class="variable">BOOL</span>)</span>removeDictionaryNamedString:<span class="params">(<span class="variable">NSString</span> *)</span>name;</div><div class="line">- <span class="params">(<span class="variable">BOOL</span>)</span>removeDataNamedString:<span class="params">(<span class="variable">NSString</span> *)</span>name;</div></pre></td></tr></table></figure>

</li>
</ul>
<p>它的用法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL <span class="keyword">ret</span> = [dataManager removeArrayNameStrin<span class="variable">g:</span>@<span class="string">"order"</span>];</div></pre></td></tr></table></figure>

<p>其他类型以此类推</p>
<ul>
<li><figure class="highlight NSFileManager"><figcaption><span>```清空</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">-<span class="ruby"> (<span class="constant">BOOL</span>)clearDiskUnderImages;</span></div><div class="line">-<span class="ruby"> (<span class="constant">BOOL</span>)clearDiskUnderDatas;</span></div><div class="line">-<span class="ruby"> (void)clearAllDataOnDisk;</span></div></pre></td></tr></table></figure>

</li>
</ul>
<p>它的用法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">BOOL ret </span>=<span class="string"> [dataManager clearDiskUnderDatas];</span></div></pre></td></tr></table></figure>

<p>其中</p>
<figure class="highlight clearDiskUnderDatas```是清除Data目录中所有数据；"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="escape">``</span><span class="escape">`c</span>learDiskUnderImages</div></pre></td></tr></table></figure>

<p>是清除Image目录中所有数据</p>
<figure class="highlight clearAllDataOnDisk```是清除Disk上所有数据"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

<p>NSFileManager </p>
<figure class="highlight 获取数据大小"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">-<span class="ruby"> (<span class="constant">NSString</span>*)imageOndiskSize;</span></div><div class="line">-<span class="ruby"> (<span class="constant">NSString</span>*)dataOndiskSize;</span></div><div class="line">-<span class="ruby"> (<span class="constant">NSString</span>*)tmpOndiskSize;</span></div></pre></td></tr></table></figure>

<ul>
<li><figure class="highlight NSUserDefaults"><figcaption><span>```上的操作</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

</li>
</ul>
<p>NSUserDefaults </p>
<figure class="highlight 存数据"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>storeValue:<span class="params">(id)</span>value keyValue:<span class="params">(<span class="variable">NSString</span>*)</span>key;</span></div></pre></td></tr></table></figure>

<ul>
<li><figure class="highlight NSUserDefaults"><figcaption><span>```取数据</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="pp">- <span class="params">(id)</span>fetchValueUnderKeyValue:<span class="params">(<span class="variable">NSString</span> *)</span>key;</span></div></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<figure class="highlight NSUserDefaults"><figcaption><span>```用法</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="constant">BOOL ret</span> = [dataManager storeValue:@<span class="string">"LinkAge"</span> keyValue:@<span class="string">"Co.,Ltd."</span>];</div><div class="line"><span class="constant">NSString *corp</span> = [dataManager fetchValueUnderKeyValue:@<span class="string">"Co.,Ltd."</span>];</div></pre></td></tr></table></figure>

<ul>
<li><figure class="highlight NSKeyedArchiver"><figcaption><span>```上的操作(对有序列化要求的数据提供存储方法)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

</li>
</ul>
<p>NSKeyedArchiver </p>
<figure class="highlight 存数据"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>storeObject:<span class="params">(id)</span>object withFileName:<span class="params">(<span class="variable">NSString</span> *)</span>fileName;</span></div></pre></td></tr></table></figure>

<ul>
<li><figure class="highlight NSKeyedArchiver"><figcaption><span>```取数据</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="pp">- <span class="params">(id)</span>fetchObjectNamedString:<span class="params">(<span class="variable">NSString</span> *)</span>name;</span></div></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<figure class="highlight NSKeyedArchiver"><figcaption><span>```删数据</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">放在</div></pre></td></tr></table></figure>

<p>NSFileManager </p>
<figure class="highlight 对Data操作一致"><figcaption><span>他们的存储目录一样</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

<p>NSKeyedArchiver </p>
<figure class="highlight 用法"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="built_in">NSDictionary</span> *dic ...{为后台返回回来的jsonDic}</div><div class="line"><span class="built_in">BOOL</span> ret = [dataManager storeObject:dic withFileName:<span class="string">@"washCarList"</span>];</div><div class="line"><span class="built_in">NSDictionary</span> *fetchDic = [dataManager fetchObjectNamedString:<span class="string">@"washCarList"</span>];</div></pre></td></tr></table></figure>

<p>其余自定义类需要调用函数的 完成NSCoding协议后在调用</p>
]]></content>
    <summary type="html">
    <![CDATA[<h6 id="#_文章参照cucuz的数据存储Library"># 文章参照cucuz的数据存储Library</h6>
<p><strong>类 的目的</strong></p>
<p>方便项目当中数据的存储，提供简单的接口供使用,根据存储的位置划分可以分为缓存和本地存储，<br>其中包括</p>
<pre><code><span class="built_in">NSArray</span>, <span class="built_in">NSDictionary</span>, NSData,<span class="built_in">NSString</span>,<span class="built_in">UIImage</span> 等常用数据类型，自定义Object(自行实现NSCoding协议)
</code></pre><p><strong>类的函数介绍</strong></p>
<ul>
<li>类初始化(单例)</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">LCDataManager *dataManager </span>=<span class="string"> [LCDataManager shareManager];</span></div></pre></td></tr></table></figure>

<p>首先，我们创建一个对象，下文将以它作为存储的一个依据</p>
<h2 id="Cache_block">Cache block</h2>
<p>]]>
    
    </summary>
    
      <category term="LCDataManager" scheme="http://linkageios.github.io/tags/LCDataManager/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[地图开发总结]]></title>
    <link href="http://linkageios.github.io/2014/11/07/%E5%9C%B0%E5%9B%BE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>http://linkageios.github.io/2014/11/07/地图开发总结/</id>
    <published>2014-11-07T04:18:00.000Z</published>
    <updated>2014-11-18T10:27:25.000Z</updated>
    <content type="html"><![CDATA[<h3 id="坑爹的高德">坑爹的高德</h3>
<p>项目中地图原来用的高德sdk，其实我不知道当时为什么就用了高德，但既然用了，那么就在此基础上开发吧。可是写着写着，问题就来了： <a href="http://bbs.amap.com/thread-42153-1-1.html" target="_blank" rel="external">问题链接</a>。虽然这个问题不是什么太大的问题，但保不准以后还会遇到什么别的坑，而且以高德的效率，短期内肯定不会解决的。<br>那为什么还要用那个sdk呢？好像我们用到的功能苹果自带的MapKit都能实现啊，而且高德官网上的合作伙伴（携程、美团）也是用的原生的MapKit（从地图默认加载背景就可以看出来）。后来只花了一点点时间就切换到苹果的MapKit（API是一样的），目前还没发现什么bug。</p>
<h3 id="坐标转换之中国特色">坐标转换之中国特色</h3>
<p>因为不用高德了，所以当前位置经纬度就用CoreLocation来获取。可是当你把获取的经纬度放到MKMapView中显示，位置竟然有偏移，而且还不小。</p>
<p>这是苹果的bug吗？不是，是有关部门的功劳。我们只有一个地球，所以地球上每个点的经纬度是固定的，国际上有个通用标准，简称国际标准。CoreLocation取到的经纬度符合国际标准。</p>
<p>可是在国内，由于国家安全，有关部门制定了一套新的标准，简称国家标准。只要是在国内发行的地图（包括电子地图），都要按国家标准来，不然就是非法的。所以苹果手机中的国内地图肯定也是改良过的。</p>
<p>我拿着国际标准的经纬度放到改良过的符合国家标准的地图中，显然会发生偏移。</p>
<p>解决办法就是将国际标准的经纬度转换成国家标准的经纬度。<a href="https://gist.github.com/mithvv/5476132" target="_blank" rel="external">算法是现成的</a>（以前用高德sdk获取当前位置的经纬度本来就是国家标准的，所以没事。）<br><a id="more"></a></p>
<h3 id="坑爹的高德-1">坑爹的高德</h3>
<p>项目中地图原来用的高德sdk，其实我不知道当时为什么就用了高德，但既然用了，那么就在此基础上开发吧。可是写着写着，问题就来了： <a href="http://bbs.amap.com/thread-42153-1-1.html" target="_blank" rel="external">问题链接</a>。虽然这个问题不是什么太大的问题，但保不准以后还会遇到什么别的坑，而且以高德的效率，短期内肯定不会解决的。<br>那为什么还要用那个sdk呢？好像我们用到的功能苹果自带的MapKit都能实现啊，而且高德官网上的合作伙伴（携程、美团）也是用的原生的MapKit（从地图默认加载背景就可以看出来）。后来只花了一点点时间就切换到苹果的MapKit（API是一样的），目前还没发现什么bug。</p>
<h3 id="坐标转换之中国特色-1">坐标转换之中国特色</h3>
<p>因为不用高德了，所以当前位置经纬度就用CoreLocation来获取。可是当你把获取的经纬度放到MKMapView中显示，位置竟然有偏移，而且还不小。</p>
<p>这是苹果的bug吗？不是，是有关部门的功劳。我们只有一个地球，所以地球上每个点的经纬度是固定的，国际上有个通用标准，简称国际标准。CoreLocation取到的经纬度符合国际标准。</p>
<p>可是在国内，由于国家安全，有关部门制定了一套新的标准，简称国家标准。只要是在国内发行的地图（包括电子地图），都要按国家标准来，不然就是非法的。所以苹果手机中的国内地图肯定也是改良过的。</p>
<p>我拿着国际标准的经纬度放到改良过的符合国家标准的地图中，显然会发生偏移。</p>
<p>解决办法就是将国际标准的经纬度转换成国家标准的经纬度。<a href="https://gist.github.com/mithvv/5476132" target="_blank" rel="external">算法是现成的</a>（以前用高德sdk获取当前位置的经纬度本来就是国家标准的，所以没事。）</p>
<h3 id="怎么使用MapKit">怎么使用MapKit</h3>
<p>用苹果官方的framework最幸福了，因为有标准的文档可查，只要看就是了。目前我们对地图的使用非常简单，就是在地图上加地理位置标注，所以我要看的只有其中<a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/LocationAwarenessPG/AnnotatingMaps/AnnotatingMaps.html#//apple_ref/doc/uid/TP40009497-CH6-SW1" target="_blank" rel="external">一小段</a>。</p>
<p>要实现标注，必须要有以下3个对象：</p>
<ul>
<li>AnnotationObject(标注对象)</li>
<li>AnnotationView(标注视图)</li>
<li>AnnotationCalloutView(标注弹出视图，可看做是标注视图的一部分)</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/16632-ebb438364bb22eb8.png" alt="annotation.png" width="200px"></p>
<p>结合上面的图，AnnotationObject是标注的模型对象，AnnotationView就是大头针，AnnotationCallView就是弹出来的浮层。</p>
<h6 id="AnnotationObject">AnnotationObject</h6>
<p>AnnotationObject必须实现MKAnnotation协议：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MKAnnotation</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Center latitude and longitude of the annotation view.</span></div><div class="line"><span class="comment">// The implementation of this property must be KVO compliant.</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) CLLocationCoordinate2D coordinate;</div><div class="line"></div><div class="line"><span class="keyword">@optional</span></div><div class="line"></div><div class="line"><span class="comment">// Title and subtitle for use by selection UI.</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *title;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *subtitle;</div><div class="line"></div><div class="line"><span class="comment">// Called as a result of dragging an annotation view.</span></div><div class="line">- (<span class="keyword">void</span>)setCoordinate:(CLLocationCoordinate2D)newCoordinate NS_AVAILABLE(<span class="number">10</span>_9, <span class="number">4</span>_0);</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>框架默认提供了一个MKPointAnnotation，只有coordinate、title、subtitle，如果要求不高，这个类也够用了。但更多的情况就需要我们自定义MKAnnotation。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HJGasStationAnnotation</span> : <span class="title">NSObject</span>&lt;<span class="title">MKAnnotation</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">//经纬度</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) CLLocationCoordinate2D coordinate;</div><div class="line"><span class="comment">//标题</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>* title;</div><div class="line"><span class="comment">//地址</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>* address;</div><div class="line"><span class="comment">//电话</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>* tel;</div><div class="line"></div><div class="line">- (instancetype)initWithLocation:(CLLocationCoordinate2D)coordinate;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>里面的title、address、tel都是我随便加的，只要有需求，加任何东西都可以，但官方文档中也说了，AnnotationObject不能太大，不然地图上标注一多，效率会有问题。</p>
<p>想一下，为什么要有AnnotationObject这个对象？我看到之前的代码没么有自定义什么AnnotationObject，所有的标注都用MKPointAnnotation，然后所有其他的属性都封装成另外一个对象（ObjectB，这个ObjectB也是从项目的其他地方拿来的）都放到AnnotationView去。</p>
<p>这样造成的后果就是AnnotationView中既有AnnotationObject，又有ObjectB（而且ObjectB不够纯粹，有很多冗余的属性），导致AnnotationView代码耦合性较大。而子类话AnnotationObject，就能消除这种耦合，把ObjectB中有用的属性封装到SubAnnotationObject中即可，这样对于AnnotationView而言，只需要知道AnnotationObject，管它什么ObjectB呢！</p>
<h6 id="AnnotationView">AnnotationView</h6>
<p>框架提供了默认的MKPinAnnotationView，就是一个大头针。因为不够美观，我们可能要换成其它图片或者自定义视图。</p>
<p>怎么自定义呢？只要继承一下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HJGasStationAnnotationView</span> : <span class="title">MKAnnotationView</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) HJGasStationCalloutView *calloutView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HJGasStationAnnotationView</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithAnnotation:(<span class="keyword">id</span>&lt;MKAnnotation&gt;)annotation reuseIdentifier:(<span class="built_in">NSString</span> *)reuseIdentifier</div><div class="line">{</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithAnnotation:annotation reuseIdentifier:reuseIdentifier];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)</div><div class="line">    {</div><div class="line">        <span class="keyword">self</span><span class="variable">.bounds</span> = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">23</span>, <span class="number">35</span>);</div><div class="line">        <span class="keyword">self</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];</div><div class="line">        <span class="keyword">self</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"map_location.png"</span>];</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>上面的自定义非常简单，只是换了张图片，如果有更复杂的需求，直接在里面加子控件或者重写drewRect都可。</p>
<h6 id="AnnotationCalloutView">AnnotationCalloutView</h6>
<p>框架里有标准的AnnotationCalloutView，只需要设置AnnotationView的属性canShowCallout为YES，就能展示默认的CalloutView；如果需要自定义CalloutView的话就必须将canShowCallout设为NO，这样就不会弹出默认的CalloutView。</p>
<p>自定义的CalloutView就是一个普通的View，爱怎么写就怎么写。它展示和消失的逻辑是由AnnotationView来控制的，所以说CalloutView其实是AnnotationView的一部分。</p>
<p>交互的逻辑就是重写两个方法，而且必须要重写，变量名根据实际情况会变，但方法逻辑结构就不需要动。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(UIEvent *)event</div><div class="line">{</div><div class="line">    <span class="built_in">BOOL</span> inside = [<span class="keyword">super</span> pointInside:point withEvent:event];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!inside && <span class="keyword">self</span><span class="variable">.selected</span>)</div><div class="line">    {</div><div class="line">        inside = [<span class="keyword">self</span><span class="variable">.calloutView</span> pointInside:[<span class="keyword">self</span> convertPoint:point toView:<span class="keyword">self</span><span class="variable">.calloutView</span>] withEvent:event];</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> inside;</div><div class="line">}</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setSelected:(<span class="built_in">BOOL</span>)selected</div><div class="line">{</div><div class="line">    [<span class="keyword">super</span> setSelected:selected];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(selected)</div><div class="line">    {</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.calloutView</span> == <span class="literal">nil</span>) {</div><div class="line">            <span class="keyword">self</span><span class="variable">.calloutView</span> = [[HJGasStationCalloutView alloc] initWithFrame:CGRectMake(<span class="number">0</span>, <span class="number">0</span>, kCalloutWidth, kCalloutHeight)];</div><div class="line">            [<span class="keyword">self</span><span class="variable">.calloutView</span><span class="variable">.telButton</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(telButtonPressed:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">            [<span class="keyword">self</span><span class="variable">.calloutView</span><span class="variable">.navButton</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(navButtonPressed:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">            <span class="keyword">self</span><span class="variable">.calloutView</span><span class="variable">.center</span> = CGPointMake(CGRectGetWidth(<span class="keyword">self</span><span class="variable">.bounds</span>) / <span class="number">2.</span>f + <span class="keyword">self</span><span class="variable">.calloutOffset</span><span class="variable">.x</span>,(-CGRectGetHeight(<span class="keyword">self</span><span class="variable">.calloutView</span><span class="variable">.bounds</span>) / <span class="number">2.</span>f + <span class="keyword">self</span><span class="variable">.calloutOffset</span><span class="variable">.y</span>));</div><div class="line">        }</div><div class="line">        [<span class="keyword">self</span> bindDataToUI];</div><div class="line">        [<span class="keyword">self</span> addSubview:<span class="keyword">self</span><span class="variable">.calloutView</span>];</div><div class="line">    }</div><div class="line">    <span class="keyword">else</span></div><div class="line">    {</div><div class="line">        [<span class="keyword">self</span><span class="variable">.calloutView</span> removeFromSuperview];</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="展现逻辑">展现逻辑</h3>
<p>像MapView添加标注</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.mapView <span class="symbol">addAnnotation:</span><span class="keyword">self</span>.annotation];</div></pre></td></tr></table></figure>

<p> 在MapView的代理方法中生成AnnotationView</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (MKAnnotationView *)mapView:(<span class="built_in">MKMapView</span> *)mapView viewForAnnotation:(<span class="keyword">id</span>&lt;MKAnnotation&gt;)annotation</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> ([annotation isKindOfClass:[HJGasStationAnnotation class]]) {</div><div class="line">        </div><div class="line">        <span class="keyword">static</span> <span class="built_in">NSString</span> *customReuseIndetifier = <span class="string">@"HJGasStationAnnotation"</span>;</div><div class="line">        HJGasStationAnnotationView *annotationView = (HJGasStationAnnotationView*)[mapView dequeueReusableAnnotationViewWithIdentifier:customReuseIndetifier];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (annotationView == <span class="literal">nil</span>)</div><div class="line">        {</div><div class="line">            annotationView = [[HJGasStationAnnotationView alloc] initWithAnnotation:annotation reuseIdentifier:customReuseIndetifier];</div><div class="line">            annotationView<span class="variable">.canShowCallout</span> = <span class="literal">NO</span>;</div><div class="line">            annotationView<span class="variable">.draggable</span> = <span class="literal">NO</span>;</div><div class="line">            annotationView<span class="variable">.calloutOffset</span> = CGPointMake(<span class="number">0</span>, -<span class="number">5</span>);</div><div class="line">            annotationView<span class="variable">.selected</span> = <span class="literal">YES</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span> {</div><div class="line">            annotationView<span class="variable">.annotation</span> = annotation;</div><div class="line">        }</div><div class="line">        </div><div class="line">        [annotationView bindDataToUI];</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> annotationView;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h3 id="坑爹的高德">坑爹的高德</h3>
<p>项目中地图原来用的高德sdk，其实我不知道当时为什么就用了高德，但既然用了，那么就在此基础上开发吧。可是写着写着，问题就来了： <a href="http://bbs.amap.com/thread-42153-1-1.html" target="_blank" rel="external">问题链接</a>。虽然这个问题不是什么太大的问题，但保不准以后还会遇到什么别的坑，而且以高德的效率，短期内肯定不会解决的。<br>那为什么还要用那个sdk呢？好像我们用到的功能苹果自带的MapKit都能实现啊，而且高德官网上的合作伙伴（携程、美团）也是用的原生的MapKit（从地图默认加载背景就可以看出来）。后来只花了一点点时间就切换到苹果的MapKit（API是一样的），目前还没发现什么bug。</p>
<h3 id="坐标转换之中国特色">坐标转换之中国特色</h3>
<p>因为不用高德了，所以当前位置经纬度就用CoreLocation来获取。可是当你把获取的经纬度放到MKMapView中显示，位置竟然有偏移，而且还不小。</p>
<p>这是苹果的bug吗？不是，是有关部门的功劳。我们只有一个地球，所以地球上每个点的经纬度是固定的，国际上有个通用标准，简称国际标准。CoreLocation取到的经纬度符合国际标准。</p>
<p>可是在国内，由于国家安全，有关部门制定了一套新的标准，简称国家标准。只要是在国内发行的地图（包括电子地图），都要按国家标准来，不然就是非法的。所以苹果手机中的国内地图肯定也是改良过的。</p>
<p>我拿着国际标准的经纬度放到改良过的符合国家标准的地图中，显然会发生偏移。</p>
<p>解决办法就是将国际标准的经纬度转换成国家标准的经纬度。<a href="https://gist.github.com/mithvv/5476132" target="_blank" rel="external">算法是现成的</a>（以前用高德sdk获取当前位置的经纬度本来就是国家标准的，所以没事。）<br>]]>
    
    </summary>
    
      <category term="地图" scheme="http://linkageios.github.io/tags/%E5%9C%B0%E5%9B%BE/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[POP框架初探]]></title>
    <link href="http://linkageios.github.io/2014/11/06/POP%E6%A1%86%E6%9E%B6%E5%88%9D%E6%8E%A2/"/>
    <id>http://linkageios.github.io/2014/11/06/POP框架初探/</id>
    <published>2014-11-06T10:05:14.000Z</published>
    <updated>2014-11-18T09:10:14.000Z</updated>
    <content type="html"><![CDATA[<p>合适的动画效果是提高用户体验最直观的方式，我们项目中的动画应用也不少，主要是使用的UIKit的动画扩展，还有少量用CoreAnimation实现。现在Facebook开源了POP，我们又多了一种强大好用的选择。与CoreAnimation相比，api用法相似，POP提供了更多方便生动的动画效果，主要是弹簧（SpringAnimation）和衰减（DecayAnimation）效果。</p>
<h1 id="使用方法">使用方法</h1>
<p>POP的使用跟CoreAnimation比较相似，基本的步骤如下：</p>
<ul>
<li>选择一种动画效果<br>1.POPBasicAnimation 基本的动画效果，我们常用的EaseInOut、Linenear的动画效果都可以用这种方式实现</li>
</ul>
<p>2.POPSpringAnimation 弹簧效果，如下图</p>
<p><img src="../images/pop.gif" alt="pop.gif"></p>
<pre><code>
POPSpringAnimation *springAnimation = [POPSpringAnimation animation];
springAnimation.springBounciness=14;    // 弹簧弹力 取值范围为[0, 20]，默认值为4
springAnimation.springSpeed=3;     // 弹簧速度，速度越快，动画时间越短 [0, 20]，默认为12，和springBounciness一起决定着弹簧动画的效果

<a id="more"></a>



合适的动画效果是提高用户体验最直观的方式，我们项目中的动画应用也不少，主要是使用的UIKit的动画扩展，还有少量用CoreAnimation实现。现在Facebook开源了POP，我们又多了一种强大好用的选择。与CoreAnimation相比，api用法相似，POP提供了更多方便生动的动画效果，主要是弹簧（SpringAnimation）和衰减（DecayAnimation）效果。
# 使用方法
POP的使用跟CoreAnimation比较相似，基本的步骤如下：
- 选择一种动画效果
1.POPBasicAnimation 基本的动画效果，我们常用的EaseInOut、Linenear的动画效果都可以用这种方式实现

<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="constant">POPBasicAnimation *basicAnimation</span> = [POPBasicAnimation animation];</div><div class="line">basicAnimation.timingFunction=[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];</div><div class="line"><span class="comment">// kCAMediaTimingFunctionLinear  kCAMediaTimingFunctionEaseIn  kCAMediaTimingFunctionEaseOut  kCAMediaTimingFunctionEaseInEaseOut</span></div></pre></td></tr></table></figure>

2.POPSpringAnimation 弹簧效果，如下图

![pop.gif](../images/pop.gif)

<pre><code>
POPSpringAnimation *springAnimation = [POPSpringAnimation animation];
springAnimation.springBounciness=14;    // 弹簧弹力 取值范围为[0, 20]，默认值为4
springAnimation.springSpeed=3;     // 弹簧速度，速度越快，动画时间越短 [0, 20]，默认为12，和springBounciness一起决定着弹簧动画的效果
// 还有：dynamicsTension 弹簧的张力 dynamicsFriction 弹簧摩擦 dynamicsMass 质量 。张力，摩擦，质量这三者可以从更细的粒度上替代springBounciness和springSpeed控制弹簧动画的效果
</code></pre>
3.POPDecayAnimation 衰减效果，参考UIScrollView滑动松手后的减速
<pre><code>
POPDecayAnimation *decayAnimation=[POPDecayAnimation animation];
decayAnimation.velocity=@(233); //值的变化速率
</code></pre>

<ul>
<li>选择生成动画的Property<br>View Properties，包含以下定义<br>kPOPViewAlpha  kPOPViewBackgroundColor kPOPViewBounds kPOPViewCenter kPOPViewFrame kPOPViewScaleXY  kPOPViewSize</li>
</ul>
<p>Layer Properties<br>kPOPLayerBackgroundColor kPOPLayerBounds kPOPLayerScaleXY kPOPLayerSize kPOPLayerOpacity kPOPLayerPosition kPOPLayerPositionX kPOPLayerPositionY  kPOPLayerRotation kPOPLayerBackgroundColor</p>
<ul>
<li><p>设置对应的.toValue<br>例如</p>
<pre><code>
// 设置alpha
POPBasicAnimation *basicAnimation = [POPBasicAnimation animation];
basicAnimation.property = [POPAnimatableProperty propertyWithName:kPOPViewAlpha];
basicAnimation.toValue= @(0);
// 设置BackgroundColor
POPSpringAnimation *basicAnimation = [POPSpringAnimation animation];
basicAnimation.property = [POPAnimatableProperty propertyWithName: kPOPLayerBackgroundColor];
basicAnimation.toValue= [UIColor redColor];
</code></pre>
</li>
<li><p>为动画设置name和delegate<br><pre><code><br>basicAnimation.name=@”POPAnimation”;<br>basicAnimation.delegate=self;<br></code></pre><br>delegate方法如下</p>
</li>
</ul>
<pre><code>
- (void)pop_animationDidStart:(POPAnimation *)anim;
- (void)pop_animationDidStop:(POPAnimation *)anim finished:(BOOL)finished;
- (void)pop_animationDidReachToValue:(POPAnimation *)anim;

</code></pre>
- 将animation添加到对象上
<pre><code>
[self.tableView pop_addAnimation:basicAnimation forKey:@"POPAnimation"];
</code></pre>

<h1 id="完整例子">完整例子</h1>
<pre><code>
POPSpringAnimation *basicAnimation = [POPSpringAnimation animation];
basicAnimation.property = [POPAnimatableProperty propertyWithName:kPOPViewFrame];
basicAnimation.toValue=[NSValue valueWithCGRect:CGRectMake(0, 0, 90, 190)];
basicAnimation.name=@"SomeAnimationNameYouChoose";
basicAnimation.delegate=self;
[self.tableView pop_addAnimation:basicAnimation forKey:@"POPAnimation"];
</code></pre></code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>合适的动画效果是提高用户体验最直观的方式，我们项目中的动画应用也不少，主要是使用的UIKit的动画扩展，还有少量用CoreAnimation实现。现在Facebook开源了POP，我们又多了一种强大好用的选择。与CoreAnimation相比，api用法相似，POP提供了更多方便生动的动画效果，主要是弹簧（SpringAnimation）和衰减（DecayAnimation）效果。</p>
<h1 id="使用方法">使用方法</h1>
<p>POP的使用跟CoreAnimation比较相似，基本的步骤如下：</p>
<ul>
<li>选择一种动画效果<br>1.POPBasicAnimation 基本的动画效果，我们常用的EaseInOut、Linenear的动画效果都可以用这种方式实现</li>
</ul>
<p>2.POPSpringAnimation 弹簧效果，如下图</p>
<p><img src="../images/pop.gif" alt="pop.gif"></p>
<pre><code>
POPSpringAnimation *springAnimation = [POPSpringAnimation animation];
springAnimation.springBounciness=14;    // 弹簧弹力 取值范围为[0, 20]，默认值为4
springAnimation.springSpeed=3;     // 弹簧速度，速度越快，动画时间越短 [0, 20]，默认为12，和springBounciness一起决定着弹簧动画的效果

]]>
    
    </summary>
    
      <category term="POP" scheme="http://linkageios.github.io/tags/POP/"/>
    
      <category term="动画" scheme="http://linkageios.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LCMenuView简介]]></title>
    <link href="http://linkageios.github.io/2014/11/05/LCMenuView%E7%AE%80%E4%BB%8B/"/>
    <id>http://linkageios.github.io/2014/11/05/LCMenuView简介/</id>
    <published>2014-11-05T08:43:14.000Z</published>
    <updated>2014-11-18T10:31:02.000Z</updated>
    <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>筛选功能在慧驾项目中用的比较多，所以抽取出来，以便简化代码，便于维护</p>
<h1 id="类与方法说明">类与方法说明</h1>
<p>LCMenuView<br>菜单标题相关，与此次迭代UI相同，以后根据UI的变更进行修改，提供方法和属性如下：</p>
<pre><code>
- (id)initWithFrame:(CGRect)frame       //
segmentWidths:(NSArray *)widths   // 每个segment的宽度，类型NSNumber
segmentTitles:(NSArray *)titles   // 标题，类型NSString
popups:(NSArray *)popups   // 弹出菜单，类型LCMenuPopupView
parentView:(UIView *)parent;   // menu的parentView

<a id="more"></a>

# 简介
筛选功能在慧驾项目中用的比较多，所以抽取出来，以便简化代码，便于维护

# 类与方法说明
LCMenuView
菜单标题相关，与此次迭代UI相同，以后根据UI的变更进行修改，提供方法和属性如下：
<pre><code>
- (id)initWithFrame:(CGRect)frame       //
segmentWidths:(NSArray *)widths   // 每个segment的宽度，类型NSNumber
segmentTitles:(NSArray *)titles   // 标题，类型NSString
popups:(NSArray *)popups   // 弹出菜单，类型LCMenuPopupView
parentView:(UIView *)parent;   // menu的parentView

- (void)setSegmentTitle:(NSString *)title index:(NSInteger)index;   // 设置标题
- (NSString *)segmentTitleAtIndex:(NSInteger)index;                 // 标题

- (BOOL)showPopup:(BOOL)show index:(NSInteger)index animate:(BOOL)animate;  // 显示或隐藏菜单
- (void)hideAllPopup:(BOOL)animate; //隐藏所有菜单

@property (nonatomic, weak, readonly) UIView *parent;
@property (nonatomic, strong, readonly) UIView *maskView;

@property (nonatomic, assign, readonly) NSInteger popedIndex;   // 当前显示菜单index
</code></pre>

<p>LCMenuPopupView<br>弹出菜单相关，主要封装了菜单的弹出收起动画，提供方法和属性如下：</p>
<pre><code>
// 初始化方法 arrowBtmCenterX是箭头X轴位置
- (id)initWithFrame:(CGRect)frame
ContentView:(UIView *)contentView
arrowPosition:(CGFloat)arrowBtmCenterX;

@property (nonatomic, strong, readwrite) UIView *contentView;

@property (nonatomic, assign, readonly) CGFloat arrowBtmCenterX;

// 显示或隐藏内容
@property (nonatomic, assign, getter=isShow) BOOL show;
- (void)show:(BOOL)show animate:(BOOL)animate;
</code></pre>

<h1 id="使用方法">使用方法</h1>
<p>创建UIView子类，封装弹出菜单的内容，本次封装的是LCMenuContentView</p>
<pre><code>
LCMenuContentView *t0 = [[LCMenuContentView alloc] initWithFrame:CGRectMake(0, 0, 320, 40 * arrayPopInfoMile.count) titles:arrayPopInfoMile selectRow:0];
t0.shopPopViewDelegate = self;
LCMenuPopupView *p0 = [[LCMenuPopupView alloc] initWithFrame:CGRectMake(0, 0, 320, 40 * arrayPopInfoMile.count) ContentView:t0 arrowPosition:53];

NSInteger index = -1;
index = [arrayPopInfoKind indexOfObject:self.stringTitle];
LCMenuContentView *t1 = [[LCMenuContentView alloc] initWithFrame:CGRectMake(0, 0, 320, 40 * arrayPopInfoKind.count) titles:arrayPopInfoKind selectRow:index];
t1.shopPopViewDelegate = self;
LCMenuPopupView *p1 = [[LCMenuPopupView alloc] initWithFrame:CGRectMake(0, 0, 320, 40 * arrayPopInfoKind.count) ContentView:t1 arrowPosition:160];


LCMenuContentView *t2 = [[LCMenuContentView alloc] initWithFrame:CGRectMake(0, 0, 320, 40 * arrayPopInfoComment.count) titles:arrayPopInfoComment selectRow:-1];
t2.shopPopViewDelegate = self;
LCMenuPopupView *p2 = [[LCMenuPopupView alloc] initWithFrame:CGRectMake(0, 0, 320, 40 * arrayPopInfoComment.count) ContentView:t2 arrowPosition:320 - 53];

LCMenuView *view = [[LCMenuView alloc] initWithFrame:CGRectMake(0, 0, 320, 50)
segmentWidths:@[@(106), @(108), @(106)]
segmentTitles:@[arrayPopInfoMile[0], self.stringTitle, @"智能"]
popups:@[p0, p1, p2]
parentView:self.view];
[self.view addSubview:view];
</code></pre>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="简介">简介</h1>
<p>筛选功能在慧驾项目中用的比较多，所以抽取出来，以便简化代码，便于维护</p>
<h1 id="类与方法说明">类与方法说明</h1>
<p>LCMenuView<br>菜单标题相关，与此次迭代UI相同，以后根据UI的变更进行修改，提供方法和属性如下：</p>
<pre><code>
- (id)initWithFrame:(CGRect)frame       //
segmentWidths:(NSArray *)widths   // 每个segment的宽度，类型NSNumber
segmentTitles:(NSArray *)titles   // 标题，类型NSString
popups:(NSArray *)popups   // 弹出菜单，类型LCMenuPopupView
parentView:(UIView *)parent;   // menu的parentView

]]>
    
    </summary>
    
      <category term="LCMenuView" scheme="http://linkageios.github.io/tags/LCMenuView/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高德地图sdk分析]]></title>
    <link href="http://linkageios.github.io/2014/11/03/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BEsdk%E5%88%86%E6%9E%90/"/>
    <id>http://linkageios.github.io/2014/11/03/高德地图sdk分析/</id>
    <published>2014-11-03T07:27:00.000Z</published>
    <updated>2014-11-18T10:27:43.000Z</updated>
    <content type="html"><![CDATA[<p>高德地图sdk是目前国内使用比较多的地图类sdk（还有百度地图也不错），目前项目中也用到了，但是相关封装还是不够清晰。为了做好这一层封装，首先需要把高德地图sdk研究一下。</p>
<p>高德地图有各种语言版本的sdk，其中iOS的sdk就包含基本sdk、云图sdk，导航sdk。后两个sdk暂时用不到，而基本sdk中又包含2d（栅格地图）和3d（矢量地图）两个版本的库以及搜索的库。今天要分析的就是2d和搜索的framework，最新的sdk版本是2.4.0。<br><a id="more"></a></p>
<p>高德地图sdk是目前国内使用比较多的地图类sdk（还有百度地图也不错），目前项目中也用到了，但是相关封装还是不够清晰。为了做好这一层封装，首先需要把高德地图sdk研究一下。</p>
<p>高德地图有各种语言版本的sdk，其中iOS的sdk就包含基本sdk、云图sdk，导航sdk。后两个sdk暂时用不到，而基本sdk中又包含2d（栅格地图）和3d（矢量地图）两个版本的库以及搜索的库。今天要分析的就是2d和搜索的framework，最新的sdk版本是2.4.0。</p>
<h3 id="几个核心类说明">几个核心类说明</h3>
<h6 id="MAMapView">MAMapView</h6>
<p>地图视图类，sdk中最重要的一个类，用来负责地图的展示，该类直接从UIView继承而来。</p>
<p>1、属性visibleMapRect</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">self.mapView.visibleMapRect </span>=<span class="string"> MAMapRectMake(220880104, 101476980, 272496, 466656);</span></div></pre></td></tr></table></figure>

<p>它定义了地图的可见范围，如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/16632-3c72c4c2f1c5ff9b.png" alt="mamap_2.png"><br>我们如果改变visibleMapRect的大小，地图就会显示不同的区域。</p>
<p>2、属性mapType<br>地图类型，有两种类型： 普通地图和卫星地图，我们经常用到的就是普通地图</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> NS_ENUM(<span class="built_in">NSInteger</span>, MAMapType)</div><div class="line">{</div><div class="line">    MAMapTypeStandard,  <span class="comment">// 普通地图</span></div><div class="line">    MAMapTypeSatellite  <span class="comment">// 卫星地图</span></div><div class="line">};</div></pre></td></tr></table></figure>

<p>3、属性showTraffic<br>是否展示路况拥堵信息，默认是不展示的，一般也用不到。</p>
<p>4、属性scrollEnabled和zoomEnabled<br>MAMapView虽然不是UIScrollView，但自身也实现了滚动和缩放功能（UIWebView同理）。这两个属性可以控制缩放和滚动的开关，默认都是打开的。</p>
<p>5、属性logoCenter和logoSize<br>高德的logo位置和大小，这个logo是需要显示出来的，不能隐藏不能遮挡（尊重知识产权）</p>
<p>6、属性showsCompass、compassOrigin、compassSize<br>地图的罗盘是否展示，展示的位置和大小</p>
<p>7、属性showsScale、scaleOrigin、scaleSize<br>地图的比例尺是否展示，展示的位置和大小</p>
<p>8、属性centerCoordinate<br>地图中心点的经纬度，改变它不会影响缩放比例。</p>
<p>9、属性showsUserLocation、userLocation、userTrackingMode<br>是否显示用户位置，用户位置的数据、用户追踪的模式。</p>
<p>10、属性annotations<br>地图上的标注，显示对应位置有什么东西，比较常用。</p>
<p>11、属性overlays<br>地图上的覆盖图形，能够在地图指定位置绘制自定义的图层，比较常用。</p>
<p>12、属性distanceFilter、desiredAccuracy、headingFilter<br>最小更新距离，定位精度，最小更新角度。</p>
<p>13、协议，MAMapViewDelegate，作为一个自定义的视图，当其数据对应数据发生变化时，肯定会有一些函数回调来改变自身。这些方法都被集中在MAMapViewDelegate中。一共有18个方法，大致可以分为4类：地图区域改变、用户位置发生变化、标注的创建和事件响应已经覆盖层的一些逻辑。个人觉得这个协议太大了，不符合接口分离原则 。</p>
<h6 id="AMapSearchAPI">AMapSearchAPI</h6>
<p>AMapSearchAPI是一个NSObject，代表高德地图的搜索功能。</p>
<p>1、属性timeOut。<br>搜索请求超时时间，默认是20秒。</p>
<p>2、查询接口，不同的查询类型有不同的查询接口。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//<span class="variable">POI</span>查询接口函数，即根据 <span class="variable">POI</span> 参数选项进行 <span class="variable">POI</span> 查询。</div><div class="line"><span class="pp">- <span class="params">(void)</span>AMapPlaceSearch:<span class="params">(<span class="variable">AMapPlaceSearchRequest</span> *)</span>request;</span></div><div class="line"></div><div class="line">//路径规划查询接口。</div><div class="line">- <span class="params">(void)</span>AMapNavigationSearch:<span class="params">(<span class="variable">AMapNavigationSearchRequest</span> *)</span>request;</div><div class="line"></div><div class="line">//输入提示查询接口。</div><div class="line">- <span class="params">(void)</span>AMapInputTipsSearch:<span class="params">(<span class="variable">AMapInputTipsSearchRequest</span> *)</span>request;</div><div class="line"></div><div class="line">//地址编码查询接口。</div><div class="line">- <span class="params">(void)</span>AMapGeocodeSearch:<span class="params">(<span class="variable">AMapGeocodeSearchRequest</span> *)</span>request;</div><div class="line"></div><div class="line">//逆地址编码查询接口。</div><div class="line">- <span class="params">(void)</span>AMapReGoecodeSearch:<span class="params">(<span class="variable">AMapReGeocodeSearchRequest</span> *)</span>request;</div><div class="line"></div><div class="line">//公交线路查询接口。</div><div class="line">- <span class="params">(void)</span>AMapBusLineSearch:<span class="params">(<span class="variable">AMapBusLineSearchRequest</span> *)</span>request;</div><div class="line"></div><div class="line">//公交车站查询接口。</div><div class="line">- <span class="params">(void)</span>AMapBusStopSearch:<span class="params">(<span class="variable">AMapBusStopSearchRequest</span> *)</span>request;</div></pre></td></tr></table></figure>

<p>3、协议AMapSearchDelegate，包含对各种请求接口成功失败的回调。</p>
<h3 id="可以实现的功能">可以实现的功能</h3>
<h6 id="自定义用户坐标点">自定义用户坐标点</h6>
<p>如果起用了定位，如下的方法会被调用到，因为自身打点也是一个Annotation，但这个Annotation的类型是MAUserLocation。然后通过设置MAUserLocationRepresentation，就可以将用户坐标点进行自定义。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)mapView:(MAMapView *)mapView didAddAnnotationViews:(NSArray *)views</div><div class="line">{</div><div class="line">    MAAnnotationView *<span class="variable">view =</span> views[<span class="number">0</span>];</div><div class="line"></div><div class="line">    // 放到该方法中用以保证userlocation的annotationView已经添加到地图上了。</div><div class="line">    <span class="keyword">if</span> ([view.annotation isKindOfClass:[MAUserLocation class]])</div><div class="line">    {</div><div class="line">        MAUserLocationRepresentation *<span class="variable">pre =</span> [[MAUserLocationRepresentation alloc] init];</div><div class="line">        pre.<span class="variable">fillColor =</span> [UIColor colorWithRed:<span class="number">0.9</span> green:<span class="number">0.1</span> blue:<span class="number">0.1</span> alpha:<span class="number">0.3</span>];</div><div class="line">        pre.<span class="variable">strokeColor =</span> [UIColor colorWithRed:<span class="number">0.1</span> green:<span class="number">0.1</span> blue:<span class="number">0.9</span> alpha:<span class="number">1.0</span>];</div><div class="line">        pre.<span class="variable">image =</span> [UIImage imageNamed:@<span class="string">"location.png"</span>];</div><div class="line">        pre.<span class="variable">lineWidth =</span> <span class="number">3</span>;</div><div class="line">        pre.<span class="variable">lineDashPattern =</span> @[@<span class="number">6</span>, @<span class="number">3</span>];</div><div class="line"></div><div class="line">        [self.mapView updateUserLocationRepresentation:pre];</div><div class="line"></div><div class="line">        view.<span class="variable">calloutOffset =</span> CGPointMake(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    }  </div><div class="line">}</div></pre></td></tr></table></figure>

<h6 id="用户手势">用户手势</h6>
<p>缩放和滚动有属性直接控制，单击双击也能够支持，但是为了和AnnotationView进行区分，需要用下面的方法进行过滤。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>gestureRecognizer:<span class="params">(<span class="variable">UIGestureRecognizer</span> *)</span>gestureRecognizer shouldReceiveTouch:<span class="params">(<span class="variable">UITouch</span> *)</span>touch</span></div></pre></td></tr></table></figure>

<h6 id="添加浮层">添加浮层</h6>
<p>浮层对象是遵循MAOverlay协议的对象，可以是圆、折线和多边形。在高德sdk中，MACircle、MAPolyline、MAPolygon都是浮层对象。<br>然后通过</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>addOverlays:<span class="params">(<span class="variable">NSArray</span> *)</span>overlays;</span></div></pre></td></tr></table></figure>

<p>将浮层对象添加到MapView中。</p>
<h6 id="自定义浮层">自定义浮层</h6>
<p>可以自定义浮层对象，只要符合MAOverlay协议即可。然后在绘制图层的代理方法中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(<span class="variable">MAOverlayRenderer</span> *)</span>mapView:<span class="params">(<span class="variable">MAMapView</span> *)</span>mapView viewForOverlay:<span class="params">(id &lt;<span class="variable">MAOverlay</span>&gt;)</span>overlay</span></div></pre></td></tr></table></figure>

<p>子类话一个MAOverlayRenderer并返回，该子类只要重写方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>drawMapRect:<span class="params">(<span class="variable">MAMapRect</span>)</span>mapRect zoomScale:<span class="params">(<span class="variable">MAZoomScale</span>)</span>zoomScale inContext:<span class="params">(<span class="variable">CGContextRef</span>)</span>context</span></div></pre></td></tr></table></figure>

<p>该方法就如果UIView的drawRect，可以随心所欲的在上面画任何东西。</p>
<p>Overlay可以直接贴图，使用MAGroundOverlay类。虽然这个功能用自定义Overlay的方式也能实现，但比较麻烦。用MAGroundOverlay就很简单。</p>
<p>Overlay还支持大地曲线：MAGeodesicPolyline，图片tiles：MATileOverlay。</p>
<h6 id="打点标记">打点标记</h6>
<p>Annotaion就是在地图上标记一个位置，然后展示出来。展示的视图就是用MAAnnotationView。<br>像MapView插入Annotation的方法是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>addAnnotation:<span class="params">(id &lt;<span class="variable">MAAnnotation</span>&gt;)</span>annotation;</span></div></pre></td></tr></table></figure>

<p>类似UITableView，MAAnnotationView的创建实在代理方法中实现的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(<span class="variable">MAAnnotationView</span> *)</span>mapView:<span class="params">(<span class="variable">MAMapView</span> *)</span>mapView viewForAnnotation:<span class="params">(id&lt;<span class="variable">MAAnnotation</span>&gt;)</span>annotation</span></div></pre></td></tr></table></figure>

<p>MAAnnotationView可以自定义，可以有更好的显示效果；Annotation还支持动画，让显示的点动起来。</p>
<h3 id="搜索接口">搜索接口</h3>
<h6 id="POI搜索">POI搜索</h6>
<p>POI(Point of Interest)，信息点，一家餐馆就是一个信息点。POI搜索可以根据ID、关键字、中心点搜索周边、指定范围搜索等搜索方式来满足不同的需求。代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 根据ID来搜索POI. */</span></div><div class="line">- (void)searchPoiByID</div><div class="line">{</div><div class="line">    AMapPlaceSearchRequest *<span class="variable">request =</span> [[AMapPlaceSearchRequest alloc] init];</div><div class="line">    //    B000A80WBJ    hotel</div><div class="line">    //    B00141IEZK    dining</div><div class="line">    //    B000A876EH    cinema</div><div class="line">    //    B000A7O1CU    scenic</div><div class="line">    request.<span class="variable">searchType          =</span> AMapSearchType_PlaceID;</div><div class="line">    request.<span class="variable">uid                 =</span> @<span class="string">"B000A07060"</span>;</div><div class="line">    request.<span class="variable">requireExtension    =</span> YES;</div><div class="line">    </div><div class="line">    [self.search AMapPlaceSearch:request];</div><div class="line">    </div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* 根据关键字来搜索POI. */</span></div><div class="line">- (void)searchPoiByKeyword</div><div class="line">{</div><div class="line">    AMapPlaceSearchRequest *<span class="variable">request =</span> [[AMapPlaceSearchRequest alloc] init];</div><div class="line">    </div><div class="line">    request.<span class="variable">searchType          =</span> AMapSearchType_PlaceKeyword;</div><div class="line">    request.<span class="variable">keywords            =</span> @<span class="string">"肯德基"</span>;</div><div class="line">    request.<span class="variable">city                =</span> @[@<span class="string">"010"</span>];</div><div class="line">    request.<span class="variable">requireExtension    =</span> YES;</div><div class="line">    [self.search AMapPlaceSearch:request];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* 根据中心点坐标来搜周边的POI. */</span></div><div class="line">- (void)searchPoiByCenterCoordinate</div><div class="line">{</div><div class="line">    AMapPlaceSearchRequest *<span class="variable">request =</span> [[AMapPlaceSearchRequest alloc] init];</div><div class="line">    </div><div class="line">    request.<span class="variable">searchType          =</span> AMapSearchType_PlaceAround;</div><div class="line">    request.<span class="variable">location            =</span> [AMapGeoPoint locationWithLatitude:<span class="number">39.990459</span> longitude:<span class="number">116.481476</span>];</div><div class="line">    request.<span class="variable">keywords            =</span> @<span class="string">"餐饮"</span>;</div><div class="line">    <span class="comment">/* 按照距离排序. */</span></div><div class="line">    request.<span class="variable">sortrule            =</span> <span class="number">1</span>;</div><div class="line">    request.<span class="variable">requireExtension    =</span> YES;</div><div class="line">    </div><div class="line">    <span class="comment">/* 添加搜索结果过滤 */</span></div><div class="line">    AMapPlaceSearchFilter *<span class="variable">filter =</span> [[AMapPlaceSearchFilter alloc] init];</div><div class="line">    filter.<span class="variable">costFilter =</span> @[@<span class="string">"100"</span>, @<span class="string">"200"</span>];</div><div class="line">    filter.<span class="variable">requireFilter =</span> AMapRequireGroupbuy;</div><div class="line">    request.<span class="variable">searchFilter =</span> filter;</div><div class="line">    </div><div class="line">    [self.search AMapPlaceSearch:request];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* 在指定的范围内搜索POI. */</span></div><div class="line">- (void)searchPoiByPolygon</div><div class="line">{</div><div class="line">    NSArray *<span class="variable">points =</span> [NSArray arrayWithObjects:</div><div class="line">                       [AMapGeoPoint locationWithLatitude:<span class="number">39.990459</span> longitude:<span class="number">116.481476</span>],</div><div class="line">                       [AMapGeoPoint locationWithLatitude:<span class="number">39.890459</span> longitude:<span class="number">116.581476</span>],</div><div class="line">                       nil];</div><div class="line">    AMapGeoPolygon *<span class="variable">polygon =</span> [AMapGeoPolygon polygonWithPoints:points];</div><div class="line">    </div><div class="line">    AMapPlaceSearchRequest *<span class="variable">request =</span> [[AMapPlaceSearchRequest alloc] init];</div><div class="line">    </div><div class="line">    request.<span class="variable">searchType          =</span> AMapSearchType_PlacePolygon;</div><div class="line">    request.<span class="variable">polygon             =</span> polygon;</div><div class="line">    request.<span class="variable">keywords            =</span> @<span class="string">"Apple"</span>;</div><div class="line">    request.<span class="variable">requireExtension    =</span> YES;</div><div class="line">    </div><div class="line">    [self.search AMapPlaceSearch:request];</div><div class="line">}</div></pre></td></tr></table></figure>

<h6 id="地理编码">地理编码</h6>
<p>输入提示查询</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="constant">AMapInputTipsSearchRequest</span> *tips = [[<span class="constant">AMapInputTipsSearchRequest</span> alloc] init];</div><div class="line">tips.keywords = @<span class="string">"关键字"</span>;</div><div class="line">[<span class="keyword">self</span>.search <span class="constant">AMapInputTipsSearch</span><span class="symbol">:tips</span>];</div></pre></td></tr></table></figure>

<p>输入提示回调</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)onInputTipsSearchDone:(AMapInputTipsSearchRequest *)<span class="built_in">request</span> <span class="built_in">response</span>:(AMapInputTipsSearchResponse *)<span class="built_in">response</span></div><div class="line">{</div><div class="line">    [self.tips setArray:<span class="built_in">response</span>.tips];</div><div class="line">    </div><div class="line">    [self.displayController.searchResultsTableView reloadData];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>搜索地理编码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="constant">AMapGeocodeSearchRequest</span> *geo = [[<span class="constant">AMapGeocodeSearchRequest</span> alloc] init];</div><div class="line">geo.address = key;</div><div class="line">    </div><div class="line"><span class="input"><span class="prompt">if (adcode.length &gt;</span> <span class="number">0</span>)</span></div><div class="line">{</div><div class="line">    geo.city = @[adcode];</div><div class="line">}</div><div class="line">    </div><div class="line">[<span class="keyword">self</span>.search <span class="constant">AMapGeocodeSearch</span><span class="symbol">:geo</span>];</div></pre></td></tr></table></figure>

<p>地理编码回调，得到一个地点的经纬度信息</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>onGeocodeSearchDone:<span class="params">(<span class="variable">AMapGeocodeSearchRequest</span> *)</span>request response:<span class="params">(<span class="variable">AMapGeocodeSearchResponse</span> *)</span>response</span></div><div class="line">{</div><div class="line">}</div></pre></td></tr></table></figure>

<h6 id="逆地理编码">逆地理编码</h6>
<p>逆地理编码与地理编码正好相反，是通过经纬度来查询文字描述的位置信息。<br>发起逆地理编码查询</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AMapReGeocodeSearchRequest *regeo = [[AMapReGeocodeSearchRequest alloc] init];</div><div class="line">    </div><div class="line"><span class="filename">regeo.location = [AMapGeoPoint locationWithLatitude</span>:<span class="filename">coordinate.latitude longitude</span>:<span class="filename">coordinate.longitude];</span></div><div class="line">regeo.requireExtension = YES;</div><div class="line">    </div><div class="line">[self.search AMapReGoecodeSearch:regeo];</div></pre></td></tr></table></figure>

<p>逆地理编码回调</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)onReGeocodeSearchDone:(AMapReGeocodeSearchRequest *)<span class="built_in">request</span> <span class="built_in">response</span>:(AMapReGeocodeSearchResponse *)<span class="built_in">response</span></div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">response</span>.regeocode != nil)</div><div class="line">    {</div><div class="line">        CLLocationCoordinate2D coordinate = CLLocationCoordinate2DMake(<span class="built_in">request</span>.location.latitude, <span class="built_in">request</span>.location.longitude);</div><div class="line">        ReGeocodeAnnotation *reGeocodeAnnotation = [[ReGeocodeAnnotation alloc] initWithCoordinate:coordinate</div><div class="line">                                                                                         reGeocode:<span class="built_in">response</span>.regeocode];</div><div class="line">        </div><div class="line">        [self.mapView addAnnotation:reGeocodeAnnotation];</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>除了以上的搜索，还有导航、搜索公交路线、公交站，这些再一般的应用中不会用到，就不介绍了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>高德地图sdk是目前国内使用比较多的地图类sdk（还有百度地图也不错），目前项目中也用到了，但是相关封装还是不够清晰。为了做好这一层封装，首先需要把高德地图sdk研究一下。</p>
<p>高德地图有各种语言版本的sdk，其中iOS的sdk就包含基本sdk、云图sdk，导航sdk。后两个sdk暂时用不到，而基本sdk中又包含2d（栅格地图）和3d（矢量地图）两个版本的库以及搜索的库。今天要分析的就是2d和搜索的framework，最新的sdk版本是2.4.0。<br>]]>
    
    </summary>
    
      <category term="高德" scheme="http://linkageios.github.io/tags/%E9%AB%98%E5%BE%B7/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个简单的分享框架]]></title>
    <link href="http://linkageios.github.io/2014/10/29/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E4%BA%AB%E6%A1%86%E6%9E%B6/"/>
    <id>http://linkageios.github.io/2014/10/29/一个简单的分享框架/</id>
    <published>2014-10-29T02:33:00.000Z</published>
    <updated>2014-11-18T10:28:21.000Z</updated>
    <content type="html"><![CDATA[<h3 id="背景">背景</h3>
<p>分享，是APP中一个基础功能，可以为APP提供传播渠道。APP中分享功能的开发主要有两种形式：</p>
<ul>
<li>集成各个分享平台提供的sdk。<br> 常用的社交软件，如微信、微博，都有各自的开放平台，提供各种语言的sdk。使用sdk，我们可以快速的将分享功能加到应用中。</li>
<li>使用分享集成框架。<br>虽然使用sdk开发已经很快了，但是不同的分享平台有不同的特点，一个一个去集成研究还是要花费一定时间。而分享功能在展现形式和交互流程上又有共通性，所以技术上也存在整合的可行性。因此，市场上出现了如友盟等第三方分享平台，开发者只需要加很少的代码，就能集成几乎所有的分享渠道。</li>
</ul>
<p>既然友盟等已经做的这么好了，为什么还要自己做分享框架呢？</p>
<p>首先，技术上的不可控性。我们依赖友盟，友盟再依赖原生sdk，环节越多，中间的风险就越多。<br>其次，展现上的雷同。用友盟等工具的APP基本上是一样的展现形式，如果你做的只是一款大陆货，那没问题；但想做好，雷同就是首先要避免的。<br>最后，确实有时间做这个。做这个东西，集成了微信、微博、短信、邮件，总共花了三天。<br><a id="more"></a></p>
<h3 id="背景-1">背景</h3>
<p>分享，是APP中一个基础功能，可以为APP提供传播渠道。APP中分享功能的开发主要有两种形式：</p>
<ul>
<li>集成各个分享平台提供的sdk。<br> 常用的社交软件，如微信、微博，都有各自的开放平台，提供各种语言的sdk。使用sdk，我们可以快速的将分享功能加到应用中。</li>
<li>使用分享集成框架。<br>虽然使用sdk开发已经很快了，但是不同的分享平台有不同的特点，一个一个去集成研究还是要花费一定时间。而分享功能在展现形式和交互流程上又有共通性，所以技术上也存在整合的可行性。因此，市场上出现了如友盟等第三方分享平台，开发者只需要加很少的代码，就能集成几乎所有的分享渠道。</li>
</ul>
<p>既然友盟等已经做的这么好了，为什么还要自己做分享框架呢？</p>
<p>首先，技术上的不可控性。我们依赖友盟，友盟再依赖原生sdk，环节越多，中间的风险就越多。<br>其次，展现上的雷同。用友盟等工具的APP基本上是一样的展现形式，如果你做的只是一款大陆货，那没问题；但想做好，雷同就是首先要避免的。<br>最后，确实有时间做这个。做这个东西，集成了微信、微博、短信、邮件，总共花了三天。</p>
<h3 id="实现">实现</h3>
<ul>
<li><p>准备工作<br>因为目前我们要用的分享渠道只有微信朋友圈、微信好友、新浪微博、短信、邮件。所以需要准备的sdk只有微信和新浪，把sdk大概看一遍，跑一下Demo，就可以进行设计了。</p>
</li>
<li><p>接口<br>分享框架的客户是公司内部的iOS程序员，别人没有义务了解你的sdk究竟是怎么做的。以前用的友盟一行代码就能搞定，所以这个框架也必须要足够简单。因此，我还是参照了友盟的接口，设计了该框架唯一的分享接口。</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//LCShareSDK.h</span></div><div class="line">+ (<span class="keyword">void</span>)presentShareMenu:(<span class="built_in">NSArray</span>*)menu</div><div class="line">        inViewController:(<span class="built_in">UIViewController</span>*)viewController</div><div class="line">               shareItem:(LCShareItem*)item</div><div class="line">                delegate:(<span class="keyword">id</span>&lt;LCShareDelegate&gt;)delegate;</div></pre></td></tr></table></figure>

<ul>
<li>实现<br>主要是采用了单例模式来开发。虽然能够覆盖现有的使用场景，但不支持多线程，而且设计模式中最鄙视单例模式，这是一种让人懒惰的模式（个人观点）。<br>最上层给用户看到只有一个叫LCShareSDK的类，只有一个类方法。中间层分别对新浪微博、微信sdk进行封装，分别提供一个Manager类，也是单例。短信和邮件比较简单，逻辑处理就在LCShareSDK类里面实现。最下层是微信和新浪微博的sdk。<br>此外，新浪微博我用的不是最新的sdk，是有代码的。这样我就可以在程序内部进行分享，而且可以自定义授权页面和分享界面，灵活性很好。所以作为框架的一部分，还有授权和分享两个ViewController。<br>以下是结构图<br><img src="http://upload-images.jianshu.io/upload_images/16632-f852fef3b1f23475.png" alt="share.png"></li>
</ul>
<p>新浪微博里面默认的授权页面是弹出式的页面，弹出框还没有网页打，我觉得比较丑，就用自己写的LCShareOauthViewController替换了原有的View（这就是老版本sdk的好处，最新sdk只有静态库了）。</p>
<h3 id="使用">使用</h3>
<p>使用非常简单，在ViewController(非必须，但参数中是需要ViewController的)里面如下调用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LCShareItem* <span class="variable">shareItem =</span> [LCShareItem new];</div><div class="line">shareItem.<span class="variable">title =</span> @<span class="string">"XXXX"</span>;</div><div class="line">shareItem.<span class="variable">desc =</span> @<span class="string">"YYYY"</span>;</div><div class="line">shareItem.<span class="variable">image =</span> [UIImage imageNamed:SHARE_ICON];</div><div class="line">shareItem.<span class="variable">url =</span> @<span class="string">"http://www.qq.com"</span>;</div><div class="line">        </div><div class="line">[LCShareSDK presentShareMenu:@[@(WXMoments),@(WXFriend),@(Weibo),@(SMS),@(Mail)]</div><div class="line">            inViewController:self</div><div class="line">                   shareItem:shareItem</div><div class="line">                    delegate:self];</div></pre></td></tr></table></figure>

<p>然后就会弹出分享菜单：<br><img src="http://upload-images.jianshu.io/upload_images/16632-137ada9d0cca3657.png" alt="share_menu2.png"></p>
<p>如果之前没有授权过，下一步是打开授权页面，如果已安装微博，就会进行SSO授权。<br><img src="http://upload-images.jianshu.io/upload_images/16632-e60aaae234179c63.png" alt="share_oauth.png"></p>
<p>最后出现分享界面，点击发送即可分享。<br><img src="http://upload-images.jianshu.io/upload_images/16632-9db4f6b115712302.png" alt="share_content2.png"></p>
<p>除了那个分享接口，我们还提供了两个代理方法，用来判断用户点了哪个渠道，哪个渠道的分享结果。当然，这两个方法不是必须要实现的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">LCShareDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@optional</span></div><div class="line"></div><div class="line"><span class="comment">//点完了某个分享渠道按钮</span></div><div class="line">- (<span class="keyword">void</span>)didSelectShareWithSource:(LCShareSource)source;</div><div class="line"></div><div class="line"><span class="comment">//分享结果回调（成功或失败）</span></div><div class="line">- (<span class="keyword">void</span>)didFinishShareWithResponse:(LCShareResponse*)response;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>还有在AppDelegate里面要做些初始化工作，比如在程序启动时注册微信：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">[LCShareSDK registerWXApp:kWeiXinAppId]</span><span class="comment">;</span></div></pre></td></tr></table></figure>

<p>从微信或微博返回APP时的处理：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application openURL:(<span class="built_in">NSURL</span> *)url sourceApplication:(<span class="built_in">NSString</span> *)sourceApplication annotation:(<span class="keyword">id</span>)annotation</div><div class="line">{ </div><div class="line">    <span class="keyword">return</span> [LCShareSDK handleOpenUrl:url];</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h3 id="背景">背景</h3>
<p>分享，是APP中一个基础功能，可以为APP提供传播渠道。APP中分享功能的开发主要有两种形式：</p>
<ul>
<li>集成各个分享平台提供的sdk。<br> 常用的社交软件，如微信、微博，都有各自的开放平台，提供各种语言的sdk。使用sdk，我们可以快速的将分享功能加到应用中。</li>
<li>使用分享集成框架。<br>虽然使用sdk开发已经很快了，但是不同的分享平台有不同的特点，一个一个去集成研究还是要花费一定时间。而分享功能在展现形式和交互流程上又有共通性，所以技术上也存在整合的可行性。因此，市场上出现了如友盟等第三方分享平台，开发者只需要加很少的代码，就能集成几乎所有的分享渠道。</li>
</ul>
<p>既然友盟等已经做的这么好了，为什么还要自己做分享框架呢？</p>
<p>首先，技术上的不可控性。我们依赖友盟，友盟再依赖原生sdk，环节越多，中间的风险就越多。<br>其次，展现上的雷同。用友盟等工具的APP基本上是一样的展现形式，如果你做的只是一款大陆货，那没问题；但想做好，雷同就是首先要避免的。<br>最后，确实有时间做这个。做这个东西，集成了微信、微博、短信、邮件，总共花了三天。<br>]]>
    
    </summary>
    
      <category term="分享" scheme="http://linkageios.github.io/tags/%E5%88%86%E4%BA%AB/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS的网络框架（HTTP）]]></title>
    <link href="http://linkageios.github.io/2014/10/13/iOS%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%EF%BC%88HTTP%EF%BC%89/"/>
    <id>http://linkageios.github.io/2014/10/13/iOS的网络框架（HTTP）/</id>
    <published>2014-10-13T07:07:00.000Z</published>
    <updated>2014-11-18T10:29:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="背景和目标">背景和目标</h2>
<p>目前市场上的大部分App都有网络功能，而网络功能大部分都是基于HTTP协议的。HTTP协议简单而又强大，这也是该协议长盛不衰的秘诀之一。每一个程序员都最好了解一下HTTP协议，这会让你受益匪浅。</p>
<ul>
<li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html" target="_blank" rel="external">协议规范(英)</a></li>
<li><a href="http://javadocs.wikidot.com/hypertext-transfer-protocol-http1-1" target="_blank" rel="external">协议规范(中)</a></li>
</ul>
<p>回到iOS，我们将如何使用HTTP协议来完成网络请求呢？从头开始开发一个协议栈是重复造轮子，非常不明智。因为苹果的开发框架中已经包含了对HTTP协议的封装。<a href="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/WorkingWithHTTPAndHTTPSRequests/WorkingWithHTTPAndHTTPSRequests.html" target="_blank" rel="external">请看官方文档说明</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/16632-bc2417c93684ed68.gif" alt="network.gif"><br><a id="more"></a></p>
<h2 id="背景和目标-1">背景和目标</h2>
<p>目前市场上的大部分App都有网络功能，而网络功能大部分都是基于HTTP协议的。HTTP协议简单而又强大，这也是该协议长盛不衰的秘诀之一。每一个程序员都最好了解一下HTTP协议，这会让你受益匪浅。</p>
<ul>
<li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html" target="_blank" rel="external">协议规范(英)</a></li>
<li><a href="http://javadocs.wikidot.com/hypertext-transfer-protocol-http1-1" target="_blank" rel="external">协议规范(中)</a></li>
</ul>
<p>回到iOS，我们将如何使用HTTP协议来完成网络请求呢？从头开始开发一个协议栈是重复造轮子，非常不明智。因为苹果的开发框架中已经包含了对HTTP协议的封装。<a href="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/WorkingWithHTTPAndHTTPSRequests/WorkingWithHTTPAndHTTPSRequests.html" target="_blank" rel="external">请看官方文档说明</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/16632-bc2417c93684ed68.gif" alt="network.gif"></p>
<p>上面这张<a href="http://www.infoq.com/cn/articles/afn_vs_asi" target="_blank" rel="external">图片</a>解释了iOS框架中网络的实现方式和目前流行的网络框架所出的位置（第三行右边应该视CFHTTP，不是CFFTP））。ASI是基于CFHTTP的，AFNetworking是基于NSURL的，两者处在不同的层次上，实现原理也不同。</p>
<p>像这样的第三方网络框架，虽然使用起来比系统原生的简单了许多，但为了保持通用性，整个框架的接口还是比较多，调用的过程也不是一两行能搞定的。</p>
<p>我想，如果在开发自己的项目过程中，能不能提供一套最简单的API，只提供我们用的到的接口，并且将一些重复的处理逻辑封装起来。使得调用者在不需要了解CFHTTP、NSURL、ASIHTTPRequest、AFNetworking的情况下，只要用一两行代码，就能把网络请求处理完，让开发着处理网络请求像调用本地方法一样自然，这就是我的目标。</p>
<h2 id="确定需求范围">确定需求范围</h2>
<p>我不想做一个通用性很强的框架，我只是希望它能解决目前的所有需求，然后越简单越好。<br>我们目前遇到的需求不是很多，有如下几种类型：</p>
<ul>
<li>根据本地参数，向后台发起请求，获得我要的数据。</li>
<li>像后台提交数据，知道成功或者失败。</li>
</ul>
<h2 id="实现方式选择">实现方式选择</h2>
<p>由于个人喜好，我会基于AFNetworking之上开发一套API，同时让这套API可以方便的切换到ASIHTTPRequest或者哪天有冒出来的新框架。</p>
<h2 id="最终实现">最终实现</h2>
<p>最终的实现基本满足了预期的目标，即用一两行代码完成网络的请求。下面是架构图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/16632-9e79a04bcf4a1033.png" alt="http_framework.png"></p>
<p>其实一开始设计的时候，就只有4个类：</p>
<ul>
<li>MJHttpClient</li>
<li>MJRequest</li>
<li>MJHttpError</li>
<li>MJResponse</li>
</ul>
<p> 这样做满足了项目中80%的后台接口，但有些比如传图片或者需要在httpbody中塞数据的接口，用最基本的Request难以封装，所以就陆续加了两个子类。因为是见招拆招，所以并不完美，不过还是覆盖了当前项目的所有请求类型。</p>
<p>接下来主义介绍这几个类：</p>
<h4 id="MJHttpClient">MJHttpClient</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJResponseObject)(MJResponse* responseObject);</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJResponseError)(MJHttpError* responseError);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJHttpClient</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">+ (MJHttpClient*)client;</div><div class="line"></div><div class="line"><span class="comment">//设置是否接受非json格式的返回</span></div><div class="line">- (<span class="keyword">void</span>)enableNoneJsonBack;</div><div class="line"></div><div class="line"><span class="comment">//发送请求，需要提供成功和失败的回掉</span></div><div class="line">- (<span class="keyword">void</span>)sendRequest:(MJRequest*)request</div><div class="line">         onResponse:(MJResponseObject)processBlock</div><div class="line">            onError:(MJResponseError)errorBlock;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>这个类非常简单，第一个方法创建自身对象，非单例（因为可能同时存在多个请求，所以不可以用单例）。第二个方法是因为后台的返回数据有些不是json格式的（事情上开发过程中前后台需要协调尽量让所有的接口返回json，不要返回字符串或者整数对象。但现在已经有了漏网之鱼，所以要做容错）。第三个方法就是发送请求的方法，就一行代码。</p>
<h4 id="MJRequest">MJRequest</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, RequestMethod) <span class="comment">{</span></div><div class="line">    RequestMethod_Get,</div><div class="line">    RequestMethod_Post,</div><div class="line">    RequestMethod_Put,</div><div class="line">    RequestMethod_Delete</div><div class="line">};</div><div class="line"></div><div class="line">@<span class="keyword">class</span> MJQueryModel;</div><div class="line"></div><div class="line">@<span class="keyword">interface</span> MJRequest : NSObject</div><div class="line"></div><div class="line">@<span class="keyword">property</span> (nonatomic,assign) RequestMethod <span class="function"><span class="keyword">method</span>;</span></div><div class="line"></div><div class="line">@<span class="keyword">property</span> (nonatomic,<span class="keyword">copy</span>) NSString* baseUrl;</div><div class="line"></div><div class="line">@<span class="keyword">property</span> (nonatomic,<span class="keyword">copy</span>) NSString* api;</div><div class="line"></div><div class="line"><span class="comment">//请求参数的对象</span></div><div class="line">@<span class="keyword">property</span> (nonatomic,<span class="keyword">strong</span>) MJQueryModel* queryModel;</div><div class="line"></div><div class="line"><span class="comment">//请求参数的对象（请求参数是数组的话）</span></div><div class="line">@<span class="keyword">property</span> (nonatomic,<span class="keyword">strong</span>) NSArray* queryModels;</div><div class="line"></div><div class="line"><span class="comment">//创建请求</span></div><div class="line">+ (MJRequest*)requestWithMethod:(RequestMethod)<span class="function"><span class="keyword">method</span> <span class="title">api</span>:</span>(NSString*)api;</div><div class="line"></div><div class="line"><span class="comment">//请求参数对象转化成NSDictionary或者NSArray</span></div><div class="line">- (id)buildParam;</div><div class="line"></div><div class="line">@<span class="keyword">end</span></div></pre></td></tr></table></figure>

<p>这个Request只能吃力url传参数的情况，body里面传参数是不支持的（这也是MJBodyRequest和MJMultipartRequest存在的必要）。但即使url传参数，也有字典和数组两种情况，所以这里加了queryModel和queryModels两个属性，在实用的时候，只需要给其中一个复制就可以了。</p>
<h4 id="MJResponse">MJResponse</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJResponse</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="keyword">id</span> object;</div><div class="line"></div><div class="line">+ (MJResponse*)responseWithObject:(<span class="keyword">id</span>)responseObject;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>MJResponse是请求成功之后返回的对象，可以是空、字符串、字典、数组，基本上都可以支持，在成功的block里需要对其处理。</p>
<h4 id="MJHttpError">MJHttpError</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJHttpError</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">NSInteger</span> errorCode;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span>* errorDescription;</div><div class="line"></div><div class="line">+ (MJHttpError*)errorWithNSError:(<span class="built_in">NSError</span>*)error;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>这个类比较鸡肋，就是一个翻版的NSError。但后期可能会对错误有特殊处理，就先占个位。</p>
<h3 id="使用方法">使用方法</h3>
<h4 id="普通请求">普通请求</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">MJHttpClient<span class="keyword">*</span> client = [MJHttpClient client];</div><div class="line">MJRequest<span class="keyword">*</span> request = [MJRequest requestWithMethod:RequestMethod_Get api:<span class="comment">@"xxx/yyy"];</span></div><div class="line">    </div><div class="line">HJQueryAdsModel<span class="keyword">*</span> model = [HJQueryAdsModel new];</div><div class="line">model.type = [NSString stringWithFormat:<span class="comment">@"%d",mtag];</span></div><div class="line">request.queryModel = model;</div><div class="line">    </div><div class="line">[client sendRequest:request onResponse:^(MJResponse <span class="keyword">*</span>responseObject) {</div><div class="line">    //数据处理</div><div class="line">} onError:^(MJHttpError <span class="keyword">*</span>responseError) {</div><div class="line">    NSLog(<span class="comment">@"%@",responseError.errorDescription);</span></div><div class="line">}];</div></pre></td></tr></table></figure>

<h4 id="Body请求">Body请求</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">MJHttpClient<span class="keyword">*</span> client = [MJHttpClient client];</div><div class="line">        </div><div class="line">MJBodyRequest<span class="keyword">*</span> request = [MJBodyRequest requestWithMethod:RequestMethod_Post api:<span class="comment">@"xxx/yyy" bodies:array];</span></div><div class="line">        </div><div class="line">[client sendRequest:request onResponse:^(MJResponse <span class="keyword">*</span>responseObject) {</div><div class="line">     //数据处理   </div><div class="line">} onError:^(MJHttpError <span class="keyword">*</span>responseError) {</div><div class="line">     NSLog(<span class="comment">@"%@",responseError.errorDescription);</span></div><div class="line">}];</div></pre></td></tr></table></figure>

<h4 id="Multipart请求">Multipart请求</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="type">MJHttpClient</span>* client = [<span class="type">MJHttpClient</span> client];</div><div class="line"><span class="type">MJMultipartData</span>* <span class="typedef"><span class="keyword">data</span> = [<span class="type">MJMultipartData</span> new];</span></div><div class="line"><span class="typedef"><span class="keyword">data</span>.fileData = <span class="type">UIImagePNGRepresentation</span><span class="container">(<span class="title">image</span>)</span>;</span></div><div class="line"><span class="typedef"><span class="keyword">data</span>.name = @"file";</span></div><div class="line"><span class="typedef"><span class="keyword">data</span>.fileName = @"boris.png";</span></div><div class="line"><span class="typedef"><span class="keyword">data</span>.fileType = @"image/png";</span></div><div class="line">    </div><div class="line"><span class="type">MJMultipartRequest</span>* request = [<span class="type">MJMultipartRequest</span> requestWithMethod:<span class="type">RequestMethod_Post</span> api:@<span class="string">"xxx/yyy"</span> datas:@[<span class="typedef"><span class="keyword">data</span>]];</span></div><div class="line">[client sendRequest:request onResponse:^(<span class="type">MJResponse</span> *responseObject) {</div><div class="line">    //数据处理 </div><div class="line">} onError:^(<span class="type">MJHttpError</span> *responseError) {</div><div class="line">    <span class="type">NSLog</span>(@<span class="string">"%@"</span>,responseError.errorDescription);</div><div class="line">}];</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="背景和目标">背景和目标</h2>
<p>目前市场上的大部分App都有网络功能，而网络功能大部分都是基于HTTP协议的。HTTP协议简单而又强大，这也是该协议长盛不衰的秘诀之一。每一个程序员都最好了解一下HTTP协议，这会让你受益匪浅。</p>
<ul>
<li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html" target="_blank" rel="external">协议规范(英)</a></li>
<li><a href="http://javadocs.wikidot.com/hypertext-transfer-protocol-http1-1" target="_blank" rel="external">协议规范(中)</a></li>
</ul>
<p>回到iOS，我们将如何使用HTTP协议来完成网络请求呢？从头开始开发一个协议栈是重复造轮子，非常不明智。因为苹果的开发框架中已经包含了对HTTP协议的封装。<a href="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/WorkingWithHTTPAndHTTPSRequests/WorkingWithHTTPAndHTTPSRequests.html" target="_blank" rel="external">请看官方文档说明</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/16632-bc2417c93684ed68.gif" alt="network.gif"><br>]]>
    
    </summary>
    
      <category term="网络" scheme="http://linkageios.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS代码中的不良实践与优化]]></title>
    <link href="http://linkageios.github.io/2014/10/11/iOS%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E4%B8%8D%E8%89%AF%E5%AE%9E%E8%B7%B5%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://linkageios.github.io/2014/10/11/iOS代码中的不良实践与优化/</id>
    <published>2014-10-11T09:32:00.000Z</published>
    <updated>2014-11-18T10:29:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="不良实践的根源">不良实践的根源</h2>
<ul>
<li>项目时间紧，没有时间去思考更好的写法</li>
<li>认为花精力去优化代码结构不值得</li>
</ul>
<p>第一种原因，一般是因为经验不足，通过学习，任何人都可以很本能的写出结构良好的代码。至于时间确实很紧，后面总会重构的时间。</p>
<p>第二种原因，我觉得要分项目看。如果只是第一个试水版本，没有问题。但是作为一个长久项目，千万不能抱有这种观点。不仅害己，更是害人。</p>
<p>最近做了一个项目，由于种种原因，我们的代码有很多问题。因为正在做重构，所以就把一些不良的实践总结出来。希望对大家有所帮助。</p>
<p><a id="more"></a></p>
<h2 id="不良实践的根源-1">不良实践的根源</h2>
<ul>
<li>项目时间紧，没有时间去思考更好的写法</li>
<li>认为花精力去优化代码结构不值得</li>
</ul>
<p>第一种原因，一般是因为经验不足，通过学习，任何人都可以很本能的写出结构良好的代码。至于时间确实很紧，后面总会重构的时间。</p>
<p>第二种原因，我觉得要分项目看。如果只是第一个试水版本，没有问题。但是作为一个长久项目，千万不能抱有这种观点。不仅害己，更是害人。</p>
<p>最近做了一个项目，由于种种原因，我们的代码有很多问题。因为正在做重构，所以就把一些不良的实践总结出来。希望对大家有所帮助。</p>
<h2 id="不良实践1：控制变量的滥用">不良实践1：控制变量的滥用</h2>
<p>控制变量，一般以XXflag的形式出现在代码中，其作用就是处理各种变化的条件。产品经理写需求往往是从人的角度说的，会对某种行为加上很多条件。这种复杂的限制转换到代码中就变成了一堆的控制变量。当你的代码中充斥着许多零散的flag，就好像打满补丁衣服，让人看着很难受。比如下面的代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated</div><div class="line">{</div><div class="line">    [<span class="keyword">super</span> viewWillAppear:<span class="literal">YES</span>];</div><div class="line">    [[AppDelegate appDelegate]hideTabbar:<span class="literal">YES</span>];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (refreshFlag == <span class="literal">NO</span>)</div><div class="line">    {</div><div class="line">        refreshFlag = <span class="literal">YES</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">else</span></div><div class="line">    {</div><div class="line">        <span class="keyword">self</span><span class="variable">.currentPage</span> = <span class="number">0</span>;</div><div class="line">        [_data removeAllObjects];</div><div class="line">        [<span class="keyword">self</span> getCarsList];</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated</div><div class="line">{</div><div class="line">    [<span class="keyword">super</span> viewWillDisappear:<span class="literal">YES</span>];</div><div class="line">    </div><div class="line">    [[AppDelegate appDelegate]hideTabbar:<span class="literal">NO</span>];</div><div class="line">    refreshFlag = <span class="literal">NO</span>;</div><div class="line">}</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated</div><div class="line">{</div><div class="line">    refreshFlag = <span class="literal">YES</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码取自于项目中的某个类，这里面已经出现了n次reflashFlag，而且这个类的其他地方还有出现。顾名思义，这是为了控制这个页面是否要从后台重新获取数据。但是在实际测试中，我发现了一些问题，想改却无从下手。这就好像地心说的百衲衣，每次发现新的星体，就要从头开始把所有的轨道都算一遍，累都累死了。而日心说通过简单的公式就能覆盖所有的星体。可见，正确的解决方式都是简单的，搞得太复杂，肯定从一开始就错了。</p>
<p>回到当前这个问题，为什么要加个刷新呢？那得从需求说起，当前页面是一个我的汽车列表页面，可能会有多辆车。点击其中某辆车就可以进行编辑。编辑完成之后回到上一个页面（我的汽车列表页面）就需要刷新。最开始实现的时候，在viewWillAppear里面每次都调一下后台请求。但是后来加了滑动返回，当从编辑页面往回退时，其实用户还没真正返回，后台请求就发出了。于是乎，就加了refreshFlag来进行控制。</p>
<p>仔细思考这个问题，刷新的真正原因和实现的代码完全是不对等的。是用户更新了汽车信息才需要刷新，而不是返回需要刷新。这时，我们又遇到了新的问题：类和类之间如何通信。因为刷新是在类A中发生的，而更新内容是在类B中发生的。这种情况下，我觉得用通知是最佳实践。如果内容更新，类B就抛出一个通知。A的接收函数更新标志位（是的，还是会出现flag，但只会出现两次，很容易控制）。然后再viewWillAppear的时候根据标志位进行刷新。这样逻辑就比较顺，bug就相对少一些。</p>
<p>PS：类与类之间还有加引用、Delegate、KVO等通信方式，为什么不用？</p>
<h2 id="不良实践2：同一个类中代码重复出现">不良实践2：同一个类中代码重复出现</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">- (<span class="type">void</span>)getCode</div><div class="line">{</div><div class="line">    [self hideKeyBord];</div><div class="line">    <span class="keyword">if</span> (tfTelNumber.text == <span class="keyword">nil</span> || [tfTelNumber.text isEqualToString:@<span class="string">""</span>]) {</div><div class="line">        showErroMsg(@<span class="string">"请输入手机号"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(![<span class="type">CommonMethod</span> validateMobile:tfTelNumber.text]){</div><div class="line">        showErroMsg(@<span class="string">"手机号码不正确"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="type">MBProgressHUD</span>* hudProgress;</div><div class="line">    __block <span class="type">int</span> <span class="literal">result</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (viewFlag == <span class="number">1</span>)</div><div class="line">    {</div><div class="line">        hudProgress = [[<span class="type">MBProgressHUD</span> alloc] initWithWindow:[<span class="type">UIApplication</span> sharedApplication].keyWindow];</div><div class="line">        [self.view addSubview:hudProgress];</div><div class="line">        [self.view bringSubviewToFront:hudProgress];</div><div class="line">        hudProgress.labelText = @<span class="string">"正在获取验证码..."</span>;</div><div class="line">        </div><div class="line">        <span class="type">APIPackageCheckCodeGoHeader</span> *goHead = [[<span class="type">APIPackageCheckCodeGoHeader</span> alloc]init];</div><div class="line">        <span class="type">APIPackageCheckCodeBackHeader</span> *backHead = [[<span class="type">APIPackageCheckCodeBackHeader</span> alloc]init];</div><div class="line">        goHead.phone = tfTelNumber.text;</div><div class="line">        goHead.<span class="keyword">type</span> = @<span class="string">"2"</span>;</div><div class="line"></div><div class="line">        [goHead makeDictionary];</div><div class="line">        <span class="type">NSMutableDictionary</span> *dicBack = [[<span class="type">NSMutableDictionary</span> alloc]init];</div><div class="line">        [hudProgress showAnimated:<span class="type">YES</span> whileExecutingBlock:^{</div><div class="line">            //        调用接口方法</div><div class="line">            <span class="literal">result</span> = [<span class="type">GMPostServer</span> <span class="type">GetServerBack</span>:<span class="type">SERVER_CHECKCODE</span> path_Param:<span class="keyword">nil</span> query_Param:goHead.dicGo body_Param:<span class="keyword">nil</span> <span class="keyword">method</span>:<span class="type">GM_NETWORK_METHOD_GET</span> returnValue:dicBack];</div><div class="line">            [backHead getBodyDataItems:dicBack];</div><div class="line">        </div><div class="line">            </div><div class="line">        }completionBlock:^{</div><div class="line">            <span class="keyword">if</span> (<span class="literal">result</span> == <span class="type">GM_NETWORK_NULL_BACK</span>)</div><div class="line">            {</div><div class="line">                _timeCount = [kTimeCount intValue];</div><div class="line">                self.btGetCode.enabled = <span class="type">NO</span>;</div><div class="line">                [self.btGetCode setTitle:[<span class="type">NSString</span> stringWithFormat:@<span class="string">"%d秒后重发"</span>,_timeCount] forState:<span class="type">UIControlStateDisabled</span>];</div><div class="line">                self.timerGetCode = [<span class="type">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:self selector:@selector(countDown) userInfo:<span class="keyword">nil</span> repeats:<span class="type">YES</span>];</div><div class="line">            }</div><div class="line">            <span class="keyword">else</span></div><div class="line">            {</div><div class="line">                showErroMsg(backHead.errorMsg);</div><div class="line">            }</div><div class="line">        }];</div><div class="line">        </div><div class="line">    }</div><div class="line">    <span class="keyword">else</span></div><div class="line">    {</div><div class="line">        hudProgress = [[<span class="type">MBProgressHUD</span> alloc] initWithWindow:[<span class="type">UIApplication</span> sharedApplication].keyWindow];</div><div class="line">        [self.view addSubview:hudProgress];</div><div class="line">        [self.view bringSubviewToFront:hudProgress];</div><div class="line">        hudProgress.labelText = @<span class="string">"正在获取验证码..."</span>;</div><div class="line">        </div><div class="line">        <span class="type">APIPackageCheckCodeGoHeader</span> *goHead = [[<span class="type">APIPackageCheckCodeGoHeader</span> alloc]init];</div><div class="line">        <span class="type">APIPackageCheckCodeBackHeader</span> *backHead = [[<span class="type">APIPackageCheckCodeBackHeader</span> alloc]init];</div><div class="line">        goHead.phone = tfTelNumber.text;</div><div class="line">        goHead.<span class="keyword">type</span> = @<span class="string">"1"</span>;</div><div class="line">        </div><div class="line">        [goHead makeDictionary];</div><div class="line">        <span class="type">NSMutableDictionary</span> *dicBack = [[<span class="type">NSMutableDictionary</span> alloc]init];</div><div class="line">        [hudProgress showAnimated:<span class="type">YES</span> whileExecutingBlock:^{</div><div class="line">            //        调用接口方法</div><div class="line">            <span class="literal">result</span> = [<span class="type">GMPostServer</span> <span class="type">GetServerBack</span>:<span class="type">SERVER_CHECKCODE</span> path_Param:<span class="keyword">nil</span> query_Param:goHead.dicGo body_Param:<span class="keyword">nil</span> <span class="keyword">method</span>:<span class="type">GM_NETWORK_METHOD_GET</span> returnValue:dicBack];</div><div class="line">            [backHead getBodyDataItems:dicBack];</div><div class="line">            </div><div class="line">            </div><div class="line">        }completionBlock:^{</div><div class="line">            <span class="keyword">if</span> (<span class="literal">result</span> == <span class="type">GM_NETWORK_NULL_BACK</span>)</div><div class="line">            {</div><div class="line">                _timeCount = [kTimeCount intValue];</div><div class="line">                self.btGetCode.enabled = <span class="type">NO</span>;</div><div class="line">                [self.btGetCode setTitle:[<span class="type">NSString</span> stringWithFormat:@<span class="string">"%d秒后重发"</span>,_timeCount] forState:<span class="type">UIControlStateDisabled</span>];</div><div class="line">                self.timerGetCode = [<span class="type">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:self selector:@selector(countDown) userInfo:<span class="keyword">nil</span> repeats:<span class="type">YES</span>];</div><div class="line">            }</div><div class="line">            <span class="keyword">else</span></div><div class="line">            {</div><div class="line">                showErroMsg(backHead.errorMsg);</div><div class="line">            }</div><div class="line">        }];</div><div class="line">        </div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面这个函数就是发送一个请求，请求根据状态不同分成两种情况。这里有两个问题：</p>
<ul>
<li>函数较长，100行</li>
<li>代码重复，if/else里面的代码基本一样</li>
</ul>
<p>这里的解决方法显而易见，给函数加一个参数，然后请求的参数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">goHead.<span class="built_in">type</span> = @<span class="string">"1"</span>;</div></pre></td></tr></table></figure>

<p>根据函数参数来确定，请求过程只需要写一边即可。这里的重复代码去起来比较简单，有些地方会有一些牵扯（尤其是前文提到的控制变量，这是并发症），但都是可以解决的，最多分几步解决（先解决控制变量，在解决重复代码）。</p>
<h2 id="不良实践3：不同类中重复代码">不良实践3：不同类中重复代码</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([<span class="constant">LCStringUtil</span> <span class="symbol">isBlankString:</span><span class="keyword">self</span>.changedphoneNumfield.text]||[<span class="constant">LCStringUtil</span> <span class="symbol">isBlankString:</span><span class="keyword">self</span>.orignphoneNumfield.text]) {</div><div class="line">     showErroMsg(@<span class="string">"号码不能为空!"</span>);</div><div class="line">     <span class="keyword">return</span>;</div><div class="line"> }</div><div class="line"> <span class="keyword">if</span> ([<span class="keyword">self</span>.changedphoneNumfield.text <span class="symbol">isEqualToString:</span><span class="keyword">self</span>.orignphoneNumfield.text]) {</div><div class="line">     showErroMsg(@<span class="string">"号码不能相同"</span>);</div><div class="line">     <span class="keyword">return</span>;</div><div class="line"> }</div><div class="line"> <span class="keyword">if</span> (![<span class="constant">CommonMethod</span> <span class="symbol">validateMobile:</span><span class="keyword">self</span>.changedphoneNumfield.text]) {</div><div class="line">     showErroMsg(@<span class="string">"请输入正确的新手机号"</span>);</div><div class="line">     <span class="keyword">return</span>;</div><div class="line"> }</div></pre></td></tr></table></figure>

<p>以上这段代码是对手机号码做合理性验证的，在好几个类里面反复出现。除了代码重复，更大的问题是不一致性。这个页面做了两个条件的判断，那个页面做了三个条件的判断，提示语又有可能不一样，这些全都是bug。</p>
<p>处理这个问题，需要有一个验证类，处理各种验证：验证电话号码、密码……然后创建验证对象，调用一下就可以了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">TextValidator*  validator </span>=<span class="string">  [TextValidator new];</span></div><div class="line">[validator isValidPhoneNumber];</div></pre></td></tr></table></figure>

<p>不同类中的重复代码有些也可以放在基类中，如下面的代码，定制导航栏的title，在此不作详细解释。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//添加标题</div><div class="line">- (void)addTitle:(NSString*)titleStr{</div><div class="line">    </div><div class="line">    UILabel *<span class="variable">lblbartitle =</span> [[UILabel alloc] initWithFrame:CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">44</span>)];</div><div class="line">    lblbartitle.<span class="variable">text =</span> NSLocalizedString(titleStr, nil);</div><div class="line">    lblbartitle.<span class="variable">textColor =</span> LCRGBColor(<span class="number">61</span>, <span class="number">66</span>, <span class="number">69</span>);</div><div class="line">    lblbartitle.<span class="variable">center =</span> CGPointMake(SCREEN_WIDTH/<span class="number">2</span>, <span class="number">44</span>);</div><div class="line">    lblbartitle.<span class="variable">textAlignment =</span> NSTextAlignmentCenter;</div><div class="line">    lblbartitle.<span class="variable">font =</span> [HSGBFONT systemFontOfSize:<span class="number">20</span>];</div><div class="line">    lblbartitle.<span class="variable">backgroundColor =</span> [UIColor clearColor];</div><div class="line">    self.navigationItem.<span class="variable">titleView =</span> lblbartitle;</div><div class="line">    </div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="不良实践4：劳模函数">不良实践4：劳模函数</h2>
<p>一个人如果是多面手，那值得表扬；一个函数做多件事情，就有问题。看看下面的代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line">- (void)requestCarList</div><div class="line">{</div><div class="line">    [arrayCar removeAllObjects];</div><div class="line">    </div><div class="line">    APIPackageGetCarListGoHeader *<span class="variable">goQueryHeader =</span> [[APIPackageGetCarListGoHeader alloc] init];</div><div class="line">    goQueryHeader.<span class="variable">page =</span> @<span class="string">"0"</span>;</div><div class="line">    goQueryHeader.<span class="variable">size =</span> @<span class="string">"100"</span>;</div><div class="line">    </div><div class="line">    [goQueryHeader makeDictionary];</div><div class="line">    </div><div class="line">    __block NSInteger <span class="variable">result =</span> <span class="number">0</span>;</div><div class="line">    APIPackageGetCarListBackHeader *<span class="variable">backHeader =</span> [[APIPackageGetCarListBackHeader alloc] init];</div><div class="line">    NSMutableDictionary *<span class="variable">dicBack =</span> [[NSMutableDictionary alloc] init];</div><div class="line">    MBProgressHUD *<span class="variable">hud =</span> [[MBProgressHUD alloc] initWithWindow:[AppDelegate appDelegate].window];</div><div class="line">    hud.<span class="variable">labelText =</span> @<span class="string">"正在查询车辆列表，请稍候..."</span>;</div><div class="line">    [[[AppDelegate appDelegate] window] addSubview:hud];</div><div class="line">    [hud showAnimated:YES whileExecutingBlock:^{</div><div class="line">        <span class="variable">result =</span> [GMPostServer GetServerBack:SERVER_GETCARLIST path_Param:nil query_Param:goQueryHeader.dicGo body_Param:nil method:GM_NETWORK_METHOD_GET returnValue:dicBack];</div><div class="line">    }completionBlock:^{</div><div class="line">        [hud removeFromSuperview];</div><div class="line">        [backHeader getBodyDataItems:dicBack];</div><div class="line">        <span class="keyword">if</span> (<span class="variable">result =</span>= GM_POSTBACK_SUCCESS)</div><div class="line">        {</div><div class="line">            [arrayCar addObjectsFromArray:backHeader.pageInfo.content];</div><div class="line">            </div><div class="line">            pageController.<span class="variable">alpha =</span> arrayCar.count&gt;<span class="number">3</span>?<span class="number">1</span>:<span class="number">0</span>;</div><div class="line"></div><div class="line">            int <span class="variable">intNum =</span> [backHeader.pageInfo.content count]/<span class="number">3</span>+([backHeader.pageInfo.content count]%<span class="number">3</span> == <span class="number">0</span>?<span class="number">0</span>:<span class="number">1</span>);</div><div class="line">            scrollCar.<span class="variable">contentSize =</span> CGSizeMake((SCREEN_WIDTH+<span class="number">1</span>)*intNum, <span class="number">50</span>);</div><div class="line">            pageController.<span class="variable">numberOfPages =</span> intNum;</div><div class="line">            </div><div class="line">            //imageSelect.<span class="variable">hidden =</span> NO;</div><div class="line">            </div><div class="line">            [self removeAllSubViews:scrollCar];</div><div class="line">            </div><div class="line">            //画上部车辆按钮</div><div class="line">            </div><div class="line">            CGRect <span class="variable">imageViewCarRect =</span> CGRectMake(<span class="number">25</span>, IS_INCH_4?<span class="number">12</span>:<span class="number">10</span>, <span class="number">57</span>, <span class="number">22</span>);</div><div class="line">            CGRect <span class="variable">labelCarRect =</span> CGRectMake(<span class="number">0</span>, IS_INCH_4?<span class="number">44</span>:<span class="number">37</span>, <span class="number">106</span>, <span class="number">14</span>);</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (arrayCar.count &gt;<span class="number">0</span>) {</div><div class="line">                for (int <span class="variable">i=</span><span class="number">0</span>;i&lt;[arrayCar count];i++)</div><div class="line">                {</div><div class="line">                    APIPackageGetCarListBackHeader_content *<span class="variable">item =</span> (APIPackageGetCarListBackHeader_content*)[arrayCar objectAtIndex:i];</div><div class="line">                    </div><div class="line">                    UIButton *<span class="variable">btnCar =</span> [UIButton buttonWithType:UIButtonTypeCustom];</div><div class="line">                    btnCar.<span class="variable">frame =</span> CGRectMake(<span class="number">107</span>*i, <span class="number">0</span>, <span class="number">106</span>, CarScorllHeight);</div><div class="line">                    btnCar.<span class="variable">backgroundColor =</span> [UIColor clearColor];</div><div class="line">                    [btnCar addTarget:self action:@selector(selectCar:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">                    btnCar.<span class="variable">tag =</span> i;</div><div class="line">                    [scrollCar addSubview:btnCar];</div><div class="line">                    </div><div class="line">                    UIImageView *<span class="variable">imageViewCar =</span> [[UIImageView alloc] initWithFrame:imageViewCarRect];</div><div class="line">                    <span class="keyword">if</span> (<span class="variable">i =</span>= <span class="number">0</span>)</div><div class="line">                    {</div><div class="line">                        <span class="variable">selectCar =</span> <span class="number">0</span>;</div><div class="line">                        [imageViewCar setImage:[UIImage imageNamed:@<span class="string">"carIcon"</span>]];</div><div class="line">                    }</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                    {</div><div class="line">                        [imageViewCar setImage:[UIImage imageNamed:@<span class="string">"car_touch_no.png"</span>]];</div><div class="line">                    }</div><div class="line">                    [btnCar addSubview:imageViewCar];</div><div class="line">                    imageViewCar.<span class="variable">tag =</span> i+<span class="number">100</span>;</div><div class="line">                    </div><div class="line">                    UILabel *<span class="variable">labelCar =</span> [[UILabel alloc] init];</div><div class="line">                    labelCar.<span class="variable">frame =</span> labelCarRect;</div><div class="line">                    labelCar.<span class="variable">backgroundColor =</span> [UIColor clearColor];</div><div class="line">                    <span class="keyword">if</span> (<span class="variable">i =</span>= <span class="number">0</span>)</div><div class="line">                    {</div><div class="line">                        labelCar.<span class="variable">textColor =</span> LCRGBColor(<span class="number">214</span>, <span class="number">62</span>, <span class="number">37</span>);</div><div class="line">                    }</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                    {</div><div class="line">                        labelCar.<span class="variable">textColor =</span> LCRGBColor(<span class="number">105</span>, <span class="number">105</span>, <span class="number">105</span>);</div><div class="line">                    }</div><div class="line">                    </div><div class="line">                    labelCar.<span class="variable">textAlignment =</span> NSTextAlignmentCenter;</div><div class="line">                    labelCar.<span class="variable">font =</span> [HSGBFONT systemFontOfSize:<span class="number">14</span>];</div><div class="line">                    labelCar.<span class="variable">text =</span> [NSString stringWithFormat:@<span class="string">"%@ %@"</span>,[LCStringUtil isBlankString:item.carBrand]?@<span class="string">""</span>:item.carBrand,[LCStringUtil isBlankString:item.carSeries]?@<span class="string">""</span>:item.carSeries];</div><div class="line">                    labelCar.<span class="variable">tag =</span> i+<span class="number">200</span>;</div><div class="line">                    [btnCar addSubview:labelCar];</div><div class="line">                    </div><div class="line">                    UIImageView *<span class="variable">imageLine =</span> [[UIImageView alloc] initWithFrame:CGRectMake(<span class="number">106</span>+<span class="number">107</span>*i, <span class="number">0</span>, <span class="number">1</span> / [UIScreen mainScreen].scale, CarScorllHeight)];</div><div class="line">                    imageLine.<span class="variable">backgroundColor =</span> LCRGBColor(<span class="number">211</span>, <span class="number">211</span>, <span class="number">211</span>);</div><div class="line">                    [scrollCar addSubview:imageLine];</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                UIButton *<span class="variable">btnCar =</span> [UIButton buttonWithType:UIButtonTypeCustom];</div><div class="line">                btnCar.<span class="variable">frame =</span> CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">106</span>, CarScorllHeight);</div><div class="line">                btnCar.<span class="variable">backgroundColor =</span> [UIColor clearColor];</div><div class="line">                [btnCar addTarget:self action:@selector(selectCar:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">                btnCar.<span class="variable">tag =</span> -<span class="number">1</span>;</div><div class="line">                [scrollCar addSubview:btnCar];</div><div class="line">                </div><div class="line">                UIImageView *<span class="variable">imageViewCar =</span> [[UIImageView alloc] initWithFrame:imageViewCarRect];</div><div class="line">                [imageViewCar setImage:[UIImage imageNamed:@<span class="string">"jiajiacheliang"</span>]];</div><div class="line">                [btnCar addSubview:imageViewCar];</div><div class="line">                </div><div class="line">                UILabel *<span class="variable">labelCar =</span> [[UILabel alloc] init];</div><div class="line">                labelCar.<span class="variable">frame =</span> labelCarRect;</div><div class="line">                labelCar.<span class="variable">backgroundColor =</span> [UIColor clearColor];</div><div class="line">                labelCar.<span class="variable">textColor =</span> LCRGBColor(<span class="number">105</span>, <span class="number">105</span>, <span class="number">105</span>);</div><div class="line">                labelCar.<span class="variable">textAlignment =</span> NSTextAlignmentCenter;</div><div class="line">                labelCar.<span class="variable">font =</span> [HSGBFONT systemFontOfSize:<span class="number">14</span>];</div><div class="line">                labelCar.<span class="variable">text =</span> @<span class="string">"添加车辆"</span>;</div><div class="line">                [btnCar addSubview:labelCar];</div><div class="line">                </div><div class="line">                UIImageView *<span class="variable">imageLine =</span> [[UIImageView alloc] initWithFrame:CGRectMake(<span class="number">106</span>, <span class="number">0</span>, <span class="number">1</span> / [UIScreen mainScreen].scale, CarScorllHeight)];</div><div class="line">                imageLine.<span class="variable">backgroundColor =</span> LCRGBColor(<span class="number">211</span>, <span class="number">211</span>, <span class="number">211</span>);</div><div class="line">                [scrollCar addSubview:imageLine];</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span></div><div class="line">        {</div><div class="line">            [self.navigationController popViewControllerAnimated:YES];</div><div class="line">            showErroMsg(backHeader.errorMsg);</div><div class="line">        }</div><div class="line">    }];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>看函数名就是请求汽车列表，但是实现代码除了请求，还有一大块的创建UI。这部分代码完全可以再创建一个函数来实现。<br>任何时候，设计良好的函数只做一件事情。</p>
<h2 id="不良实践5：劳模类">不良实践5：劳模类</h2>
<p>劳模类就是毫不相关的函数一起出现的地方，最常见的就是单例类，最明显的就是AppDelegate。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>autologin :<span class="params">(<span class="variable">NSDictionary</span> *)</span>launchOptions</span></div><div class="line">- <span class="params">(<span class="variable">BOOL</span>)</span>intervalSinceNowThanOneHour: <span class="params">(<span class="variable">NSString</span> *)</span> theDate</div><div class="line">- <span class="params">(void)</span>requestUserInfo</div><div class="line">- <span class="params">(void)</span>showFaildMsg:<span class="params">(<span class="variable">NSString</span>*)</span>msg</div><div class="line">.......</div></pre></td></tr></table></figure>

<p>上面的函数功能五花八门，因为图方便，放在AppDelegate中。开了不好的头，后面的开发者就会源源不断往里面加函数。现在第一个版本就已经500+行，那么后面的扩张就可想而知了。<br>单例作为一种设计模式，有其存在的意义。但因为没有严格的限制，很多人把它当做了全局变量在用。在面向对象的世界中，全局变量都是老鼠屎般的存在，必须清除干净。<br>任何时候，设计良好的类只做一类事情。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="不良实践的根源">不良实践的根源</h2>
<ul>
<li>项目时间紧，没有时间去思考更好的写法</li>
<li>认为花精力去优化代码结构不值得</li>
</ul>
<p>第一种原因，一般是因为经验不足，通过学习，任何人都可以很本能的写出结构良好的代码。至于时间确实很紧，后面总会重构的时间。</p>
<p>第二种原因，我觉得要分项目看。如果只是第一个试水版本，没有问题。但是作为一个长久项目，千万不能抱有这种观点。不仅害己，更是害人。</p>
<p>最近做了一个项目，由于种种原因，我们的代码有很多问题。因为正在做重构，所以就把一些不良的实践总结出来。希望对大家有所帮助。</p>
<p>]]>
    
    </summary>
    
      <category term="代码优化" scheme="http://linkageios.github.io/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARC转换总结+避免循环引用]]></title>
    <link href="http://linkageios.github.io/2014/09/25/ARC%E8%BD%AC%E6%8D%A2%E6%80%BB%E7%BB%93+%E9%81%BF%E5%85%8D%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/"/>
    <id>http://linkageios.github.io/2014/09/25/ARC转换总结+避免循环引用/</id>
    <published>2014-09-25T02:02:00.000Z</published>
    <updated>2014-11-18T10:28:40.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.hrchen.com/2013/07/arc-transfer-and-notice/" target="_blank" rel="external">参考</a></p>
<p>上面的文章写得已经非常全面了，不过还是有些东西需要补充一下。</p>
<h2 id="循环引用">循环引用</h2>
<p>循环引用和ARC没有直接关系，但是在转换的过程中遇到了相关问题，所以就着重说明一下。</p>
<h3 id="循环引用的原因">循环引用的原因</h3>
<p>任何一种语言，都必须有它的内存管理方式。比如C语言中，我们用malloc申请一块内存，放入数据。当这块内存不在需要时，就调用free将其释放掉。这是一种比较原始的方式，当同一块内存在多个地方被用到时，到底应该由谁来释放呢？你只能小心翼翼的处理这种问题，除此之外没有别的办法。<br><a id="more"></a></p>
<p><a href="http://www.hrchen.com/2013/07/arc-transfer-and-notice/" target="_blank" rel="external">参考</a></p>
<p>上面的文章写得已经非常全面了，不过还是有些东西需要补充一下。</p>
<h2 id="循环引用-1">循环引用</h2>
<p>循环引用和ARC没有直接关系，但是在转换的过程中遇到了相关问题，所以就着重说明一下。</p>
<h3 id="循环引用的原因-1">循环引用的原因</h3>
<p>任何一种语言，都必须有它的内存管理方式。比如C语言中，我们用malloc申请一块内存，放入数据。当这块内存不在需要时，就调用free将其释放掉。这是一种比较原始的方式，当同一块内存在多个地方被用到时，到底应该由谁来释放呢？你只能小心翼翼的处理这种问题，除此之外没有别的办法。</p>
<p>Objective-C相较于C的一大优势就是内存管理，提出了引用计数的概念。引用计数是针对对象的，即NSObject，不是NSObject就没必要谈引用计数。</p>
<p>在Objective-C中，凡是继承自NSObject的类都提供了两个方法，retain和release。当我们调用一个对象的retain时，这个对象的内存计数加1；反之，当我们调用release时， 对象的内存计数减1，只有当对象内存计数为0时，这个对象才真正会被释放，此时，对象的delloc方法会自动被调用，来做些内存回收前的工作。</p>
<p>那么问题就来了。比如有A和B两个对象，A持有B，B同时也持有A，按照上面的规则，A只有B释放之后才有可能释放，同样B只有A释放后才可能释放，当双方都在等待对方释放的时候， 循环引用就形成了。两个对象都永远不会被释放，这样就造成内存泄露。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ARC code</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">A</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) B* b;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">B</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) A* a;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>解决办法也很简单，只要不让A和B同时保持对方的强引用即可。 注意，B对A的引用是weak。知道为什么我们要把Delegate对象设成weak了吧？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ARC code</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">A</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) B* b;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">B</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>) A* a;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<h3 id="当Block遇到ARC">当Block遇到ARC</h3>
<p>Block的概念这里就不详细解释了。我想说的是，Block就是一个对象，它能访问上下文变量，这就要保证上下文所属的对象在Block运行时必须不被释放，所以Block默认会对当前上下文进行强引用。这时如果当前对象也对Block有强引用，那么就会造成循环引用。比如下面的代码，self强引用tableView，tableView强引用block；block又强引用self，所以问题就产生了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span><span class="variable">.tableView</span> addPullToRefreshWithActionHandler:^{</div><div class="line">       <span class="keyword">self</span><span class="variable">.isRefresh</span> = <span class="literal">YES</span>;</div><div class="line">       <span class="keyword">self</span><span class="variable">.hideHud</span> = <span class="literal">YES</span>;</div><div class="line">       <span class="keyword">self</span><span class="variable">.currentPage</span> = <span class="number">0</span>;</div><div class="line">       [<span class="keyword">self</span> queryCarFault];</div><div class="line">   }];</div></pre></td></tr></table></figure>

<p>如何破局，ARC之后有一个__weak的关键字。这样Block就不会强引用BBWarningRecordTableViewController的对象了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__<span class="keyword">weak</span> BBWarningRecordTableViewController* weakSelf = <span class="keyword">self</span>;</div><div class="line">    [<span class="keyword">self</span><span class="variable">.tableView</span> addPullToRefreshWithActionHandler:^{</div><div class="line">        weakSelf<span class="variable">.isRefresh</span> = <span class="literal">YES</span>;</div><div class="line">        weakSelf<span class="variable">.hideHud</span> = <span class="literal">YES</span>;</div><div class="line">        weakSelf<span class="variable">.currentPage</span> = <span class="number">0</span>;</div><div class="line">        [weakSelf queryCarFault];</div><div class="line">    }];</div></pre></td></tr></table></figure>

<p>从上面的代码可以看到，我们只是加了一行代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__<span class="keyword">weak</span> BBWarningRecordTableViewController* weakSelf = <span class="keyword">self</span>;</div></pre></td></tr></table></figure>

<p>但是有一次我发现类似的语句不止一种<a href="http://www.tuicool.com/articles/bYBB7r" target="_blank" rel="external">写法</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不知道这行代码的使用场景的同学你该去自习看看ARC的注意事项和Block的使用了</span></div><div class="line"><span class="comment">// AFNetworking的写法</span></div><div class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(&*<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</div><div class="line"></div><div class="line"><span class="comment">// 我之前一直这么写的</span></div><div class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</div><div class="line"><span class="comment">// 或者这么写</span></div><div class="line">__<span class="keyword">weak</span> XxxViewController *weakSelf = <span class="keyword">self</span>;</div><div class="line"><span class="comment">// 或者这么写</span></div><div class="line">__<span class="keyword">weak</span> <span class="keyword">id</span> weakSelf = <span class="keyword">self</span>;</div></pre></td></tr></table></figure>

<p>这四种写法居然都是对的，第三种在我看来是最不好的，因为每个地方都要单独写。而其余几种写法都可以封装成一个宏，当项目中很多地方都要写类似代码时，用宏肯定是最佳的实践。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.hrchen.com/2013/07/arc-transfer-and-notice/" target="_blank" rel="external">参考</a></p>
<p>上面的文章写得已经非常全面了，不过还是有些东西需要补充一下。</p>
<h2 id="循环引用">循环引用</h2>
<p>循环引用和ARC没有直接关系，但是在转换的过程中遇到了相关问题，所以就着重说明一下。</p>
<h3 id="循环引用的原因">循环引用的原因</h3>
<p>任何一种语言，都必须有它的内存管理方式。比如C语言中，我们用malloc申请一块内存，放入数据。当这块内存不在需要时，就调用free将其释放掉。这是一种比较原始的方式，当同一块内存在多个地方被用到时，到底应该由谁来释放呢？你只能小心翼翼的处理这种问题，除此之外没有别的办法。<br>]]>
    
    </summary>
    
      <category term="ARC" scheme="http://linkageios.github.io/tags/ARC/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS技术路线图]]></title>
    <link href="http://linkageios.github.io/2014/09/24/iOS%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%9B%BE/"/>
    <id>http://linkageios.github.io/2014/09/24/iOS技术路线图/</id>
    <published>2014-09-24T09:19:00.000Z</published>
    <updated>2014-11-18T10:29:57.000Z</updated>
    <content type="html"><![CDATA[<p>做技术分成好几个层次：</p>
<ul>
<li>第一层：把功能做出来，不用考虑代码质量。</li>
<li>第二层：把功能做稳定，不会有太多的bug。</li>
<li>第三层：把功能做得快，能够快速响应需求。</li>
</ul>
<p>如果是从零开始做项目，迫于经验不足和时间紧迫，都会经历从第一层慢慢向上的过程。遗憾的是，做到第三层是很难的，但不管怎样，追求的过程是充满挑战的，也是受益无穷的。</p>
<p>评价一下我们现在的项目，还应留在第一层。为了能够达到第三层，我和同事们一起想了一些方法和步骤。</p>
<hr>
<p><a id="more"></a><br>做技术分成好几个层次：</p>
<ul>
<li>第一层：把功能做出来，不用考虑代码质量。</li>
<li>第二层：把功能做稳定，不会有太多的bug。</li>
<li>第三层：把功能做得快，能够快速响应需求。</li>
</ul>
<p>如果是从零开始做项目，迫于经验不足和时间紧迫，都会经历从第一层慢慢向上的过程。遗憾的是，做到第三层是很难的，但不管怎样，追求的过程是充满挑战的，也是受益无穷的。</p>
<p>评价一下我们现在的项目，还应留在第一层。为了能够达到第三层，我和同事们一起想了一些方法和步骤。</p>
<hr>
<h3 id="ARC">ARC</h3>
<p>ARC全名Automatic Reference Counting，是苹果公司在WWDC2011上就推出来的一项技术，只在减少程序员的工作，不用再去手动管理内存（典型的费力不讨好），而是由编译器采用智能算法，在编译的时候自动插入内存管理代码。ARC目前已经广泛的被绝大部分开发者所接受，因为它带来了开发效率的提升。我们目前的代码还没有采用ARC，这个改一下不是什么难事，具体做法可参考<a href="https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">官方文档</a>。<br><a id="more"></a><br>做技术分成好几个层次：</p>
<ul>
<li>第一层：把功能做出来，不用考虑代码质量。</li>
<li>第二层：把功能做稳定，不会有太多的bug。</li>
<li>第三层：把功能做得快，能够快速响应需求。</li>
</ul>
<p>如果是从零开始做项目，迫于经验不足和时间紧迫，都会经历从第一层慢慢向上的过程。遗憾的是，做到第三层是很难的，但不管怎样，追求的过程是充满挑战的，也是受益无穷的。</p>
<p>评价一下我们现在的项目，还应留在第一层。为了能够达到第三层，我和同事们一起想了一些方法和步骤。</p>
<hr>
<h3 id="ARC-1">ARC</h3>
<p>ARC全名Automatic Reference Counting，是苹果公司在WWDC2011上就推出来的一项技术，只在减少程序员的工作，不用再去手动管理内存（典型的费力不讨好），而是由编译器采用智能算法，在编译的时候自动插入内存管理代码。ARC目前已经广泛的被绝大部分开发者所接受，因为它带来了开发效率的提升。我们目前的代码还没有采用ARC，这个改一下不是什么难事，具体做法可参考<a href="https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="Xib，StoryBoard">Xib，StoryBoard</h3>
<p>Xib、StoryBoard和纯代码到底哪个好，一直被程序员们<a href="http://www.raywenderlich.com/51992/storyboards-vs-nibs-vs-code-the-great-debate" target="_blank" rel="external">争个不休</a>。但不可否认的是，苹果公司每次更新XCode，界面工具都会不断被优化以方便开发。尤其是分辨率越来越多以后，一些特性如AutoLayout，最佳使用场景就是界面工具，手写AutoLayout是很复杂的。所以我推荐用Xib乃至StoryBoard，但是并不反对用纯代码，因为有些复杂的UI更适合用代码写。三者可以和平共处，并不是非此即彼的关系。</p>
<h3 id="代码规范">代码规范</h3>
<p>这是老生常谈，不多说了，大家都懂的。前些天草拟了<a href="http://www.jianshu.com/p/552974248b8e" target="_blank" rel="external">一份规范</a>。</p>
<h3 id="模块化">模块化</h3>
<p>一个软件，尤其是大中型的软件，肯定有很多相对独立的功能。模块化相当于对大系统进行降维，使开发大系统像开发小功能一样容易。而且，有些模块可以被复用，能提升开发的效率和质量。</p>
<p>我们现在的代码虽然是按照业务功能分开写的，但并没有严格的分开。比如登录相关的逻辑就散布在程序的多个地方，如果把登录做成一个模块，对外提供一组接口，登录逻辑要改就很方便，不用在多个地方改。分模块的要义是抽象出一组接口，模块间的通信只依赖于接口。模块的最终形式是.a文件。</p>
<h3 id="API包装层">API包装层</h3>
<p>在很多公司，前后台不属于同一个部门。后开负责开发基本的API，而前台对于返回的数据进行处理。这种处理有时候是很复杂的，因为后台不关心具体前端需求（或者它要为多平台提供支持），所以提供的数据往往是非常原始的。这样就有三种做法：</p>
<ul>
<li>前台在请求的地方单独处理。</li>
<li>前台有专门的网络层处理。</li>
<li>后台提供一层包装API，将数据进行预处理。</li>
</ul>
<p>目前我们用的是第一种做法，最好的还是第三种做法。</p>
<h3 id="控件">控件</h3>
<p>控件的作用是封装通用的UI组件，写iOS代码大部分时间都是在写UI，所以控件可以大大提高开发速度和质量。<br>网上有很多开源的组件，我们可以参考，但一定要看明白，不能拿来就用，不然风险太大。向UITableView的刷新、RichLabel等等，都需要控件化。</p>
<h3 id="业务逻辑与视图分离">业务逻辑与视图分离</h3>
<p>目前的代码是不分离的，一股脑儿写在ViewController里面。后果就是无法进行单元测试、并且维护性差。分层就可以解决这一问题，业界已经有很多方法：<br><a href="http://www.jianshu.com/p/385138a5daf0" target="_blank" rel="external">MVVM</a><br><a href="http://objccn.io/issue-1/" target="_blank" rel="external">更轻量的 View Controllers</a><br><a href="http://objccn.io/issue-13-5/" target="_blank" rel="external">使用 VIPER 构建 iOS 应用</a></p>
<h3 id="网络层封装">网络层封装</h3>
<p>无论是ASI还是AFNetWork，都已经提供了一套基本的Http框架，我们要做的是在此基础上进行一层包装，调用者只需要了解包装层的接口，这样以后替换类库都不会有问题。</p>
<h3 id="数据层封装">数据层封装</h3>
<p>把数据层抽象出来，这样代用存储代码就会变得很简单。而且数据层扩展各种存储类型，对业务层代码不需要太大的改动。</p>
<h3 id="动画框架">动画框架</h3>
<p>手势返回是必须要做的。<br>至于动画框架还没想清楚，因为动画变化多端，所以对框架的通用性就有很高的要求。如果太通用，就和系统API没什么差别了。<br>这是Facebook推出的<a href="https://code.facebook.com/posts/234067533455773/introducing-pop-the-animation-engine-behind-paper/" target="_blank" rel="external">POP动画框架</a>，值得参考一下。</p>
<h3 id="Bean规范化">Bean规范化</h3>
<p>Bean是程序中最基本的对象。没有业务相关的方法，只有属性和存储方法。每个Bean一个文件，目前是所有Bean在一个文件中，不容易查看。</p>
<h3 id="基类">基类</h3>
<p>无基类，不框架。基类会随着项目的发展不断演进，基类可以让问哦们少些很多很多的代码。</p>
<h3 id="工具类">工具类</h3>
<p>代码规范里也提到，工具类的使用有两种误区：</p>
<ul>
<li>Util方法没有单独写在一个文件里面，不具备重用性。</li>
<li>有一个超级Util类，写了一堆不太相关的方法。</li>
</ul>
<p>能用Category尽量用Category，对于Util，也要按功能进行区分。</p>
<h3 id="分享框架">分享框架</h3>
<p>分享不是一件特别困难的事，所以最好自己做。用第三方定制UI也是很难实现的，还不如自己做。</p>
<hr>
<p>上文提出的种种，都是我们要做的，如果按理想情况做完的话，我们就能达到本文开头所说的第三层境界了。但是过程肯定不轻松，也许会在某一点上失败，但是前进的过程又是充满诱惑的，所以加油吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>做技术分成好几个层次：</p>
<ul>
<li>第一层：把功能做出来，不用考虑代码质量。</li>
<li>第二层：把功能做稳定，不会有太多的bug。</li>
<li>第三层：把功能做得快，能够快速响应需求。</li>
</ul>
<p>如果是从零开始做项目，迫于经验不足和时间紧迫，都会经历从第一层慢慢向上的过程。遗憾的是，做到第三层是很难的，但不管怎样，追求的过程是充满挑战的，也是受益无穷的。</p>
<p>评价一下我们现在的项目，还应留在第一层。为了能够达到第三层，我和同事们一起想了一些方法和步骤。</p>
<hr>
<p><!--more--><br>做技术分成好几个层次：</p>
<ul>
<li>第一层：把功能做出来，不用考虑代码质量。</li>
<li>第二层：把功能做稳定，不会有太多的bug。</li>
<li>第三层：把功能做得快，能够快速响应需求。</li>
</ul>
<p>如果是从零开始做项目，迫于经验不足和时间紧迫，都会经历从第一层慢慢向上的过程。遗憾的是，做到第三层是很难的，但不管怎样，追求的过程是充满挑战的，也是受益无穷的。</p>
<p>评价一下我们现在的项目，还应留在第一层。为了能够达到第三层，我和同事们一起想了一些方法和步骤。</p>
<hr>
<h3 id="ARC">ARC</h3>
<p>ARC全名Automatic Reference Counting，是苹果公司在WWDC2011上就推出来的一项技术，只在减少程序员的工作，不用再去手动管理内存（典型的费力不讨好），而是由编译器采用智能算法，在编译的时候自动插入内存管理代码。ARC目前已经广泛的被绝大部分开发者所接受，因为它带来了开发效率的提升。我们目前的代码还没有采用ARC，这个改一下不是什么难事，具体做法可参考<a href="https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">官方文档</a>。<br>]]>
    
    </summary>
    
      <category term="路线图" scheme="http://linkageios.github.io/tags/%E8%B7%AF%E7%BA%BF%E5%9B%BE/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS架构设计与分层]]></title>
    <link href="http://linkageios.github.io/2014/09/22/iOS%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E5%B1%82/"/>
    <id>http://linkageios.github.io/2014/09/22/iOS架构设计与分层/</id>
    <published>2014-09-22T02:37:00.000Z</published>
    <updated>2014-11-18T10:30:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="结构设计的层次是否越多越好？">结构设计的层次是否越多越好？</h2>
<p>多人都会说，凡事不能走极端，走了极端就过犹不及。所以应该分层，但不能过分分层，应该视具体情况来定。这样的话听起来很有道理，却只是一句废话。当我们遇到问题时，还是摸不着头脑！</p>
<p>看看知名的架构师是怎么说的吧！来自<a href="http://weibo.com/rebol" target="_blank" rel="external">蔡学镛</a></p>
<blockquote>
<p>我做（开发）架构的几个原则，根据优先次序高低排列：1. （逻辑）拆分越细越好 2. 依赖关细越少越好 3. 交互越少越好 … 相互矛盾时，如果没有特殊理由，以优先权高者胜出。</p>
</blockquote>
<p>由此启发，我觉得设计架构应该拆的越细越好。这样做有如下几点好处：</p>
<ul>
<li>对于大中型软件，层次越多，每一层就更单纯，更容易维护。</li>
<li>团队成员只需了解一小部分业务，就能顺利进行开发。</li>
<li>相对底层的模块，可以更好的重用。</li>
<li>层次分的越多，开发者对抽象的理解就更深入。</li>
</ul>
<p>iOS说到分层，有几种常见的做法。</p>
<ul>
<li>按功能分：有MVC，MVVM……</li>
<li>按层次分：有数据层、逻辑层、展现层……</li>
</ul>
<p><a id="more"></a></p>
<h2 id="结构设计的层次是否越多越好？-1">结构设计的层次是否越多越好？</h2>
<p>多人都会说，凡事不能走极端，走了极端就过犹不及。所以应该分层，但不能过分分层，应该视具体情况来定。这样的话听起来很有道理，却只是一句废话。当我们遇到问题时，还是摸不着头脑！</p>
<p>看看知名的架构师是怎么说的吧！来自<a href="http://weibo.com/rebol" target="_blank" rel="external">蔡学镛</a></p>
<blockquote>
<p>我做（开发）架构的几个原则，根据优先次序高低排列：1. （逻辑）拆分越细越好 2. 依赖关细越少越好 3. 交互越少越好 … 相互矛盾时，如果没有特殊理由，以优先权高者胜出。</p>
</blockquote>
<p>由此启发，我觉得设计架构应该拆的越细越好。这样做有如下几点好处：</p>
<ul>
<li>对于大中型软件，层次越多，每一层就更单纯，更容易维护。</li>
<li>团队成员只需了解一小部分业务，就能顺利进行开发。</li>
<li>相对底层的模块，可以更好的重用。</li>
<li>层次分的越多，开发者对抽象的理解就更深入。</li>
</ul>
<p>iOS说到分层，有几种常见的做法。</p>
<ul>
<li>按功能分：有MVC，MVVM……</li>
<li>按层次分：有数据层、逻辑层、展现层……</li>
</ul>
<p>这些分层看起来五花八门，但实质并不冲突。最近读了一篇<a href="http://objccn.io/issue-13-5/" target="_blank" rel="external">文章</a>，深受启发，在其模式的基础上修改了一个自己的架构模式，暂且称之为VPBD。废话不多说，线上架构图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/16632-1c0b49ca52cf24c7.png" alt="VPBD.png"></p>
<p>下面说说各个模块分别干了什么？</p>
<ul>
<li>ViewController(View)：管理View的层次结构、生命周期、一些组合过的View。</li>
<li>ViewModel：负责转换View需要的数据格式。</li>
<li>Presenter：显示View、ViewController的逻辑。</li>
<li>Router(Wireframe)：页面跳转逻辑。</li>
<li>Business：核心业务逻辑，复用性很高。</li>
<li>Model：基本数据模型，根据业务来定义。</li>
<li>DataSource：对于数据的抽象，对于Business层而言，不需要知道它是从网络、数据库还是缓存中得到的。</li>
</ul>
<p>讲模式不能光说不练，所以我决定写一个Demo来实践这一模式。</p>
<p>国庆过来加了3天班，总算写了一个Demo，因为基于目前公司产品的后台，所以代码就不贴了。讲讲思路就好。</p>
<p>最终的版本比上面图中，做了一些妥协，主要是把Presenter和Router拿掉了。因为目前的项目交互都比较简单，而Presenter和Router都是处理交互相关代码的，所以即使写出来代码也很少。下面是结构图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/16632-d2a0af9a682cc160.jpg" alt="VVBD.jpg"></p>
<p>更详细的结构图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/16632-0b362df9cc644327.png" alt="arch.png"></p>
<p>在最早的代码中，ViewController、Business、ViewModel都是写在ViewController里面的，这样迟早是要把ViewController写爆的。为了i面ViewController复杂化，我就把它拆成了3个部分。</p>
<h5 id="ViewController">ViewController</h5>
<p>负责View生命周期的管理、视图跳转、以及用户事件的接收。</p>
<h5 id="Business">Business</h5>
<p>负责所有的业务逻辑，它不需要知道View是怎样的。View需要的数据结构会通过ViewModel来定义，所以Business就是处理逻辑，并把最终数据转换成ViewModel，抛给ViewController即可。这个过程中转换成ViewModel比较简单，最核心的是定义业务逻辑。即这个模块是干嘛的。举个例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HJShopModule</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) HJShopQueryConfig* queryConfig;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span>* currentShopId;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)getShopListOnSuccess:(ResponseArray)successBlock</div><div class="line">                   onFailure:(ResponseString)failureBlock;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)getShopDetailOnSuccess:(ResponseObject)successBlock</div><div class="line">                     onFailure:(ResponseString)failureBlock;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>上面定义的是一个商店模块，就是商店相关的任何逻辑都应该在这里。一个商店模块能干嘛？这需要从需求出发。</p>
<ul>
<li>需求1：通过筛选得到商店列表</li>
<li>需求2：查看商店详情</li>
</ul>
<p>根据以上两个需求，我先把筛选条件封装成一个对象（筛选条件多且复杂），然后调用getShopList方法，该方法会筛选条件解析出来，并向后台请求，请求成功再将数据封装好，丢给ViewController。同理，查看商店详情，同样只需要调用一个接口。这里虽然只写了两个，但是真实情况会有很多接口，比如收藏商店、分享商店……业务需求有多少，这里就要加多少。因为写在这里的方法都差不多，所以可读性、维护性都会比较好。</p>
<h5 id="ViewModel">ViewModel</h5>
<p>我这里的ViewModel和MVVM中的ViewModel不太一样。我这里的ViewModel其实是Model的延伸。我们定义Model的时候是根据业务来定的。而ViewModel是根据View的展示需求来定的。两者只是结构上的不同，并没有本质差异。假如ViewModel会增加一些类，但是ViewController就不用再做繁琐无聊的数据转换了。</p>
<h3 id="总结">总结</h3>
<p>用了这个模式，ViewController得到了很大的简化，但是以后可能还会有复杂化的问题。尤其是当页面的交互逻辑变得复杂的时候。这时候需要把交互再抽象出来，就像最上面的一张图。但目前我觉得这是没有必要的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="结构设计的层次是否越多越好？">结构设计的层次是否越多越好？</h2>
<p>多人都会说，凡事不能走极端，走了极端就过犹不及。所以应该分层，但不能过分分层，应该视具体情况来定。这样的话听起来很有道理，却只是一句废话。当我们遇到问题时，还是摸不着头脑！</p>
<p>看看知名的架构师是怎么说的吧！来自<a href="http://weibo.com/rebol" target="_blank" rel="external">蔡学镛</a></p>
<blockquote>
<p>我做（开发）架构的几个原则，根据优先次序高低排列：1. （逻辑）拆分越细越好 2. 依赖关细越少越好 3. 交互越少越好 … 相互矛盾时，如果没有特殊理由，以优先权高者胜出。</p>
</blockquote>
<p>由此启发，我觉得设计架构应该拆的越细越好。这样做有如下几点好处：</p>
<ul>
<li>对于大中型软件，层次越多，每一层就更单纯，更容易维护。</li>
<li>团队成员只需了解一小部分业务，就能顺利进行开发。</li>
<li>相对底层的模块，可以更好的重用。</li>
<li>层次分的越多，开发者对抽象的理解就更深入。</li>
</ul>
<p>iOS说到分层，有几种常见的做法。</p>
<ul>
<li>按功能分：有MVC，MVVM……</li>
<li>按层次分：有数据层、逻辑层、展现层……</li>
</ul>
<p>]]>
    
    </summary>
    
      <category term="架构" scheme="http://linkageios.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C代码规范]]></title>
    <link href="http://linkageios.github.io/2014/09/16/Objective-C%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://linkageios.github.io/2014/09/16/Objective-C代码规范/</id>
    <published>2014-09-16T09:33:00.000Z</published>
    <updated>2014-11-18T10:31:19.000Z</updated>
    <content type="html"><![CDATA[<h1 id="为什么要有代码规范？">为什么要有代码规范？</h1>
<p>对于团队，如果代码风格不统一，阅读或修改同事的代码会非常困难，造成潜在的风险。</p>
<p>对于个人，代码规范是对自身编码习惯的一种监督，如果没有这种监督，有时候因为偷懒，会写出难看的代码，时间长了自己都看不懂。这样对于代码的维护性是不利的。</p>
<h1 id="代码规范的内容？">代码规范的内容？</h1>
<p>代码规范包含的范围十分广泛。从一个变量的命名到一个类的设计，我觉得都属于代码规范的范畴。从实践的角度，可以把代码规范分成两个部分：</p>
<p>第一部分是规则，即一定要这么做。这里面没有对错，但需要统一。包含变量的命名、函数的命名、模块的组织、代码块的组织、宏、枚举、常量的声明、函数的粒度。</p>
<p>第二部分是风格，即一种模式化的代码设计结构。我们实现某个功能时，往往不止一种实现方式。每一种实现方式没有绝对的高低之分，不同角度的解读，就会有不同的偏好。所以这个层面上的代码规范，只能求同存异。但是不管怎样，每个人必须要有一致性的风格。就像不同的小区可以有不同的风格，但同一个小区只能有一种设计风格。风格包含代码设计中的抽象概念，比如接口、继承等等。</p>
<p><a id="more"></a></p>
<h1 id="为什么要有代码规范？-1">为什么要有代码规范？</h1>
<p>对于团队，如果代码风格不统一，阅读或修改同事的代码会非常困难，造成潜在的风险。</p>
<p>对于个人，代码规范是对自身编码习惯的一种监督，如果没有这种监督，有时候因为偷懒，会写出难看的代码，时间长了自己都看不懂。这样对于代码的维护性是不利的。</p>
<h1 id="代码规范的内容？-1">代码规范的内容？</h1>
<p>代码规范包含的范围十分广泛。从一个变量的命名到一个类的设计，我觉得都属于代码规范的范畴。从实践的角度，可以把代码规范分成两个部分：</p>
<p>第一部分是规则，即一定要这么做。这里面没有对错，但需要统一。包含变量的命名、函数的命名、模块的组织、代码块的组织、宏、枚举、常量的声明、函数的粒度。</p>
<p>第二部分是风格，即一种模式化的代码设计结构。我们实现某个功能时，往往不止一种实现方式。每一种实现方式没有绝对的高低之分，不同角度的解读，就会有不同的偏好。所以这个层面上的代码规范，只能求同存异。但是不管怎样，每个人必须要有一致性的风格。就像不同的小区可以有不同的风格，但同一个小区只能有一种设计风格。风格包含代码设计中的抽象概念，比如接口、继承等等。</p>
<h1 id="代码的规则">代码的规则</h1>
<p>规则如同法律，尽管从心底里很多人不认可，但每个人都必须遵守。看起来大家都受了束缚，但是对整个社会以及每一个人都是利大于弊。</p>
<h2 id="变量命名">变量命名</h2>
<p>变量命名历史上产生过很多方法，比较著名的有匈牙利命名法、驼峰命名法、下划线命名法。</p>
<ul>
<li>匈牙利命名法：szUserName</li>
<li>驼峰命名法：userName</li>
<li>下划线命名法：user_name</li>
</ul>
<p>用Objective-C开发，我们就参考苹果的官方命名方式即可，苹果采用的是驼峰命名法。</p>
<p>苹果的变量命名方式常常被其它语言的开发者所吐槽，因为它的名有时候是在太长了！！！下面是3个最长的Objective-C属性名：<br>[56] automaticallyEnablesStillImageStabilizationWhenAvailable<br>[54] availableMediaCharacteristicsWithMediaSelectionOptions<br>[49] outputObscuredDueToInsufficientExternalProtection<br>变量声明最重要的是清晰其次才考虑长短，如果为了简短而含糊不清，是不可取的。</p>
<blockquote>
<p><a href="http://segmentfault.com/a/1190000000370048" target="_blank" rel="external">Objective-C项目的命名有多长</a></p>
</blockquote>
<p>拿现有代码举例</p>
<table>
<thead>
<tr>
<th style="text-align:left">变量含义</th>
<th style="text-align:left">Not Good</th>
<th style="text-align:left">Good</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">昵称输入框</td>
<td style="text-align:left">tfNickName</td>
<td style="text-align:left">nickNameTextField</td>
</tr>
<tr>
<td style="text-align:left">密码ImageView</td>
<td style="text-align:left">imvPass</td>
<td style="text-align:left">passwordImageView</td>
</tr>
<tr>
<td style="text-align:left">我的搜索条</td>
<td style="text-align:left">mysearchBar</td>
<td style="text-align:left">mySearchBar</td>
</tr>
</tbody>
</table>
<p><strong>类变量</strong><br>前面加下划线，和系统框架保持一致</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">@interface UIViewController : UIResponder &lt;NSCoding, UIAppearanceContainer&gt; {</span></div><div class="line">    <span class="comment">@package</span></div><div class="line">    UIView           <span class="keyword">*</span>_view;</div><div class="line">    UITabBarItem     <span class="keyword">*</span>_tabBarItem;</div><div class="line">    UINavigationItem <span class="keyword">*</span>_navigationItem;</div><div class="line">    NSArray          <span class="keyword">*</span>_toolbarItems;</div><div class="line">    NSString         <span class="keyword">*</span>_title;</div><div class="line">    </div><div class="line">    NSString         <span class="keyword">*</span>_nibName;</div><div class="line">    NSBundle         <span class="keyword">*</span>_nibBundle;</div><div class="line">    ......</div></pre></td></tr></table></figure>

<p>现有的例子</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CouponListTableViewCell</span> : <span class="title">UITableViewCell</span></span></div><div class="line">{</div><div class="line">    <span class="built_in">UIImageView</span> *imageIcon;</div><div class="line">    <span class="built_in">UIImageView</span> *imageCollect;</div><div class="line">    <span class="built_in">UILabel</span> *labelName;</div><div class="line">    <span class="built_in">UILabel</span> *labelPriceSale;</div><div class="line">    <span class="built_in">UILabel</span> *labelPriceOrigin;</div><div class="line">    <span class="built_in">UILabel</span> *labelSaleNumber;</div><div class="line">    <span class="built_in">UIImageView</span> *imageArrow;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>类变量与属性</strong><br>属性是Objective-C的一种高级语法，属性可以完全替换类变量，并且提供更强大的访问控制（strong、weak、nonatomic、readonly…）,而且属性也只需要用一行就能搞定，所以为什么还要用类变量呢？<br>属性声明后不用写@synthesize，且会自动生成类变量。<a href="http://stackoverflow.com/questions/12119284/xcode-4-automatically-generates-ivars-when-using-property-where-can-i-find-the" target="_blank" rel="external">资料&gt;</a></p>
<p><strong>例外</strong><br>一些局部变量允许用最简单的方式命名：i、j、temp<br>一些常用的缩写可以不用驼峰：RMB，OBD</p>
<h2 id="函数命名">函数命名</h2>
<p>Objective-C中的函数不同于其他语言，函数名是按参数隔开的。初看起来是有点怪，但是习惯了就会发现这样和命名方式可读性极好，就像一句话一样。所以当你的函数名不能流利的读出来的话，那么它的命名肯定就有问题。<br>还是先举系统的例子</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>willAnimateFirstHalfOfRotationToInterfaceOrientation:<span class="params">(<span class="variable">UIInterfaceOrientation</span>)</span>toInterfaceOrientation duration:<span class="params">(<span class="variable">NSTimeInterval</span>)</span>duration</span></div></pre></td></tr></table></figure>

<p>这里面值得注意的几点：</p>
<ul>
<li>最左边的（+、-）和返回类型的左括号之间有一个空格，返回类型的右括号与第一个参数之间没有空格；</li>
<li>函数名中每一段描述都以小写字母开头，描述的写法要考虑清晰明确，参考变量命名；</li>
<li>如果函数名过长，应该换行，按冒号对齐；</li>
<li>从描述中可以看出对应参数的意义。</li>
</ul>
<p>再看看我们自己的命名</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">1</span>、最后一个参数描述Selector首字母大写了</div><div class="line">+(<span class="built_in">UIButton</span> *)createButton:(MUButtonItemAttribute *)attr target:(<span class="keyword">id</span>)target Selector:(SEL)sel;</div><div class="line"><span class="number">2</span>、有一些多余的空格</div><div class="line">+ (AppDelegate *) appDelegate;</div><div class="line">- (<span class="keyword">void</span>)hideTabbar :(<span class="built_in">BOOL</span>)status;</div><div class="line"><span class="number">3</span>、加减号和括号之间要有空格</div><div class="line">-(<span class="keyword">void</span>)pushEvent:(<span class="built_in">NSDictionary</span>*)dictionary target:(<span class="keyword">id</span>)target;</div><div class="line"><span class="number">4</span>、参数名和参数要对应，含义清晰</div><div class="line">- (<span class="keyword">void</span>)setNavBackButton:(<span class="built_in">NSString</span> *)string;</div><div class="line">- (<span class="keyword">id</span>)init:(<span class="built_in">NSString</span>*)nickName phoneNumber:(<span class="built_in">NSString</span> *)phoneNumber;</div><div class="line">- (<span class="keyword">void</span>)setTextFieldBackGroud:(<span class="built_in">CGRect</span>)rect;</div><div class="line">- (<span class="keyword">id</span>)init:(<span class="built_in">NSInteger</span>)flag;</div><div class="line">- (<span class="keyword">void</span>)requestHealthRecord:(<span class="built_in">NSString</span> *)typeStr;</div><div class="line"><span class="number">5</span>、函数名过长要换行</div><div class="line">- (<span class="keyword">id</span>)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(<span class="built_in">NSString</span> *)reuseIdentifier containingTableView:(<span class="built_in">UITableView</span> *)containingTableView leftUtilityButtons:(<span class="built_in">NSArray</span> *)leftUtilityButtons rightUtilityButtons:(<span class="built_in">NSArray</span> *)rightUtilityButtons;</div><div class="line"><span class="number">6</span>、命名风格混乱</div><div class="line">+ (<span class="built_in">NSInteger</span>) GetServerBack:(<span class="built_in">NSString</span> *)serverName</div><div class="line">                 path_Param:(<span class="built_in">NSMutableDictionary</span>*)path_Param</div><div class="line">                query_Param:(<span class="built_in">NSMutableDictionary</span>*)query_Param</div><div class="line">                 body_Param:(<span class="built_in">NSMutableDictionary</span>*)body_Param</div><div class="line">                     method:(<span class="built_in">NSInteger</span>)method</div><div class="line">                returnValue:(<span class="built_in">NSMutableDictionary</span>*)returnValue;</div><div class="line"><span class="number">7</span>、参数之间用and、with，多此一举</div><div class="line">- (<span class="keyword">id</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame andImageView:(<span class="built_in">UIImageView</span>*)imageView withImageFrame:(<span class="built_in">CGRect</span>)imageInitFrame withImageUrl:(<span class="built_in">NSURL</span>*)imageUrl;</div></pre></td></tr></table></figure>

<p><strong>命名很重要！！！</strong><br>良好的命名是写出高质量代码的前提，命名的时候除了符合以上的规范，还需要找到合适的单词来表达含义，不要为了一时之快用拼音，也千万不要出现数字。</p>
<h2 id="代码模块组织">代码模块组织</h2>
<p>这个代码模块的组织是指文件级别的，即我们应该如何划分包。<br>现有的包结构是有些问题的，导致我们找某个功能的实现文件比较麻烦。<br>参考<a href="http://www.cocoachina.com/industry/20140225/7879.html" target="_blank" rel="external">别人的经验</a>，个人觉得这样的划分还是不错的。</p>
<p><strong>文件的命名</strong><br>我们自己创建的文件，应该有统一的前缀。比如HJMainViewController，这也符合系统的命名规范。Objective-C没有namespace，所以这样做的好处是当你引用了第三方的代码时，防止重名。而且当我们自己的代码越来越大时，内部也会出现冲突。</p>
<p><strong>一个文件一个类</strong><br>好处：</p>
<ul>
<li>减少单个文件的长度</li>
<li>定位文件更方便</li>
<li>便于重用</li>
</ul>
<h2 id="代码块的组织">代码块的组织</h2>
<p>作为一个程序员，大部分时间实在看代码而不是在写。所以代码的可读性严重影响到我们的工作效率。<br>当你看到超过1000行的实现文件时，你还有看下去的欲望吗？<br>所以千万不要写出超过1000行的代码，有的话也得<a href="http://www.objc.io/issue-1/" target="_blank" rel="external">重构掉</a>。</p>
<p>当代码控制到1000行以内后，只是具备了可读的基本条件。我们的屏幕一般只能一次显示50行代码，从头看到尾就是20屏，常常会看了后面忘了前面。所以我们要把一个文件里面的所有函数有秩序的组织起来，让人不用重头看到尾，就能很快定位到想看的地方。<br>这里提供一个小办法：用#pragma mark宏根据功能区分开:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">pragma</span> mark - Life Circle</span></div><div class="line"><span class="preprocessor">#<span class="keyword">pragma</span> mark - Public Interface</span></div><div class="line"><span class="preprocessor">#<span class="keyword">pragma</span> mark - UI Actions</span></div><div class="line"><span class="preprocessor">#<span class="keyword">pragma</span> mark - Business Logic</span></div><div class="line"><span class="preprocessor">#<span class="keyword">pragma</span> mark - UITableViewDataSource</span></div><div class="line"><span class="preprocessor">#<span class="keyword">pragma</span> mark - UITableViewDelegate</span></div><div class="line"><span class="preprocessor">#<span class="keyword">pragma</span> mark - UIScrollViewDelegate</span></div><div class="line"><span class="preprocessor">#<span class="keyword">pragma</span> mark - Notification Handle</span></div><div class="line"><span class="preprocessor">#<span class="keyword">pragma</span> mark - Private Method</span></div></pre></td></tr></table></figure>

<h2 id="宏、枚举、常量的声明">宏、枚举、常量的声明</h2>
<p>宏的命名方式参考变量的命名方式，大写，用下划线分开</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TARGET_OS_IPHONE</div></pre></td></tr></table></figure>

<p>枚举也有很多写法，这里推荐系统的方式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, NSTextAlignment) {</div><div class="line"><span class="constant">    NSTextAlignmentLeft</span>      = <span class="number">0</span>,    <span class="comment">// Visually left aligned</span></div><div class="line"><span class="constant">    NSTextAlignmentRight</span>     = <span class="number">1</span>,    <span class="comment">// Visually right aligned</span></div><div class="line"><span class="constant">    NSTextAlignmentCenter</span>    = <span class="number">2</span>,    <span class="comment">// Visually centered</span></div><div class="line"><span class="constant">    NSTextAlignmentJustified</span> = <span class="number">3</span>,    <span class="comment">// Fully-justified. The last line in a paragraph is natural-aligned.</span></div><div class="line"><span class="constant">    NSTextAlignmentNatural</span>   = <span class="number">4</span>,    <span class="comment">// Indicates the default alignment for script</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>常量以k开头，系统命名风格</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kAPNetworkDidSetupNotification;     <span class="comment">// 建立连接</span></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kAPNetworkDidCloseNotification;     <span class="comment">// 关闭连接</span></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kAPNetworkDidRegisterNotification;  <span class="comment">// 注册成功</span></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kAPNetworkDidLoginNotification;     <span class="comment">// 登录成功</span></div></pre></td></tr></table></figure>

<p>如果是数值常量，用宏的话，也可以用k开头</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> kDistancePoint  10.0f   <span class="comment">// 圆点、标志和正文的间距</span></span></div></pre></td></tr></table></figure>

<h2 id="函数的粒度">函数的粒度</h2>
<p>知道我们现在最长的函数有多少行吗？655行。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>getShopDetail</span></div></pre></td></tr></table></figure>

<p>一个函数最好不超过一屏（50行），千万不能超过两屏（100行）。<br>因为从设计的角度来说，一个函数只需要干一件事，所以50行一般是狗的，超长的函数往往干了很多事情，或者干了意见很大的事（拆成多件小事，交给子函数去干）。</p>
<h2 id="其它">其它</h2>
<ul>
<li><strong>Log</strong>：不要使用NSLog，提交了会因想到别人，而且最后打包删起来麻烦。需要找一个Log工具，MyNSLog功能不够。</li>
<li><strong>代码中尽量不要出现数字</strong>：据上下文推测出来的，还是计算的出为好（现在界面里面很多地方确实要写死数字，适配iPhone6会很困难）</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">_contentBkg </span>=<span class="string"> [[UIView alloc] initWithFrame:CGRectMake(0, 1 / [UIScreen mainScreen].scale, 320, 68 - 1)];</span></div></pre></td></tr></table></figure>

<ul>
<li><strong>避免复杂的表达式</strong>：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (tfPassword.<span class="keyword">text</span>!=nil &&</div><div class="line">    ![tfPassword.<span class="keyword">text</span> isEqualToString:@<span class="string">""</span>] &&</div><div class="line">    tfRequestNumber.<span class="keyword">text</span>!=nil &&</div><div class="line">    ![tfRequestNumber.<span class="keyword">text</span> isEqualToString:@<span class="string">""</span>]</div><div class="line">    )</div><div class="line">{</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li><strong>一个变量不在多个函数中出现，不要作为类变量：</strong></li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="type">MBProgressHUD</span>* hudProgress;</div><div class="line"><span class="type">int</span> <span class="literal">result</span>;</div></pre></td></tr></table></figure>

<ul>
<li><strong>每个类的.h开头的地方要有注释，说明这个类是干嘛的</strong></li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"> * SDImageCache maintains a memory cache and an optional disk cache. Disk cache write operations are performed</div><div class="line"> * asynchronous so it doesn’t add unnecessary latency to the UI.</div><div class="line"> */</div><div class="line"><span class="annotation">@interface</span> SDImageCache : NSObject</div></pre></td></tr></table></figure>

<ul>
<li><strong>if后面的语句哪怕只有一行，都加括号</strong></li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([key rangeOfString:@<span class="string">"热"</span>].location != NSNotFound) {</div><div class="line">            titleLabel.<span class="variable">text =</span> @<span class="string">"热门城市"</span>;</div><div class="line">     }</div><div class="line">     <span class="keyword">else</span></div><div class="line">            titleLabel.<span class="variable">text =</span> key;</div></pre></td></tr></table></figure>

<h1 id="代码的风格">代码的风格</h1>
<p>风格如同习俗，不同地区有不同的习俗。你觉得入乡随俗好，就入乡随俗，这样避免了一些无谓的麻烦；但是你若坚持原有的习俗，社会也是能接受的，毕竟这些东西都是发展变化的，没有固定的模式，只有更好的模式。</p>
<h2 id="接口">接口</h2>
<p>这里的接口指的是一个类公开的一组方法，良好设计的类是高内聚低耦合的，所以接口必须是简洁的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PaySucceedViewController</span> : <span class="title">LCBaseViewController</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,retain) <span class="built_in">NSString</span> *isSuccess;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,retain) <span class="built_in">NSString</span> *shopName;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,retain) <span class="built_in">NSString</span> *detailinfo;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,retain) <span class="built_in">NSString</span> *amount;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,retain) <span class="built_in">NSString</span> *omsOrderId;</div><div class="line"><span class="comment">/*!</span></div><div class="line"> *  支付订单类型</div><div class="line"> *</div><div class="line"> *  @since</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) ORDER_CATEGORY mCategory;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>上面的例子是一个ViewController，但是它暴露了太多属性，属性很零碎，传值的时候要一个一个传。其实这里属性应该属于一个叫订单Model的对象，把这些属性封装在OrderModel中，复用性和可维护性都会好很多。（但是现在代码整体结构没有Model层，这里需要很大的重构）</p>
<h2 id="继承">继承</h2>
<p>继承不是为了少写代码，它的目的是抽象，顺便少写了代码。<br>举NavigationBar的例子，用宏可以实现，用基类也可以实现，但基类抽象出了一个共有的接口，以后发生共性的变化够可以通过修改基类来实现，你可以在基类里加一组方法，而宏做不到。</p>
<h2 id="其它-1">其它</h2>
<p>代码规范的路还长着，先走出第一步吧！</p>
<h1 id="参考资料">参考资料</h1>
<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" target="_blank" rel="external">Apple代码规范</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="为什么要有代码规范？">为什么要有代码规范？</h1>
<p>对于团队，如果代码风格不统一，阅读或修改同事的代码会非常困难，造成潜在的风险。</p>
<p>对于个人，代码规范是对自身编码习惯的一种监督，如果没有这种监督，有时候因为偷懒，会写出难看的代码，时间长了自己都看不懂。这样对于代码的维护性是不利的。</p>
<h1 id="代码规范的内容？">代码规范的内容？</h1>
<p>代码规范包含的范围十分广泛。从一个变量的命名到一个类的设计，我觉得都属于代码规范的范畴。从实践的角度，可以把代码规范分成两个部分：</p>
<p>第一部分是规则，即一定要这么做。这里面没有对错，但需要统一。包含变量的命名、函数的命名、模块的组织、代码块的组织、宏、枚举、常量的声明、函数的粒度。</p>
<p>第二部分是风格，即一种模式化的代码设计结构。我们实现某个功能时，往往不止一种实现方式。每一种实现方式没有绝对的高低之分，不同角度的解读，就会有不同的偏好。所以这个层面上的代码规范，只能求同存异。但是不管怎样，每个人必须要有一致性的风格。就像不同的小区可以有不同的风格，但同一个小区只能有一种设计风格。风格包含代码设计中的抽象概念，比如接口、继承等等。</p>
<p>]]>
    
    </summary>
    
      <category term="规范" scheme="http://linkageios.github.io/tags/%E8%A7%84%E8%8C%83/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
</feed>
