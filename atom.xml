<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[SmartArrow]]></title>
  <subtitle><![CDATA[技术文档]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://linkageios.github.io/"/>
  <updated>2015-02-02T09:19:41.958Z</updated>
  <id>http://linkageios.github.io/</id>
  
  <author>
    <name><![CDATA[SmartArrow]]></name>
    <email><![CDATA[stephenzhumail@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[写点更简洁的代码]]></title>
    <link href="http://linkageios.github.io/2015/01/28/%E5%86%99%E7%82%B9%E6%9B%B4%E7%AE%80%E6%B4%81%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <id>http://linkageios.github.io/2015/01/28/写点更简洁的代码/</id>
    <published>2015-01-28T09:23:14.000Z</published>
    <updated>2015-02-02T09:12:31.000Z</updated>
    <content type="html"><![CDATA[<p>最近在review整个项目的代码，因为代码量很大，参与开发的人很多，所以代码很多地方写得不够简洁。这里总结出一些代码片段，用来简化代码。<br><a id="more"></a></p>
<p>最近在review整个项目的代码，因为代码量很大，参与开发的人很多，所以代码很多地方写得不够简洁。这里总结出一些代码片段，用来简化代码。</p>
<p>1、让TableView多余的Cell不可见。<br>原来的实现：<br>给TableView增加一个空的FooterView。但是当很多地方都需有这个需求时，类似的代码就重复出现。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIView *<span class="keyword">view</span> = [UIView <span class="keyword">new</span>];</div><div class="line"><span class="keyword">view</span>.backgroundColor = [UIColor clearColor];</div><div class="line">[tableView setTableFooterVie<span class="variable">w:view</span>];</div></pre></td></tr></table></figure>

<p>改进的实现：<br>增加一个UITableView的category，这样在调用的地方只需一行就够了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UITableView</span>(<span class="title">Addtions</span>)</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)hideEmptyCells</div><div class="line">{</div><div class="line"><span class="built_in">UIView</span> *view = [<span class="built_in">UIView</span> new];</div><div class="line">view<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];</div><div class="line">[<span class="keyword">self</span> setTableFooterView:view];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">[self.tableView hideEmptyCells]</span><span class="comment">;</span></div></pre></td></tr></table></figure>

<p>2、让TableView Cell之间的分隔线左间距为0<br>这个问题是iOS7之后才出现的，iOS7的解决方法到了iOS8又出问题，所以每次用到TableView, 都要给TableView设置一便，又要给TableViewCell设置一遍，代码很多很散。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置tableView</span></div><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.tableView</span> respondsToSelector:<span class="keyword">@selector</span>(setSeparatorInset:)]) {</div><div class="line">[<span class="keyword">self</span><span class="variable">.tableView</span> setSeparatorInset:UIEdgeInsetsZero];</div><div class="line">}</div><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.tableView</span> respondsToSelector:<span class="keyword">@selector</span>(setLayoutMargins:)]) {</div><div class="line">[<span class="keyword">self</span><span class="variable">.tableView</span> setLayoutMargins:UIEdgeInsetsZero];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//设置tableviewcell</span></div><div class="line"><span class="keyword">if</span> ([cell respondsToSelector:<span class="keyword">@selector</span>(setSeparatorInset:)]) {</div><div class="line">[cell setSeparatorInset:UIEdgeInsetsZero];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">if</span> ([cell respondsToSelector:<span class="keyword">@selector</span>(setLayoutMargins:)]) {</div><div class="line">[cell setLayoutMargins:UIEdgeInsetsZero];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>改进的实现：<br>给UITableView和UITableViewCell各增加一个Category方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//UITableView</span></div><div class="line">- (<span class="keyword">void</span>)hideSeparatorLeftInset</div><div class="line">{</div><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(setSeparatorInset:)])</div><div class="line">{</div><div class="line">[<span class="keyword">self</span> setSeparatorInset:UIEdgeInsetsZero];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(setLayoutMargins:)])</div><div class="line">{</div><div class="line">[<span class="keyword">self</span> setLayoutMargins:UIEdgeInsetsZero];</div><div class="line">}</div><div class="line">}</div><div class="line"><span class="comment">//UITableViewCell</span></div><div class="line">- (<span class="keyword">void</span>)hideSeparatorLeftInset</div><div class="line">{</div><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(setLayoutMargins:)]) {</div><div class="line">[<span class="keyword">self</span> setLayoutMargins:UIEdgeInsetsZero];</div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后在创建UITableView和UITableViewCell的地方分别调用就好了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建Table</span></div><div class="line">_newsTable = [[<span class="built_in">UITableView</span> alloc] initWithFrame:CGRectMake(<span class="number">0</span>, <span class="number">0</span>, SCREEN_WIDTH, SCREEN_HEIGHT - <span class="number">64</span> -<span class="number">49</span>) style:UITableViewStylePlain];</div><div class="line">_newsTable<span class="variable">.delegate</span> = <span class="keyword">self</span>;</div><div class="line">_newsTable<span class="variable">.dataSource</span> = <span class="keyword">self</span>;</div><div class="line">[_newsTable hideSeparatorLeftInset];</div><div class="line"></div><div class="line"><span class="comment">//创建Cell</span></div><div class="line"><span class="keyword">if</span> (cell == <span class="literal">nil</span>) {</div><div class="line">cell = [[FindBigImageTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:simpleCell];</div><div class="line">[cell setSelectionStyle:UITableViewCellSelectionStyleNone];</div><div class="line">[cell hideSeparatorLeftInset];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样做的好处：</p>
<ul>
<li>代码简洁，只要一行。因为在很多类似的页面都会出现重复的代码，所以不同的人写往往会不一致，造成bug。</li>
<li>以后api升级，只要改一处地方即可，不用满世界的找代码然后修改。</li>
</ul>
<p>总结：当你写代码的时候需要复制粘贴的时候，肯定是没有封装。想想能不能用Util方法和Category进行抽象，把不变的剥离出来，组成新的方法，这比复制粘贴好太多。</p>
<p>3、网络请求的封装<br>目前代码中的网络请求，是基于Http的，主要分成如下几个过程：<br>1、设置请求参数<br>2、调用封装好的http方法发出请求<br>3、对清求结果进行处理<br>典型用法如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">MBProgressHUD<span class="keyword">*</span> hudProgress;</div><div class="line">__block int result;</div><div class="line">hudProgress = [[MBProgressHUD alloc] initWithWindow:[UIApplication sharedApplication].keyWindow];</div><div class="line"></div><div class="line">hudProgress.labelText = <span class="comment">@"XXX";</span></div><div class="line"></div><div class="line">APIPackageLoginGoHeader <span class="keyword">*</span>goHead = [[APIPackageLoginGoHeader alloc]init];</div><div class="line">APIPackageLoginBackHeader <span class="keyword">*</span>backHead = [[APIPackageLoginBackHeader alloc]init];</div><div class="line">goHead.loame = <span class="comment">@"XXXX";</span></div><div class="line">goHead.paord = <span class="comment">@"XXXX";</span></div><div class="line">goHead.surce = <span class="comment">@"XXXX</span></div><div class="line">goHead.sin = <span class="comment">@"XXXX";</span></div><div class="line">goHead.versNo = <span class="comment">@"XXXX";</span></div><div class="line">[goHead makeDictionary];</div><div class="line">NSMutableDictionary <span class="keyword">*</span>dicBack = [[NSMutableDictionary alloc]init];[hudProgress showAnimated:NO whileExecutingBlock:^{</div><div class="line">result = [GMPostServer GetServerBack:SERVER_LOGIN path_Param:nil query_Param:goHead.dicGo body_Param:nil method:GM_NETWORK_METHOD_POST returnValue:dicBack];</div><div class="line">[backHead getBodyDataItems:dicBack];     </div><div class="line">}completionBlock:^{</div><div class="line">if (result == GM_POSTBACK_SUCCESS)</div><div class="line">{</div><div class="line">[UserInfoEntity shareEntity].pne = backHead.ph;</div><div class="line">[UserInfoEntity shareEntity].niame = backHead.name;</div><div class="line">[UserInfoEntity shareEntity].hasLogin = YES;</div><div class="line">[UserInfoEntity shareEntity].userId = [NSString stringWithFormat:<span class="comment">@"%@",backHead.userId];</span></div><div class="line">[UserInfoEntity shareEntity].state = backHead.state;</div><div class="line"></div><div class="line">if ([launchOptions objectForKey:<span class="comment">@"UIApplicationLaunchOptionsRemoteNotificationKey"] != nil) {</span></div><div class="line">self.pushInfo = [launchOptions objectForKey:<span class="comment">@"UIApplicationLaunchOptionsRemoteNotificationKey"];</span></div><div class="line">BasicHomeViewController <span class="keyword">*</span>basicVc = (BasicHomeViewController<span class="keyword">*</span>)self.window.rootViewController;</div><div class="line">UINavigationController <span class="keyword">*</span>viewController = (UINavigationController <span class="keyword">*</span>)[[basicVc.tabbar.buttonData objectAtIndex:basicVc.tabbar.selectIndex] viewController];</div><div class="line">[viewController dismissViewControllerAnimated:NO completion:nil];</div><div class="line">[[PushEventManager sharedInstance] pushEvent:self.pushInfo target:viewController];</div><div class="line"></div><div class="line">[APService setBadge:0];</div><div class="line">[UIApplication sharedApplication].applicationIconBadgeNumber = 0;   </div><div class="line">}</div><div class="line">[self requestUserInfo];</div><div class="line">}</div><div class="line">else</div><div class="line">{</div><div class="line">showErroMsg(backHead.errorMsg);</div><div class="line">}</div><div class="line">}];</div></pre></td></tr></table></figure>

<p>上述代码是用户登录，在ViewController里面的，有一个很大的特点：长。而且集合了参数准备，发请求，请求结果处理，还和UI相互耦合。<br>试想一下，用户登录不会只在一个界面里有，如果多个地方存在登录的情况，这一块代码就会多次出现，而且大致结构都差不多吧？只有参数的取值和成功失败的处理逻辑不太一样，那么就把剩下的固定的逻辑：参数复制，hud，请求放到一个方法里面：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">+ (<span class="type">void</span>)userLoginWithUserName:(<span class="type">NSString</span>*)userName</div><div class="line">password:(<span class="type">NSString</span>*)password</div><div class="line">success:(<span class="type">void</span>(^)(<span class="type">APIPackageLoginBackHeader</span>*))sucBlock</div><div class="line">failure:(<span class="type">void</span>(^)(<span class="type">APIPackageLoginBackHeader</span>*))failBlock</div><div class="line">animated:(<span class="type">BOOL</span>)animated</div><div class="line">loadingText:(<span class="type">NSString</span>*)loadingText</div><div class="line">inView:(<span class="type">UIView</span>*)containerView;</div><div class="line">{</div><div class="line"><span class="type">MBProgressHUD</span>* hudProgress;</div><div class="line">__block <span class="type">NSInteger</span> <span class="literal">result</span>;</div><div class="line">hudProgress = [[<span class="type">MBProgressHUD</span> alloc] initWithWindow:[<span class="type">UIApplication</span> sharedApplication].keyWindow];</div><div class="line"></div><div class="line"><span class="keyword">if</span> (animated) {</div><div class="line">[containerView addSubview:hudProgress];</div><div class="line">[containerView bringSubviewToFront:hudProgress];</div><div class="line">hudProgress.labelText = loadingText;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="type">APIPackageLoginGoHeader</span> *goHead = [[<span class="type">APIPackageLoginGoHeader</span> alloc]init];</div><div class="line"><span class="type">APIPackageLoginBackHeader</span> *backHead = [[<span class="type">APIPackageLoginBackHeader</span> alloc]init];</div><div class="line">goHead.logame = userName;</div><div class="line">goHead.pard = password;</div><div class="line">goHead.sodde = @<span class="string">"iphone"</span>;</div><div class="line">goHead.swn = @<span class="string">"ios"</span>;</div><div class="line">goHead.versdddo = [<span class="type">LCSystemUtil</span> appVersion];</div><div class="line">[goHead makeDictionary];</div><div class="line"></div><div class="line"><span class="type">NSMutableDictionary</span> *dicBack = [[<span class="type">NSMutableDictionary</span> alloc]init];</div><div class="line">[hudProgress showAnimated:animated whileExecutingBlock:^{</div><div class="line"></div><div class="line"><span class="literal">result</span> = [<span class="type">GMPostServer</span> <span class="type">GetServerBack</span>:<span class="type">SERVER_LOGIN</span> path_Param:<span class="keyword">nil</span> query_Param:goHead.dicGo body_Param:<span class="keyword">nil</span> <span class="keyword">method</span>:<span class="type">GM_NETWORK_METHOD_POST</span> returnValue:dicBack];</div><div class="line">[backHead getBodyDataItems:dicBack];</div><div class="line"></div><div class="line"></div><div class="line">}completionBlock:^{</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">result</span> == <span class="type">GM_POSTBACK_SUCCESS</span>)</div><div class="line">{</div><div class="line">[<span class="type">UserInfoEntity</span> shareEntity].phone = backHead.pe;</div><div class="line">[<span class="type">UserInfoEntity</span> shareEntity].nikename = backHead.niccdame;</div><div class="line">[<span class="type">UserInfoEntity</span> shareEntity].hasLogin = <span class="type">YES</span>;</div><div class="line">[<span class="type">UserInfoEntity</span> shareEntity].userId = [<span class="type">NSString</span> stringWithFormat:@<span class="string">"%@"</span>,backHead.uddrId];</div><div class="line">[<span class="type">UserInfoEntity</span> shareEntity].state = backHead.stcde;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(sucBlock){</div><div class="line">sucBlock(backHead);</div><div class="line">}</div><div class="line"></div><div class="line">}</div><div class="line"><span class="keyword">else</span></div><div class="line">{</div><div class="line"><span class="keyword">if</span> (failBlock) {</div><div class="line">failBlock(backHead);</div><div class="line">}</div><div class="line">}</div><div class="line">}];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>外部调用，只要一行代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[HJUserProvider userLoginWithUserName:userName</div><div class="line">password:password</div><div class="line">success:^(APIPackageLoginBackHeader *backHeader) {</div><div class="line">[<span class="keyword">self</span> backButtonPressed:<span class="literal">nil</span>];</div><div class="line">[HJUserProvider requestUserInfoWithSuccess:<span class="literal">nil</span> failure:<span class="literal">nil</span>];</div><div class="line">}</div><div class="line">failure:^(APIPackageLoginBackHeader *backHeader) {</div><div class="line">[HJUIUtil showFailedMsg:backHeader<span class="variable">.errorMsg</span>];</div><div class="line">}</div><div class="line">animated:<span class="literal">YES</span></div><div class="line">loadingText:NSLocalizedString(<span class="string">@"Logging now..."</span>, <span class="literal">nil</span>)</div><div class="line">inView:<span class="keyword">self</span><span class="variable">.view</span>];</div></pre></td></tr></table></figure>

<p>这样的做法就把网络请求从ViewController分离开了，而且没有任何的耦合。同一个接口的请求逻辑只需写一遍（之前是copy、paste，因为代码不是唯一的，所以不同的人，不同的时间改了了其中一处，就会造成差异，引起未知的bug）。另外一个好处就是把各种请求逻辑都集中在了一处，便于阅读和修改。</p>
<p>4、数据归数据，UI归UI<br>从本质上说，程序就分成两部分：数据和UI。从ViewController的角度来说，就是State和View。View随着State的改变而改变，所以两者应该分开使ViewController结构更加清晰。<br>举个例子：viewDidLoad方法，这个方法里应该写些什么？</p>
<blockquote>
<p>This method is called after the view controller has loaded its view hierarchy into memory. This method is called regardless of whether the view hierarchy was loaded from a nib file or created programmatically in the loadView method. You usually override this method to perform additional initialization on views that were loaded from nib files.</p>
</blockquote>
<p>官方的建议是写视图上的额外的初始化工作，而和视图不相关的初始化工作就不该在这里写（题外话，iOS6之前，遇到内存警告，viewDidLoad是会调多次的，所以把对象的初始化写在这里是有问题的，iOS6之后反正没发现过viewDidLoad调用多次的情况），那么对象的初始化（状态变量的复制）应该写在哪里呢？——初始化方法！不要因为基类提供了默认的初始化方法而偷懒不写，任何一个类，除非简单的不能再简单，都要有一个初始化方法，哪怕里面什么都没写。下面这段代码的问题就是上班部分代码应该出现在初始化方法中。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad {</div><div class="line">[<span class="keyword">super</span> viewDidLoad];</div><div class="line">_newsDataAry = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">_currentPage = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">//获取缓存文章</span></div><div class="line"><span class="built_in">NSArray</span> *arr = [[ArticleSqliteData shareManager] dataGetHeadArticle];</div><div class="line">[_newsDataAry addObject:arr];</div><div class="line"></div><div class="line"><span class="built_in">NSArray</span> *arrNewsInfo = [[ArticleSqliteData shareManager] dataHomeViewIsFirstGet:<span class="literal">YES</span>];</div><div class="line">[_newsDataAry addObjectsFromArray:arrNewsInfo];</div><div class="line"></div><div class="line"><span class="keyword">if</span> ([arrNewsInfo count] != <span class="number">0</span>) {</div><div class="line">ArticleModel *model = [arrNewsInfo lastObject];</div><div class="line">_isExpire = [<span class="keyword">self</span> calculationTime:model<span class="variable">.updateTime</span>];</div><div class="line">}</div><div class="line"><span class="keyword">else</span>{</div><div class="line">_isExpire = <span class="literal">YES</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//上面的代码和对象的状态相关，不该出现在这里</span></div><div class="line">[<span class="keyword">self</span> addTableView];</div><div class="line"></div><div class="line">[<span class="keyword">self</span> setTitleViewWithText:<span class="string">@"发现"</span>];</div><div class="line">[<span class="keyword">self</span> setLeftButtonWithTitle:<span class="string">@"秘籍"</span> action:<span class="keyword">@selector</span>(showCheats)];</div><div class="line">[<span class="keyword">self</span> setRightButtonWithImageName:<span class="string">@"find_xiala.png"</span> action:<span class="keyword">@selector</span>(showCatagory)];</div><div class="line"><span class="keyword">self</span><span class="variable">.showCategory</span> = <span class="literal">NO</span>;<span class="comment">//这一行也是状态</span></div><div class="line"><span class="comment">// Do any additional setup after loading the view from its nib.</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">*  初始化分类页面</div><div class="line">*/</div><div class="line"><span class="keyword">self</span><span class="variable">.categoryView</span>  = [[HJFindCategoryView alloc] initWithFrame:CGRectMake(<span class="number">0</span>, <span class="number">64</span>, SCREEN_WIDTH, SCREEN_HEIGHT)];</div><div class="line">[<span class="keyword">self</span><span class="variable">.categoryView</span> addBorderTopLine];</div><div class="line"><span class="keyword">self</span><span class="variable">.categoryView</span><span class="variable">.hjFindCategoryViewDelegate</span> = <span class="keyword">self</span>;</div><div class="line"><span class="keyword">self</span><span class="variable">.categoryView</span><span class="variable">.hidden</span> = <span class="literal">YES</span>;<span class="comment">//UI应该依赖状态，而不是写死</span></div><div class="line">[[AppDelegate appDelegate]<span class="variable">.window</span> addSubview:<span class="keyword">self</span><span class="variable">.categoryView</span>];</div><div class="line">[<span class="keyword">self</span> getBannerNewsTitle];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>5、成员方法与Util方法<br>一个类代码比较多的一个原因，就是加入了不该加入的成员方法所致。一个方法，之所以称为成员方法，是因为它操作了对象的状态，如果它没有操作对象的状态，拿它就跟该对象没有紧密的关系，就不能放在类里面实现。举个例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)calculationTime:(<span class="built_in">NSDate</span> *)date</div><div class="line">{</div><div class="line">NSDateFormatter *dateFormatter=[[NSDateFormatter alloc] init];</div><div class="line">[dateFormatter setDateFormat:<span class="string">@"yyyy-MM-dd HH:mm:ss"</span>];</div><div class="line"><span class="built_in">NSDate</span> *  senddate=[<span class="built_in">NSDate</span> date];</div><div class="line"><span class="comment">//结束时间</span></div><div class="line"><span class="built_in">NSDate</span> *endDate = date;</div><div class="line"><span class="comment">//当前时间</span></div><div class="line"><span class="built_in">NSDate</span> *senderDate = [dateFormatter dateFromString:[dateFormatter stringFromDate:senddate]];</div><div class="line"><span class="comment">//得到相差秒数</span></div><div class="line"><span class="built_in">NSTimeInterval</span> time=[senderDate timeIntervalSinceDate:endDate];</div><div class="line"></div><div class="line"><span class="keyword">int</span> days = ((<span class="keyword">int</span>)time)/(<span class="number">3600</span>*<span class="number">24</span>);</div><div class="line"><span class="keyword">if</span> (days &lt; <span class="number">0</span>) {</div><div class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">}</div><div class="line"><span class="keyword">else</span>{</div><div class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面这个方法和对象没什么关系，更应该抽象成为一个Util方法，可以在这个类里面调用，更可以再其他更多的地方调用。</p>
<p>6、功能点单一入口<br>在代码中，有些功能逻辑是相对固定的，但是在很多地方会反复出现。<br>比如登录功能，除了用户主动登录，还有在未登录状态下使用某些需要登录的功能，都会去调用登录页面。我看了一下现在的代码，一共出现了14次调用登录页面。代码重复是一个方面，还有就是定位bug麻烦。比如进入首页的时候莫名其妙弹出个登录页面，因为首页逻辑复杂，我得打很多断点才能定位到产生问题的代码。<br>还有对tabbar的操作，也是出现在了多出地方。其实只要搞清楚tabbar是哪个类管理的，然后让这个类封装出一个public的方法，控制tabbar的隐藏与否即可。</p>
<p>所以一个功能点我们只保留一个出口，其他地方只要调用方法即可。把相同的地方写在方法内部，不同的地方作为参数对外开放。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在review整个项目的代码，因为代码量很大，参与开发的人很多，所以代码很多地方写得不够简洁。这里总结出一些代码片段，用来简化代码。<br>]]>
    
    </summary>
    
      <category term="代码规范" scheme="http://linkageios.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[状态栏高度变化处理]]></title>
    <link href="http://linkageios.github.io/2015/01/18/%E7%8A%B6%E6%80%81%E6%A0%8F%E9%AB%98%E5%BA%A6%E5%8F%98%E5%8C%96%E5%A4%84%E7%90%86/"/>
    <id>http://linkageios.github.io/2015/01/18/状态栏高度变化处理/</id>
    <published>2015-01-18T02:23:14.000Z</published>
    <updated>2015-02-02T09:12:31.000Z</updated>
    <content type="html"><![CDATA[<p>iOS中的状态栏的正常高度是20，但并不是固定高度的，至少在通话中和有热点连接时，它的高度就会变成40。这时APP的UI会整体下移，造成UI显示异常。<br><a id="more"></a></p>
<p>这是一个细节，我查看了自己手机上那些知名APP，发现还有好多没做处理。<br>处理的：</p>
<ul>
<li>微信<br><img src="http://upload-images.jianshu.io/upload_images/16632-239743d1a2852743.PNG" alt="Drawing" width="200px"></li>
<li>QQ<br><img src="http://upload-images.jianshu.io/upload_images/16632-5f0c47b2bf769cbf.PNG" alt="Drawing" width="200px"></li>
<li>淘宝<br><img src="http://upload-images.jianshu.io/upload_images/16632-274441621b624829.PNG" alt="Drawing" width="200px"></li>
<li>支付宝<br><img src="http://upload-images.jianshu.io/upload_images/16632-4649cd6e19c7ea8e.PNG" alt="Drawing" width="200px"></li>
</ul>
<p>没处理的：</p>
<ul>
<li>网易新闻<br><img src="http://upload-images.jianshu.io/upload_images/16632-f774f14e8e1bad90.PNG" alt="Drawing" width="200px"></li>
<li>京东<br><img src="http://upload-images.jianshu.io/upload_images/16632-5d37d451b1e55a3e.PNG" alt="Drawing" width="200px"></li>
<li>苏宁<br><img src="http://upload-images.jianshu.io/upload_images/16632-5d478844c53ee99e.PNG" alt="Drawing" width="200px"></li>
<li>携程<br><img src="http://upload-images.jianshu.io/upload_images/16632-ec9ee74c4007258f.PNG" alt="Drawing" width="200px"></li>
</ul>
<p>虽然这只是一个很不起眼的功能，但可以看出做产品的人有没有认真做，而不只是把功能做给用户看。</p>
<p>说完了处理这个东西的重要性，那么做起来是否简单呢？</p>
<ul>
<li>问题1：怎么获取状态栏高度？<br>状态栏的高度并非永远都是20，当有热点连接或者通话时，它的高度就会变成40。所以取得状态栏高度的标准方法如下，可以用宏来封装。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr_selector">[UIApplication sharedApplication]</span><span class="class">.statusBarFrame</span><span class="class">.size</span><span class="class">.height</span></div></pre></td></tr></table></figure>

<ul>
<li>问题2：怎么知道状态栏发生了变化？<br>是通知。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">UIApplicationWillChangeStatusBarFrameNotification</span></div><div class="line">UIApplicationDidChangeStatusBarFrameNotification</div></pre></td></tr></table></figure>

<p>我们可以监听其中某个通知，然后相应的去改变当前视图的布局。</p>
<ul>
<li>问题3：是不是需要每个页面都要去注册通知？<br>这个问题应该具体问题具体分析，但如果真的需要一个一个页面去改，我觉得肯定是程序结构出了问题。就我目前的项目而言，只是在根容器类中加了通知并处理了底部的tabbar。其他页面虽然有时也有问题，但很多都是自身实现方式有问题，和状态栏变化没有直接关系。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)statusBarFrameWillChange:(<span class="built_in">NSNotification</span>*)notification</div><div class="line">{</div><div class="line">[<span class="keyword">self</span> hideTabbar:<span class="keyword">self</span><span class="variable">.statusBarHidden</span> animated:<span class="literal">YES</span>];</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>iOS中的状态栏的正常高度是20，但并不是固定高度的，至少在通话中和有热点连接时，它的高度就会变成40。这时APP的UI会整体下移，造成UI显示异常。<br>]]>
    
    </summary>
    
      <category term="状态栏" scheme="http://linkageios.github.io/tags/%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[xib使用]]></title>
    <link href="http://linkageios.github.io/2014/12/30/xib%E7%AE%80%E4%BB%8B/"/>
    <id>http://linkageios.github.io/2014/12/30/xib简介/</id>
    <published>2014-12-30T07:00:25.000Z</published>
    <updated>2014-12-31T01:10:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="xib简介">xib简介</h2>
<p>xib用来描述软件界面，它用Interface Builder工具来编辑。<br>本文主要介绍使用xib的一些技术，即在xib中布局UI,然后xib与code相结合，快速UI开发介绍。本文主要讲解的也就是加载xib的技术。</p>
<p><a id="more"></a></p>
<h2 id="xib创建">xib创建</h2>
<h3 id="与文件同步创建">与文件同步创建</h3>
<p><img src="/images/gouxuan.png" alt="" title="" width="600">  </p>
<h3 id="已有文件单独创建xib">已有文件单独创建xib</h3>
<p><img src="/images/dandu.png" alt="" title="" width="600">  </p>
<h2 id="xib使用">xib使用</h2>
<h3 id="1、是否选择autolayout">1、是否选择autolayout</h3>
<p>如果要用autolayout则勾选下图中的红框，不勾选则使用autoresize<br><img src="/images/autolayout.png" alt="" title="" width="300"></p>
<h3 id="2、针对某一项单独禁用autolayout">2、针对某一项单独禁用autolayout</h3>
<p>如果使用autolayout，但又想对某一控件禁用autolayout，则只需加入如下代码即可：<br><em>[self.locationLabel setTranslatesAutoresizingMaskIntoConstraints:YES];</em><br>此地的self.locationLabel即为你想禁用的控件。<br><strong>特别注意：启用autolayout，则代码中所有设置frame的代码都是无用的，如果要单独设置frame则需禁用该控件的autolayout。</strong></p>
<h3 id="3、xib关联">3、xib关联</h3>
<p>如果是容器，如：viewController,则File’s Owner中的Custom Class中的Class必须关联到对应的viewController类。<br>如果是单纯控件，如：view，button等，则view中的Custom Class中的Class不用关联。</p>
<p>对于代码中需要进行操作的变量定义时需要在前部加上<br><em>IBOutlet</em><br>定义完成后，需要进行关联。选中要关联的项，拖动，具体如下图所示<br><img src="/images/guanlian.png" alt="" title="" width="600"><br>如果是容器则拖动到File’s Owner,如果是其他的则拖动到view  </p>
<h3 id="4、xib约束">4、xib约束</h3>
<p>如果是autolayout，则可以添加相对约束，所添加的约束都是相对于它最近的view，添加约束方式如下图：<br><img src="/images/yueshu.png" alt="" title="" width="300"><br>如果是autoresize，添加的约束只相对于它的superview，添加约束方式如下图：<br><img src="/images/yueshu2.png" alt="" title="" width="300"><br><strong>特别注意：启用autolayout，如果添加约束，则最好所有的项目都添加约束，以免造成页面排版错乱。</strong></p>
<h3 id="5、调用xib">5、调用xib</h3>
<p>如果是容器类xib，则只需正常的init就可以。<br>如果是非容器类xib，则调用方法如下<br><em>HomeIconView \</em>iconView = [[[NSBundle mainBundle] loadNibNamed:@”HomeIconView” owner:self options:nil] lastObject];*<br>此处的@”HomeIconView”即为你创建的xib名。  </p>
<h2 id="总结">总结</h2>
<h3 id="优点">优点</h3>
<p>使用xib，可以减少代码量。<br>autolayout和autoresize配合可以方便的解决屏幕适配问题。</p>
<h3 id="缺点">缺点</h3>
<p>使用xib，frame不能定义成0.5。<br>autolayout加约束时，尽量要都加，不然会出现各种排班问题。<br>控件叠控件不能实现，例如：button上不能再加其它控件。<br>定义好的frame，有时候会自己变成0，具体原因不明。  </p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="xib简介">xib简介</h2>
<p>xib用来描述软件界面，它用Interface Builder工具来编辑。<br>本文主要介绍使用xib的一些技术，即在xib中布局UI,然后xib与code相结合，快速UI开发介绍。本文主要讲解的也就是加载xib的技术。</p>
<p>]]>
    
    </summary>
    
      <category term="xib" scheme="http://linkageios.github.io/tags/xib/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PhoneGap入门]]></title>
    <link href="http://linkageios.github.io/2014/12/26/PhoneGap%E5%85%A5%E9%97%A8/"/>
    <id>http://linkageios.github.io/2014/12/26/PhoneGap入门/</id>
    <published>2014-12-26T09:23:14.000Z</published>
    <updated>2014-12-31T01:10:35.000Z</updated>
    <content type="html"><![CDATA[<p>跨平台开发有很多框架，PhoneGap是比较著名的一个。<br><a id="more"></a></p>
<h1 id="背景">背景</h1>
<p>听说过PhoneGap很久了，却一直没有研究过。现在混合框架越来越流行，所以还是需要看看的。</p>
<h1 id="安装">安装</h1>
<p>PhoneGap<a href="http://phonegap.com/install/" target="_blank" rel="external">官网</a>上有安装方法：<br>1、安装NodeJS。<br>2、在命令行中运行：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> npm install -g phonegap</div></pre></td></tr></table></figure>

<p>3、创建项目</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>phonegap create my-app</div><div class="line"><span class="variable">$ </span>cd my-app</div><div class="line"><span class="variable">$ </span>phonegap run ios</div></pre></td></tr></table></figure>

<p>结果报错了，根据错误提示，是少安装了一个东西,安装一下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">sudo</span> npm install -g ios-deploy</div></pre></td></tr></table></figure>

<p>再重新运行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">phonegap</span> run ios</div></pre></td></tr></table></figure>

<p>这次没有报错，到对应目录下，可以找到已经生成的项目，当然只是一个Hello World项目。</p>
<p>4、运行项目<br>找到代码目录ios文件夹，打开Xcode项目即可<br><img src="http://upload-images.jianshu.io/upload_images/16632-e6e36ef76fc454bc.png" alt="phonegap2.png"></p>
<p>5、怎么修改<br>修改了项目源代码，重新编译，发现还是原来的效果。试了一会儿，发现还是要重新运行一下这个命令</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">phonegap</span> run ios</div></pre></td></tr></table></figure>

<p>6、PhoneGap Developer App<br>按照上面的方式，每次修改都要重新编译打包，是不是太麻烦了一点？PhoneGap推出了PhoneGap Developer App的软件（AppStore上有下载），先在手机上安装好。然后进入到项目目录，运行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">phonegap</span> serve</div></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/16632-ed9cc48b1886a92a.png" alt="phonegap_3.png"><br>然后打开手机上的app，输入ip。电脑和手机必须处在同一网络下<br><img src="http://upload-images.jianshu.io/upload_images/16632-8c6f1dd19c69806f.PNG" alt="phonegap_4.PNG"></p>
<p>如果成功的话就会跳到app页面，3指点击回到跳回原来的页面，四指触摸刷新应用。</p>
<p>这时候你只要在电脑端修改了源文件，点击保存。手机端会自动更新。</p>
<p>7、PhoneGap Desktop App<br>这个软件目前是beta版，也可以用。和上面的命令行效果一样。<br><a href="http://phonegap.com/blog/2014/12/11/phonegap-desktop-app-beta/" target="_blank" rel="external">http://phonegap.com/blog/2014/12/11/phonegap-desktop-app-beta/</a></p>
<p>8、各种错误<br>在测试连接的时候，一开始总是不成功，一直提示Error，Time out。原因除了不在同一个网络之外，可能还有其他原因。反正当提示ip地址是10.10开头的时候总是连不上，后来反复试几次，变成192.168就成功了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>跨平台开发有很多框架，PhoneGap是比较著名的一个。<br>]]>
    
    </summary>
    
      <category term="PhoneGap" scheme="http://linkageios.github.io/tags/PhoneGap/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SizeClass探究]]></title>
    <link href="http://linkageios.github.io/2014/12/18/SizeClass%E6%8E%A2%E7%A9%B6/"/>
    <id>http://linkageios.github.io/2014/12/18/SizeClass探究/</id>
    <published>2014-12-18T09:23:14.000Z</published>
    <updated>2014-12-22T01:01:38.000Z</updated>
    <content type="html"><![CDATA[<p>刚开始写iOS的时候，所有的分辨率都是320*480，所以UI布局都可以用代码写死。也写多iPad的代码，为了适应横屏，写了很多布局代码，当时除此之外，也没什么好的办法。后来有了iPhone5，有把原来的代码改改改……<br><a id="more"></a></p>
<h1 id="背景">背景</h1>
<p>iOS6,AutoLayout出来了，UI元素之间可以相对布局了。但这样只是解决了不同分辨率下的适配，界面中的元素不会增减，只是布局会调整。那么如果界面中的元素在不同的硬件下不一样呢？</p>
<p>毕竟，我们有了iPhone6，iPhone6 plus，以及马上就有的iWatch。一个应用，总不能在所有的设备上显示一样的界面吧？所以，苹果为了让我们不去写很多根据设备来调整界面元素的胶水代码，创造了SizeClass这个神奇的东西。</p>
<h1 id="SizeClass是什么？">SizeClass是什么？</h1>
<p>SizeClass是一个抽象的概念。对于任何尺寸，SizeClass给它定义了两种状态：Compact和Regular，分别代表不够宽和足够宽，如果两者都可以，那就是Any。</p>
<p>任何一个iOS的设备，不管是Phone、Pad还是Watch，都必然有长和宽；不管是长或者宽，它的尺寸必然是不够宽或者足够宽。到底是不够宽或者足够宽，这个苹果官方给我们规定好了。</p>
<ul>
<li><p>iPhone4S,iPhone 5/5s,iPhone 6<br>竖屏：(w:Compact h:Regular)<br>横屏：(w:Compact h:Compact)</p>
</li>
<li><p>iPhone6Plus<br>竖屏：(w:Compact h:Regular)<br>横屏：(w:Regular h:Compact)</p>
</li>
<li><p>iPad<br>竖屏：(w:Regular h:Regular)<br>横屏：(w:Regular h:Regular)</p>
</li>
<li><p>AppleWatch(猜测)<br>竖屏：(w:Compact h:Compact)<br>横屏：(w:Compact h:Compact)</p>
</li>
</ul>
<p>还有一个Any，指的是我并不关心尺寸，无论它是Compact或Regular，我都这么设计。</p>
<p>下图是IB中设计界面点开之后选择界面模式的视图。一共有9中模式，默认的是长和宽都是Any。<br><img src="http://upload-images.jianshu.io/upload_images/16632-e2d49b1788a10342.png" alt="sizeclass_1.png"></p>
<p>这些模式是有包含关系的。<br><img src="http://upload-images.jianshu.io/upload_images/16632-5c422eb24a406863.png" alt="sizeclass_2.png"></p>
<p>如果在Any，Any模式下加入了一个View，那个不管是什么设备，都会显示这个View。<br>如果在Compact，Compact模式下加入了一个View，那么之后在iPhone4S,iPhone 5/5s,iPhone 6横屏的情况下才能看到，否则不可见。在IB中，一旦你把模式切到非Compact，Compact，该控件就会置灰。<br>如果在Compact，Any模式下加入了一个View，那么在iPhone中除了6plus横屏不可见，其余都可见，ipad均不可见。</p>
<p>总而言之，SizeClass就是对设备屏幕的抽象，不管以后苹果退出再多的分辨率，都能通过这9种模式包含起来。</p>
<h1 id="SizeClass与AutoLayout的联系">SizeClass与AutoLayout的联系</h1>
<p>SizeClass和AutoLayout是两码事，而且它们是相辅相成的。SizeClass解决了不同屏幕多种设计的问题，而AutoLayout解决的是不同频幕布局适配的问题。如果你不使用AutoLayout，则不能使用SizeClass；反之是可以的。</p>
<h1 id="SizeClass还能干嘛？">SizeClass还能干嘛？</h1>
<ul>
<li>通过Image Asset为不同的SizeClass配置不同的图片</li>
<li>Label的FontSize根据不同的SizeClass设置不同的字号</li>
<li>更多有待发现……</li>
</ul>
<h1 id="SizeClass与屏幕旋转">SizeClass与屏幕旋转</h1>
<p>对于SizeClass来说，没有什么屏幕旋转的概念，有的只是切换SizeClass的模式，所以以下的几个api已经过时了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic, readonly) UIInterfaceOrientation interfaceOrientation</div><div class="line"></div><div class="line">-<span class="ruby"> <span class="symbol">willRotateToInterfaceOrientation:</span><span class="symbol">duration:</span></span></div><div class="line">-<span class="ruby"> <span class="symbol">willAnimateRotationToInterfaceOrientation:</span><span class="symbol">duration:</span></span></div><div class="line">-<span class="ruby"> <span class="symbol">didRotateFromInterfaceOrientation:</span></span></div><div class="line">-<span class="ruby"> shouldAutomaticallyForwardRotationMethods</span></div></pre></td></tr></table></figure>

<p>取而代之的是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)willTransitionToTraitCollection:(UITraitCollection *)newCollection </div><div class="line">              withTransitionCoordinator:(<span class="keyword">id</span> &lt;UIViewControllerTransitionCoordinator&gt;)coordinator</div><div class="line">{</div><div class="line">    [<span class="keyword">super</span> willTransitionToTraitCollection:newCollection </div><div class="line">                 withTransitionCoordinator:coordinator];</div><div class="line">    [coordinator animateAlongsideTransition:^(<span class="keyword">id</span> &lt;UIViewControllerTransitionCoordinatorContext&gt; context) {</div><div class="line">        <span class="keyword">if</span> (newCollection<span class="variable">.verticalSizeClass</span> == UIUserInterfaceSizeClassCompact) {</div><div class="line">            <span class="comment">//To Do: modify something for compact vertical size</span></div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">//To Do: modify something for other vertical size</span></div><div class="line">        }</div><div class="line">        [<span class="keyword">self</span><span class="variable">.view</span> setNeedsLayout];</div><div class="line">    } completion:<span class="literal">nil</span>];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>SizeClass很美好，但8.0之后才能使用，所以手头的项目暂时还用不了。</p>
<h1 id="参考">参考</h1>
<p><a href="http://onevcat.com/2014/07/ios-ui-unique/" target="_blank" rel="external">iOS界面开发的大一统</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>刚开始写iOS的时候，所有的分辨率都是320*480，所以UI布局都可以用代码写死。也写多iPad的代码，为了适应横屏，写了很多布局代码，当时除此之外，也没什么好的办法。后来有了iPhone5，有把原来的代码改改改……<br>]]>
    
    </summary>
    
      <category term="SizeClass" scheme="http://linkageios.github.io/tags/SizeClass/"/>
    
      <category term="iOS8" scheme="http://linkageios.github.io/tags/iOS8/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS8Extension之Today插件]]></title>
    <link href="http://linkageios.github.io/2014/12/15/iOS8Extension%E4%B9%8BToday%E6%8F%92%E4%BB%B6/"/>
    <id>http://linkageios.github.io/2014/12/15/iOS8Extension之Today插件/</id>
    <published>2014-12-15T09:23:14.000Z</published>
    <updated>2014-12-16T05:06:16.000Z</updated>
    <content type="html"><![CDATA[<p>iOS8已经发布了快半年时间了，其中一个重大的更新就是扩展（Extension）。以前的iOS非常封闭，不同的APP之间很难相互通信，虽然保证了使用的安全性，但毕竟限制了很多功能，最明显的就是输入法了。苹果经过了深思熟虑之后，终于给开发者们一个解决方案——扩展。<br><a id="more"></a></p>
<h2 id="背景">背景</h2>
<p>扩展包含的内容有很多：</p>
<ul>
<li>今日插件（Today widget）</li>
<li>分享（Share）</li>
<li>操作（Action）</li>
<li>图片编辑（Photo Editing）</li>
<li>文档管理（Document Provider）</li>
<li>自定义键盘（Custom keyboard）</li>
</ul>
<p>今天先介绍一下Today widget。</p>
<p>Today widget是在通知中心下面Today标签页的内容，任何APP都可以创建自己的Today widget，而且可以创建多个。用户可以在Today页面进行管理，选择那些widget是可见的，那些是不可见的。Today widget里面可以显示应用相关的数据，可以进行一些简单的操作（官方建议不要太复杂），也可以跳回主程序。Today widget即使在锁屏状态下都是可见的，所以用户使用是很简单的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/16632-646ee9ac1ba110c2.png" alt="today_widget_0.png"></p>
<h3 id="界面">界面</h3>
<p>今日插件的界面由两部分组成，最上面是一个icon和标题，下面是插件的视图。icon和标题是创建target的时候配置的，视图的话和设计普通的APP界面没什么区别。</p>
<h3 id="创建">创建</h3>
<p>假设你已经有一个APP，现在要为它创建一个今日插件。<br>1、用Xcode打开项目，选择File-&gt;New-&gt;Target，选择Today Extension;</p>
<p><img src="http://upload-images.jianshu.io/upload_images/16632-6d8f92335082ac8d.png" alt="today_widget_1.png"></p>
<p>2、输入插件名称，如MyWidget；</p>
<p><img src="http://upload-images.jianshu.io/upload_images/16632-aacafee68dd0d329.png" alt="today_widget_2.png"></p>
<p>3、最后在项目目录里面就能看到我们新建的插件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/16632-6e8a86b381e6cb0c.png" alt="today_widget_3.png"></p>
<p>这时候如果你把Scheme选为MyWidget，就可以运行看看效果了。 默认现实的是Hello World。这个实在MyWidget的MainInterface里面初始化好的。当然后面我们要改掉。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/16632-eff7cb6dfd6e6e86.PNG" alt="today_widget_5.PNG"></p>
<p>系统给我们创建一个storyboard作为初始界面，并且使用了AutoLayout。这种做法是比较推荐的，当然一定要用代码写界面也可以，就是麻烦点。</p>
<h3 id="UI样式">UI样式</h3>
<p>如果你看一下官方对于今日插件的UI指南，有两点值得注意：<br>1、尽量不要使用背景，默认的毛玻璃效果很好，也比较统一；<br>2、尽量保持默认的缩进，即左边会空几个像素。</p>
<p>如果想改变默认缩进，有一个方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIEdgeInsets</span>)widgetMarginInsetsForProposedMarginInsets:(<span class="built_in">UIEdgeInsets</span>)defaultMarginInsets</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> UIEdgeInsetsZero;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在TodayViewController里面实现以下，缩进就没有了。</p>
<h3 id="跳转到主应用">跳转到主应用</h3>
<p>我们在插件的storyboard上加几个按钮，分别跳转到主应用的不同页面，怎么办呢？<br>通过OpenUrl方法，self.extensionContext其实就是Today这个app，然后有Today和主应用进行进程间通讯，里面很复杂，但方法封装的很简单，就是OpenUrl：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)menuPressed:(<span class="keyword">id</span>)sender</div><div class="line">{</div><div class="line">    <span class="built_in">UIButton</span>* button = (<span class="built_in">UIButton</span>*)sender;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (button<span class="variable">.tag</span> == <span class="number">1</span>) {</div><div class="line">        [<span class="keyword">self</span><span class="variable">.extensionContext</span> openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"iOSWidgetApp://action=GotoHomePage"</span>] completionHandler:^(<span class="built_in">BOOL</span> success) {</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"open url result:%d"</span>,success);</div><div class="line">        }];</div><div class="line">    }</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(button<span class="variable">.tag</span> == <span class="number">2</span>) {</div><div class="line">        [<span class="keyword">self</span><span class="variable">.extensionContext</span> openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"iOSWidgetApp://action=GotoOrderPage"</span>] completionHandler:^(<span class="built_in">BOOL</span> success) {</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"open url result:%d"</span>,success);</div><div class="line">        }];</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>协议名是iOSWidgetApp，这个要在主应用的plist里面注册一下<br><img src="http://upload-images.jianshu.io/upload_images/16632-8df6a709f3a34305.png" alt="today_widget_6.png"></p>
<p>然后在主应用的AppDelegate解析协议，进行不同的操作。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application openURL:(<span class="built_in">NSURL</span> *)url sourceApplication:(<span class="built_in">NSString</span> *)sourceApplication annotation:(<span class="keyword">id</span>)annotation</div><div class="line">{</div><div class="line">    <span class="built_in">NSString</span>* prefix = <span class="string">@"iOSWidgetApp://action="</span>;</div><div class="line">    <span class="keyword">if</span> ([[url absoluteString] rangeOfString:prefix]<span class="variable">.location</span> != <span class="built_in">NSNotFound</span>) {</div><div class="line">        <span class="built_in">NSString</span>* action = [[url absoluteString] substringFromIndex:prefix<span class="variable">.length</span>];</div><div class="line">        <span class="keyword">if</span> ([action isEqualToString:<span class="string">@"GotoHomePage"</span>]) {</div><div class="line">            </div><div class="line">        }</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>([action isEqualToString:<span class="string">@"GotoOrderPage"</span>]) {</div><div class="line">            BasicHomeViewController *vc = (BasicHomeViewController*)<span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span>;</div><div class="line">            [vc<span class="variable">.tabbar</span> selectAtIndex:<span class="number">2</span>];</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span>  <span class="literal">YES</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="数据共享">数据共享</h3>
<p>今日插件怎么能获取主应用的数据呢？要知道插件和主应用是独立的两个进程，以前是无法共享数据的，现在可以通过AppGroup来共享数据，同属于一个group的App共同访问并修改某个数据。</p>
<h3 id="创建Group">创建Group</h3>
<p>选中主应用的Target，选择Capabilities，创建一个group，名字叫group.xxx，然后到插件的target勾选刚才创建的group，这样就ok了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/16632-3fb14cbab8baa6d6.png" alt="today_widget_7.png"></p>
<h3 id="读写数据">读写数据</h3>
<p>通过NSUserDefaults来读写数据，注意NSUserDefaults是根据刚才创建的group来创建的。我们在主应用里加入如下代码，这样今日插件就有数据可读了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSUserDefaults* userDefault = [[NSUserDefaults alloc] initWithSuiteName:@<span class="string">"group.huijia"</span>];</div><div class="line">[userDefault <span class="keyword">set</span>Object:@<span class="string">"nmj"</span> <span class="keyword">for</span>Key:@<span class="string">"group.huijia.nickname"</span>];</div></pre></td></tr></table></figure>

<p>今日插件里面的代码，这样就能根据主应用的状态更新插件的状态。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSUserDefaults</span>* userDefault = [[<span class="built_in">NSUserDefaults</span> alloc] initWithSuiteName:<span class="string">@"group.huijia"</span>];</div><div class="line">    <span class="built_in">NSString</span>* nickName = [userDefault objectForKey:<span class="string">@"group.huijia.nickname"</span>];</div><div class="line">    <span class="keyword">if</span> (nickName) {</div><div class="line">        <span class="built_in">NSString</span>* message = <span class="string">@"今天XX又给你准备了很多惊喜哦，快去看看吧！"</span>;</div><div class="line">        <span class="keyword">self</span><span class="variable">.messageLabel</span><span class="variable">.text</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@,%@"</span>,nickName,message];</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>最终效果：根据用户是否已经在主应用里面登录，显示不同的message，有两个按钮，跳转到主应用不同的页面。<br><img src="http://upload-images.jianshu.io/upload_images/16632-d8e741c33f75570c.PNG" alt="today_widget_8.PNG"></p>
<h3 id="参考文档">参考文档</h3>
<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/NotificationCenter.html#//apple_ref/doc/uid/TP40014214-CH11-SW1" target="_blank" rel="external">官方指南</a><br><a href="https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/MobileHIG/AppExtensions.html#//apple_ref/doc/uid/TP40006556-CH67-SW4" target="_blank" rel="external">UI指南</a><br><a href="http://www.onevcat.com/2014/08/notification-today-widget/" target="_blank" rel="external">iOS 通知中心扩展制作入门</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>iOS8已经发布了快半年时间了，其中一个重大的更新就是扩展（Extension）。以前的iOS非常封闭，不同的APP之间很难相互通信，虽然保证了使用的安全性，但毕竟限制了很多功能，最明显的就是输入法了。苹果经过了深思熟虑之后，终于给开发者们一个解决方案——扩展。<br>]]>
    
    </summary>
    
      <category term="插件" scheme="http://linkageios.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="iOS8" scheme="http://linkageios.github.io/tags/iOS8/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SVPullToRefresh与下拉刷新]]></title>
    <link href="http://linkageios.github.io/2014/12/03/SVPullToRefresh%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://linkageios.github.io/2014/12/03/SVPullToRefresh深入理解/</id>
    <published>2014-12-03T07:59:00.000Z</published>
    <updated>2014-12-11T05:54:57.000Z</updated>
    <content type="html"><![CDATA[<p>SVPullToRefresh是iOS上实现下拉刷新和上提加载的一个组件。<br><a id="more"></a></p>
<h3 id="背景">背景</h3>
<p>使用场景仅限UIScrollView，只需要一行代码，就能添加下拉刷新的功能。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[tableView addPullToRefreshWithActionHandler:^{</div><div class="line">    <span class="comment">// 预加载数据到dataSource, 向tableview插入cell</span></div><div class="line">    <span class="comment">// 完成时调用[tableView.pullToRefreshView stopAnimating] </span></div><div class="line">}];</div></pre></td></tr></table></figure>

<p>准备研究之前google了一把SVPullToRefresh，发现除了github的官方地址，排在最前面的居然是我去年写的一篇<a href="http://blog.csdn.net/itenric/article/details/12391185" target="_blank" rel="external">博客</a>。重新看了一遍，发现自己当时讲的很浅，很多关键的东西都是一笔带过，没有讲清楚。所以今天重写一篇，深入地介绍一下这个优秀的组件。</p>
<h3 id="铺垫">铺垫</h3>
<h6 id="Associative（关联）">Associative（关联）</h6>
<p>一个不可修改的类，如果要增加方法，可以用Category；但如果要添加属性，Category就无能为力了，只能使用Associative。Associative和Category同属于Runtime的运用，只是Category属于语法级别的封装，而要使用Associative必须显示地引用头文件<objc runtime.h="">。<br>Associative一共包含三个方法：</objc></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置属性</span></div><div class="line"><span class="comment">//第一个参数是原始对象，第二个参数是关联对象的key，第三个参数是关联对象本身，第四个参数是关联的策略。</span></div><div class="line"><span class="comment">//如果第三个参数是nil，则清空当前关联。</span></div><div class="line">OBJC_EXPORT <span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy)</div><div class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);</div><div class="line"></div><div class="line"><span class="comment">//访问属性</span></div><div class="line"><span class="comment">//第一个参数是原始对象，第二个参数是关联对象的key</span></div><div class="line">OBJC_EXPORT <span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</div><div class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);</div><div class="line"></div><div class="line"><span class="comment">//移除所有属性</span></div><div class="line"><span class="comment">//参数是原始对象</span></div><div class="line"><span class="comment">//这个方法会把对象重置回初始状态，因为无法保证别的地方是否也为该对象设置为关联对象。</span></div><div class="line"><span class="comment">//所以在尽量使用objc_setAssociatedObject，并把第三个参数设成nil来替代。</span></div><div class="line">OBJC_EXPORT <span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object)</div><div class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);</div></pre></td></tr></table></figure>

<p>关联策略（objc_AssociationPolicy）一共有5种类型，参照Property的定义，应该不难理解它们之间的区别。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> {</div><div class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="javadoc">/**&lt; Specifies a weak reference to the associated object. */</span></div><div class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="javadoc">/**&lt; Specifies a strong reference to the associated object. </span></div><div class="line">                                            *   The association is not made atomically. */</div><div class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="javadoc">/**&lt; Specifies that the associated object is copied. </span></div><div class="line">                                            *   The association is not made atomically. */</div><div class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="javadoc">/**&lt; Specifies a strong reference to the associated object.</span></div><div class="line">                                            *   The association is made atomically. */</div><div class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="javadoc">/**&lt; Specifies that the associated object is copied.</span></div><div class="line">                                            *   The association is made atomically. */</div><div class="line">};</div></pre></td></tr></table></figure>

<p>  <a href="http://nshipster.cn/associated-objects/" target="_blank" rel="external">更多参考</a></p>
<h6 id="@dynamic属性声明">@dynamic属性声明</h6>
<p>正常的属性都是用@synthesize来声明的（XCode4.0之后不需要了，编译时会自动生成get、set方法）。但是有时候我们的get、set方法要在运行时才动态绑定，这时就要用@dynamic。</p>
<h6 id="KVO">KVO</h6>
<p>KVO是用来检测对象的某个属性是否发生变化的机制。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//加入观察者</span></div><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(NSKeyValueObservingOptions)options context:(<span class="keyword">void</span> *)context;</div><div class="line"></div><div class="line"><span class="comment">//移除观察者</span></div><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</div></pre></td></tr></table></figure>

<h3 id="PullToRefresh实现机制">PullToRefresh实现机制</h3>
<p>PullToRefresh就是在UIScrollView上面add了一个subview：PullToRefreshView。这个PullToRefreshView就是一个普通的View，宽度和UIScrollView相同，高度可以自定义，默认是60。</p>
<p>PullToRefreshView有四种状态：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, SVPullToRefreshState) {</div><div class="line"><span class="constant">    SVPullToRefreshStateStopped</span> = <span class="number">0</span>,</div><div class="line"><span class="constant">    SVPullToRefreshStateTriggered,</span></div><div class="line">    SVPullToRefreshStateLoading,</div><div class="line">    SVPullToRefreshStateAll = <span class="number">10</span></div><div class="line">};</div></pre></td></tr></table></figure>

<ul>
<li>SVPullToRefreshStateStopped：刷新停止状态，还没有触发刷新操作。</li>
<li>SVPullToRefreshStateTriggered：刷新操作被触发，但还没有开始发送请求（只要用户手还没松开，不会发送请求）</li>
<li>SVPullToRefreshStateLoading：已经发送请求，但数据还没回来，这时菊花一直在转。这时候UITableView的contentInset已经修改，使PullToRefreshView可见。</li>
<li>SVPullToRefreshStateAll：初始化的时候用的。</li>
</ul>
<p>如果不需要自定义，PullToRefreshView内置了一个默认版本，包含箭头、title、subtitle、time。</p>
<p>自定义也可以，在PullToRefreshView的viewForState数组中加入三中状态的视图，然后就可以显示自定义的UI了。</p>
<p>PullToRefreshView是UIScrollView的一个属性，这个属性是通过关联的方式绑定的。当用户滚动UIScrollView的时候，ContentOffset会发生变化，这时候UIScrollView的观察者PullToRefreshView就会收到通知，然后根据PullToRefreshView自身的状态和ContentOffset决定是否切换状态，并执行相应动画。</p>
<h3 id="自定义">自定义</h3>
<p>SVPullToRefresh自带的自定义功能比较鸡肋，就是根据不同的状态换不同的View。当你想做更多个性化的动画时，就比较捉急了。所以，我准备只保留其最核心的部分，比如关联、KVO、四个状态，然后整体的动画都重新写。效果图如下（话说这个动画设计的实在是low）：</p>
<p><img src="/images/16632-ba39e932e38e20d7.gif" alt="loading.gif"></p>
<p>动画分成两个阶段：</p>
<ul>
<li>第一个阶段是还没进入加载阶段，这时候随着下拉的高度，中间的图片逐渐变大，扇形区域也逐渐变大。</li>
<li>第二个阶段是加载过程中，中间的图片开始旋转，同时像两侧发射出几个小图，旋转的同时透明度也发生变化，并来回震荡，直到加载结束。</li>
</ul>
<p>代码是基于SVPullToRefresh修改的，把用不着的代码全删了。项目已上传：<a href="https://github.com/tenric/SVPullToRefreshDemo" target="_blank" rel="external">Github</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>SVPullToRefresh是iOS上实现下拉刷新和上提加载的一个组件。<br>]]>
    
    </summary>
    
      <category term="网络" scheme="http://linkageios.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
      <category term="AFNetworking" scheme="http://linkageios.github.io/categories/iOS/AFNetworking/"/>
    
      <category term="重构" scheme="http://linkageios.github.io/categories/iOS/AFNetworking/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sourceTree使用注意事项]]></title>
    <link href="http://linkageios.github.io/2014/12/03/sourceTree%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://linkageios.github.io/2014/12/03/sourceTree使用注意事项/</id>
    <published>2014-12-03T02:24:53.000Z</published>
    <updated>2014-12-03T02:58:53.000Z</updated>
    <content type="html"><![CDATA[<h1 id="sourceTree使用注意事项">sourceTree使用注意事项</h1>
<ul>
<li>更正上次文档《关于文档类工作输出要求》的错误，其中<code>其中图片必须使用本地相对路径![imag](../images/xxx.png)</code>应该为<code>其中图片必须使用本地相对路径![imag](/images/xxx.png)</code></li>
<li>点击list条目进入sourceTree工程页面<br><img src="/images/gitlist.png" alt="image"><br><br></li>
<li>点击顶部菜单栏的“抓取-fetch”，然后勾选<code>删除在所有远端都已经不存在的跟踪（tracking）分支</code><br><img src="/images/gitmenu.png" alt="image"><br><br></li>
</ul>
<p>这样就可以了同步本地的分支（服务器上已被删除而本地却有）了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="sourceTree使用注意事项">sourceTree使用注意事项</h1>
<ul>
<li>更正上次文档《关于文档类工作输出要求》的错误，其中<code>其中图片必须使用本地相对路径![imag](../images/xxx.png)</code>应该为<c]]>
    </summary>
    
      <category term="版本管理" scheme="http://linkageios.github.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[内存管理培训ppt]]></title>
    <link href="http://linkageios.github.io/2014/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://linkageios.github.io/2014/12/02/内存管理/</id>
    <published>2014-12-02T01:20:08.000Z</published>
    <updated>2014-12-03T02:51:28.000Z</updated>
    <content type="html"><![CDATA[<p><a id="more"></a></p>
<h1 id="内存管理培训ppt">内存管理培训ppt</h1>
<p><a href="/extr/内存管理.ppt">ppt</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>]]>
    
    </summary>
    
      <category term="内存" scheme="http://linkageios.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义控件说明]]></title>
    <link href="http://linkageios.github.io/2014/12/01/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E8%AF%B4%E6%98%8E/"/>
    <id>http://linkageios.github.io/2014/12/01/自定义控件说明/</id>
    <published>2014-12-01T07:59:00.000Z</published>
    <updated>2014-12-11T03:01:15.000Z</updated>
    <content type="html"><![CDATA[<p>自定义控件能满足快速迭代的需要，我把常用的控件整理出来，欢迎使用。<br><a id="more"></a></p>
<h4 id="1-PageControl">1.PageControl</h4>
<p>由于系统的PageControl控件的限制，不能修改颜色，更换图片，修改大小。所以开发了此控件。</p>
<p><img src="/images/77211-6b437f8229b8d900.gif" alt="pagecontrol.gif"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/*默认使用颜色填充,还有其他参数可以修改* /</div><div class="line"><span class="constant">_pageControl.numberOfPages</span> = <span class="number">5</span>;<span class="comment">//一共多少页</span></div><div class="line">[_pageControl setOffColor: [UIColor  whiteColor]];<span class="comment">//非当前页的圆点颜色</span></div><div class="line">[_pageControl setOnColor: [UIColor redColor]];<span class="comment">//当前页的圆点颜色</span></div><div class="line">[_pageControl setIndicatorDiameter: <span class="number">7.0</span>f] ;<span class="comment">//圆点的直径</span></div><div class="line">[_pageControl setIndicatorSpace: <span class="number">12.0</span>f] ;<span class="comment">//圆点之间的距离</span></div></pre></td></tr></table></figure>

<h4 id="2-倒计时控件">2.倒计时控件</h4>
<p>项目中经常用到获取验证码的控件，用NSTimer控制时间，刷新按钮等。整理出来，避免代码冗余，使逻辑清晰。</p>
<p><img src="/mages/77211-2a819e6b50a4e17f.gif" alt="倒计时.gif"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">IBOutlet</span> LCCountDownButton *_countDownButton;<span class="comment">//定义</span></div><div class="line">_countDownButton<span class="variable">.timeOut</span> = <span class="number">10</span>;<span class="comment">//设置时间，默认是60秒</span></div><div class="line"></div><div class="line">按钮点击事件方法中调用：</div><div class="line">[_countDownButton beginCountDown];<span class="comment">//开始计时</span></div></pre></td></tr></table></figure>

<h4 id="3-PlaceHolderTextView">3.PlaceHolderTextView</h4>
<p>系统的textview控件无法添加提示语，不能修改颜色，大小，对齐方式。提示语在没有内容时显示，填写的时候自动隐藏。<br><img src="/images/77211-b55d156a76bd77cc.gif" alt="textView.gif"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="constant">_textView.placeholder</span> = @<span class="string">"请输入你想说的话..."</span>;<span class="comment">//提示文本</span></div><div class="line"><span class="constant">_textView.placeholderColor</span> = [UIColor redColor];<span class="comment">//文本颜色</span></div><div class="line"><span class="comment">//_textView.placeHolderTextAlignment = NSTextAlignmentCenter;//对齐方式，默认左对齐</span></div></pre></td></tr></table></figure>

<h4 id="4-评分控件">4.评分控件</h4>
<p>此控件有两个功能：<br>1）仅仅显示评分，一份代表一颗星，总分可以设置。<br>2）点击评分功能。</p>
<p><img src="/images/77211-b59fc8ef654ca40a.gif" alt="starRating.gif"></p>
<h4 id="5-跑马灯效果">5.跑马灯效果</h4>
<p>项目中如果文字过长，由于屏幕宽度的限制，显示不完整，但是文本又不能截取。跑马灯是这种情况下最好的解决方案。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/77211-3c2a3f3fcd13cdcb.gif" alt="跑马灯.gif"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[_label setText:@<span class="string">"你发如雪 凄美了离别 我焚香感动了谁 邀明月 让回忆皎洁 爱在月光下完美"</span>];<span class="comment">//跑马灯文本</span></div><div class="line"><span class="constant">_label.backgroundColor</span> = [UIColor clearColor];</div><div class="line"><span class="constant">_label.subLabel.backgroundColor</span> = [UIColor clearColor];</div><div class="line"><span class="constant">_label.subLabel.textColor</span> = [UIColor redColor];<span class="comment">//文本颜色</span></div></pre></td></tr></table></figure>

<h4 id="6-标签TagView">6.标签TagView</h4>
<p>如下图所示。此控件经常用来显示个性标签。<br><img src="/images/77211-3c91a3611c9dc5e4.png" alt="tagView.png"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义标签的文本属性</span></div><div class="line">TagAttribute *attr = [[TagAttribute alloc] init];</div><div class="line">attr<span class="variable">.textBackgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];<span class="comment">//背景色</span></div><div class="line">attr<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.0</span> green:<span class="number">144.0</span>/<span class="number">255.0</span> blue:<span class="number">1.0</span> alpha:<span class="number">1.0</span>];<span class="comment">//文本颜色</span></div><div class="line">attr<span class="variable">.textFont</span> = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">12.0</span>];<span class="comment">//文本大小</span></div><div class="line">attr<span class="variable">.borderDisplay</span> = <span class="literal">YES</span>;<span class="comment">//是否显示边框</span></div><div class="line">attr<span class="variable">.borderColor</span> = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">140.0</span>/<span class="number">255.0</span> green:<span class="number">204.0</span>/<span class="number">255.0</span> blue:<span class="number">1.0</span> alpha:<span class="number">1.0</span>];<span class="comment">//文本框颜色</span></div><div class="line">attr<span class="variable">.horizotalPadding</span> = <span class="number">3.0</span>;<span class="comment">//间隔</span></div><div class="line">_tagView<span class="variable">.tagAttribute</span> = attr;</div><div class="line">    </div><div class="line"></div><div class="line">_tagView<span class="variable">.tags</span> = @[<span class="string">@"自驾游"</span>,<span class="string">@"爱吹牛"</span>,<span class="string">@"90后"</span>,<span class="string">@"王菲"</span>,<span class="string">@"爱我别走，如果你说"</span>,<span class="string">@"喜欢陶喆"</span>,<span class="string">@"发如雪，凄美"</span>];<span class="comment">//标签内容，用数组传递。自动计算</span></div><div class="line">[_tagView displayTags];<span class="comment">//开始绘制</span></div></pre></td></tr></table></figure>

<h4 id="7-segmentControl">7.segmentControl</h4>
<p>此控件的主要作用就是减少冗余重复代码，减少开发者重复的判断和多余的开发。<br>只需要在布局文件上把父view类换成SegmentControl类别，可以达到自动控制。<br><img src="http://upload-images.jianshu.io/upload_images/77211-af0166c1671a787d.gif" alt="segmentControl.gif"></p>
<p>此控件不需要写代码。仅仅连接把父类类别更改即可。</p>
<p>以上所有代码: <a href="https://github.com/angelacc1989/LCControlDemo" title="" target="_blank" rel="external"><br>LCControlDemo</a> </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>自定义控件能满足快速迭代的需要，我把常用的控件整理出来，欢迎使用。<br>]]>
    
    </summary>
    
      <category term="控件" scheme="http://linkageios.github.io/tags/%E6%8E%A7%E4%BB%B6/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
      <category term="控件" scheme="http://linkageios.github.io/categories/iOS/%E6%8E%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于文档类工作输出要求]]></title>
    <link href="http://linkageios.github.io/2014/12/01/%E5%85%B3%E4%BA%8E%E6%96%87%E6%A1%A3%E7%B1%BB%E5%B7%A5%E4%BD%9C%E8%BE%93%E5%87%BA%E8%A6%81%E6%B1%82/"/>
    <id>http://linkageios.github.io/2014/12/01/关于文档类工作输出要求/</id>
    <published>2014-12-01T05:24:53.000Z</published>
    <updated>2014-12-03T02:51:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="模板说明">模板说明</h2>
<ul>
<li>title 文档的标题</li>
<li>data 文档编写或修改的时间</li>
<li>categories 文档的类别，多个以半角逗号和方括号构成</li>
<li>tags 文档的tag，多个以半角逗号和方括号构成</li>
<li>分隔符—-这一行保留</li>
<li><code>&lt;!--more--&gt;</code>和分隔符<code>---</code>之间的内容为文档摘要</li>
<li>其中图片必须使用本地相对路径<code>![imag](/images/xxx.png)</code></li>
<li>文档提交地址<a href="http://172.16.128.161/ios/technology-blog.git" target="_blank" rel="external">http://172.16.128.161/ios/technology-blog.git</a></li>
<li>文档地址 ./source/_posts/*.md</li>
<li>图片地址 ./source/images/*.png</li>
<li>xxx 正文<br><a id="more"></a><h1 id="关于文档类工作输出要求">关于文档类工作输出要求</h1>
</li>
</ul>
<h2 id="模板">模板</h2>
<pre><code>title: iOS代码规范
date: 2014-11-07 13:38:14
categories: [iOS,执行文档]
tags: [效率]
---
# 代码规范的内容？
代码规范包含的范围十分广泛。从一个变量的命名到一个类的设计，我觉得都属于代码规范的范畴。从实践的角度，可以把代码规范分成两个部分：
第一部分是规则，即一定要这么做。这里面没有对错，但需要统一。包含变量的命名、函数的命名、模块的组织、代码块的组织、宏、枚举、常量的声明、函数的粒度。
第二部分是风格，即一种模式化的代码设计结构。我们实现某个功能时，往往不止一种实现方式。每一种实现    方式没有绝对的高低之分，不同角度的解读，就会有不同的偏好。所以这个层面上的代码规范，只能求同存异。但是不管怎样，每个人必须要有一致性的风格。就像不同的小区可以有不同的风格，但同一个小区只能有一种设计风格。风格包含代码设计中的抽象概念，比如接口、继承等等。
<span class="comment">&lt;!--more--&gt;</span>
xxxxxx
</code></pre><h2 id="模板说明-1">模板说明</h2>
<ul>
<li>title 文档的标题</li>
<li>data 文档编写或修改的时间</li>
<li>categories 文档的类别，多个以半角逗号和方括号构成</li>
<li>tags 文档的tag，多个以半角逗号和方括号构成</li>
<li>分隔符—-这一行保留</li>
<li><code>&lt;!--more--&gt;</code>和分隔符<code>---</code>之间的内容为文档摘要</li>
<li>其中图片必须使用本地相对路径<code>![imag](/images/xxx.png)</code></li>
<li>文档提交地址<a href="http://172.16.128.161/ios/technology-blog.git" target="_blank" rel="external">http://172.16.128.161/ios/technology-blog.git</a></li>
<li>文档地址 ./source/_posts/*.md</li>
<li>图片地址 ./source/images/*.png</li>
<li>xxx 正文</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="模板说明">模板说明</h2>
<ul>
<li>title 文档的标题</li>
<li>data 文档编写或修改的时间</li>
<li>categories 文档的类别，多个以半角逗号和方括号构成</li>
<li>tags 文档的tag，多个以半角逗号和方括号构成</li>
<li>分隔符—-这一行保留</li>
<li><code>&lt;!--more--&gt;</code>和分隔符<code>---</code>之间的内容为文档摘要</li>
<li>其中图片必须使用本地相对路径<code>![imag](/images/xxx.png)</code></li>
<li>文档提交地址<a href="http://172.16.128.161/ios/technology-blog.git" target="_blank" rel="external">http://172.16.128.161/ios/technology-blog.git</a></li>
<li>文档地址 ./source/_posts/*.md</li>
<li>图片地址 ./source/images/*.png</li>
<li>xxx 正文<br>]]>
    
    </summary>
    
      <category term="效率" scheme="http://linkageios.github.io/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
      <category term="执行文档" scheme="http://linkageios.github.io/categories/iOS/%E6%89%A7%E8%A1%8C%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[支付整合]]></title>
    <link href="http://linkageios.github.io/2014/11/30/%E6%94%AF%E4%BB%98%E6%95%B4%E5%90%88/"/>
    <id>http://linkageios.github.io/2014/11/30/支付整合/</id>
    <published>2014-11-30T07:59:00.000Z</published>
    <updated>2014-12-11T03:01:15.000Z</updated>
    <content type="html"><![CDATA[<p>对招行网页支付接口和银联支付sdk进行封装。<br><a id="more"></a></p>
<p>tips：根据安排整合支付模块</p>
<ul>
<li>结构说明</li>
</ul>
<p><img src="/images/79888-f225cd39b214aa91.png" alt="99042A97-1C41-4F22-A736-4EE199A32C6D.png"></p>
<p>LCPayManager 提供了支付方法和一个回掉查看支付结果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>orderPayMode:<span class="params">(<span class="variable">PayWay</span>)</span>payway orderInfo:<span class="params">(<span class="variable">LCPayBaseVo</span> *)</span>vo;</span></div></pre></td></tr></table></figure>

<p>其中PayWay是支付方式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, PayWay)</div><div class="line">{</div><div class="line"><span class="constant">    PayWayByAlipay</span>      = <span class="number">1</span>,</div><div class="line"><span class="constant">    PayWayByCMB</span>         = <span class="number">2</span>,</div><div class="line"><span class="constant">    PayWayByCash</span>        = <span class="number">3</span>,</div><div class="line"><span class="constant">    PayWayByUnionPay</span>    = <span class="number">4</span>,</div><div class="line">};</div></pre></td></tr></table></figure>

<p>vo 是一个存储支付相关信息的类，里面包含基本的商品信息</p>
<p>暂时直邮银联和招商两种支付方式，所以就提供了两种模式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">LCCMBPayMode</span></div><div class="line">LCUnionPayMode</div></pre></td></tr></table></figure>

<ul>
<li>使用<br>银联</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> LCPayUnionVo *<span class="variable">vo =</span> [[LCPayUnionVo alloc]init];</div><div class="line"> vo.<span class="variable">orderid =</span> backHead.tn;</div><div class="line"> vo.<span class="variable">viewController =</span> self;</div><div class="line">[LCPayManager sharedInstance].<span class="variable">delegate =</span> self;</div><div class="line">[[LCPayManager sharedInstance] orderPayMode:PayWayByUnionPay orderInfo:vo];</div></pre></td></tr></table></figure>

<p>招商</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">LCPayManager *<span class="variable">ma =</span> [LCPayManager sharedInstance];</div><div class="line">ma.<span class="variable">delegate =</span> self;</div><div class="line">LCPayCMBVo *<span class="variable">vo =</span> [[LCPayCMBVo alloc]init];</div><div class="line">vo.<span class="variable">branchId =</span> backHead.branchId;</div><div class="line">vo.<span class="variable">coNo =</span> backHead.coNo;</div><div class="line">vo.<span class="variable">orderid =</span> backHead.billNo;</div><div class="line">vo.<span class="variable">amount =</span> backHead.amount;</div><div class="line">vo.<span class="variable">date =</span> backHead.date;</div><div class="line">vo.<span class="variable">merchantUrl =</span> backHead.merchantUrl;</div><div class="line">vo.<span class="variable">merchantPara =</span> backHead.merchantPara;</div><div class="line">[ma orderPayMode:PayWayByCMB orderInfo:vo];</div></pre></td></tr></table></figure>

<p>所有的支付结果在中反回</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> - (<span class="type">void</span>)didFinishPayWithResult:(<span class="type">NSString</span> *)<span class="literal">result</span></div><div class="line">{</div><div class="line">    <span class="type">NSLog</span>(@<span class="string">"didFinishPayWithResult is %@"</span>,<span class="literal">result</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为CMB是跳外部浏览器的，所以在AppDelegate中也要做相应处理<br><code>- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation</code><br>添加[LCPayManager sharedInstance].mresult的赋值</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对招行网页支付接口和银联支付sdk进行封装。<br>]]>
    
    </summary>
    
      <category term="支付" scheme="http://linkageios.github.io/tags/%E6%94%AF%E4%BB%98/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
      <category term="SDK" scheme="http://linkageios.github.io/categories/iOS/SDK/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图片处理Demo]]></title>
    <link href="http://linkageios.github.io/2014/11/29/%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA/"/>
    <id>http://linkageios.github.io/2014/11/29/图片裁剪/</id>
    <published>2014-11-29T07:59:00.000Z</published>
    <updated>2014-12-11T03:01:15.000Z</updated>
    <content type="html"><![CDATA[<p>图片处理是iOS APP中一个常见的功能。<br><a id="more"></a></p>
<p>关于图片的裁剪，一般的需求是通过手势自定裁剪尺寸，如常见的美图软件。另外一种就是按照既定的比例裁剪，比如4：3， 16：9之类的。<br>这个demo主要做了两种裁剪方式。用法在demo已经写出。<br>主要看一下效果：</p>
<p><img src="/images/77211-f131390e450f1ea0.gif" alt="裁剪.gif"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>图片处理是iOS APP中一个常见的功能。<br>]]>
    
    </summary>
    
      <category term="图片" scheme="http://linkageios.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
      <category term="图片处理，剪裁" scheme="http://linkageios.github.io/categories/iOS/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%EF%BC%8C%E5%89%AA%E8%A3%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网络请求重构说明]]></title>
    <link href="http://linkageios.github.io/2014/11/28/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E9%87%8D%E6%9E%84%E8%AF%B4%E6%98%8E/"/>
    <id>http://linkageios.github.io/2014/11/28/网络请求重构说明/</id>
    <published>2014-11-28T07:59:00.000Z</published>
    <updated>2014-12-11T02:10:58.000Z</updated>
    <content type="html"><![CDATA[<p>这周主要在做网络请求的重构，在参考了很多开源的项目之后，做了一个基本的Demo。本文主要讲一下基本的使用方法，不涉及原理。<br><a id="more"></a></p>
<h3 id="背景">背景</h3>
<p>参考的项目有</p>
<ul>
<li><a href="https://github.com/Mantle/Mantle" target="_blank" rel="external">Mantle</a>：模型层的的封装框架，解决了json转object的问题。</li>
<li><a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="external">YTKNetwork</a>：网络请求的封装，基于AFNetworking，提供了普通请求，批量请求和依赖请求的处理。回调方法支持block和delegate两种模式。</li>
</ul>
<h3 id="用法">用法</h3>
<h6 id="如何创建一个请求">如何创建一个请求</h6>
<p>程序启动完成后先配置一下baseUrl：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LCNetworkConfig <span class="keyword">*</span>config = [LCNetworkConfig sharedInstance];</div><div class="line">config.baseUrl = <span class="comment">@"http://;</span></div></pre></td></tr></table></figure>

<p>创建请求首先要继承一个请求类，并声明初始化方法，初始化方法里面的参数就是请求要用到的参数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//.h文件</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UserLoginApi</span> : <span class="title">LCRequest</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithLoginName:(<span class="built_in">NSString</span> *)loginName</div><div class="line">               password:(<span class="built_in">NSString</span> *)password;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//.m文件</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UserLoginApi</span> </span>{</div><div class="line">    <span class="built_in">NSString</span> *_loginName;</div><div class="line">    <span class="built_in">NSString</span> *_password;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//初始化方法</span></div><div class="line">- (<span class="keyword">id</span>)initWithLoginName:(<span class="built_in">NSString</span> *)loginName</div><div class="line">               password:(<span class="built_in">NSString</span> *)password</div><div class="line">{</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) {</div><div class="line">        _loginName = loginName;</div><div class="line">        _password = password;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//请求的api，必须实现，如果有path类型的参数，需要从初始化方法里面把参数传进来，然后在这里拼装</span></div><div class="line">- (<span class="built_in">NSString</span> *)requestUrl {</div><div class="line">    <span class="keyword">return</span> <span class="string">@"/login"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//请求方法，必须实现</span></div><div class="line">- (LCRequestMethod)requestMethod {</div><div class="line">    <span class="keyword">return</span> LCRequestMethodPost;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//请求参数合成，如果没有请求参数，也可以不实现</span></div><div class="line">- (<span class="keyword">id</span>)requestArgument {</div><div class="line">    <span class="built_in">NSString</span>* tokenId = [USER_DEFAULT objectForKey:USERDEFAULTS_KEY_TOKENID];</div><div class="line">    <span class="built_in">NSString</span>* clientId = [USER_DEFAULT objectForKey:USERDEFAULTS_KEY_REGISTERID];</div><div class="line">    <span class="keyword">return</span> @{</div><div class="line">             <span class="string">@"loginName"</span>: _loginName,</div><div class="line">             <span class="string">@"password"</span>: _password,</div><div class="line">             <span class="string">@"source"</span>: <span class="string">@"iphone"</span>,</div><div class="line">             <span class="string">@"sign"</span>: <span class="string">@"ios"</span>,</div><div class="line">             <span class="string">@"versionNo"</span>: [LCSystemUtil appVersion],</div><div class="line">             <span class="string">@"iosTokenId"</span>: [LCStringUtil safeString:tokenId],</div><div class="line">             <span class="string">@"clientId"</span>: [LCStringUtil safeString:clientId]</div><div class="line">             };</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>实现了请求的Api对象之后，就可以发送请求了，发送请求有两种方式：Block和Delegate：<br>Block方式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CityQueryApi<span class="keyword">*</span> api = [[CityQueryApi alloc] init];</div><div class="line">[api startWithCompletionBlockWithSuccess:^(LCBaseRequest <span class="keyword">*</span>request) {</div><div class="line">       </div><div class="line">} failure:^(LCBaseRequest <span class="keyword">*</span>request) {</div><div class="line">   </div><div class="line">}];</div></pre></td></tr></table></figure>

<p>Delegate方式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="variable">CityQueryApi</span>* api = [[<span class="variable">CityQueryApi</span> alloc] init];</div><div class="line">api.delegate = self;</div><div class="line">[api start];</div><div class="line"></div><div class="line"><span class="pp">- <span class="params">(void)</span>requestFinished:<span class="params">(<span class="variable">LCBaseRequest</span> *)</span>request</span></div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line">- <span class="params">(void)</span>requestFailed:<span class="params">(<span class="variable">LCBaseRequest</span> *)</span>request</div><div class="line">{</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果一个页面只有一个请求，我觉得用Block比较直观，回调代码就在请求边上；如果有多个请求，用Delegate便于管理，因为回调处理代码都集中在一个地方。</p>
<h6 id="json转Model">json转Model</h6>
<p>json转Model使用了Mentle。原来转换起来比较麻烦，一是不能自定义属性名，接口返回json的key是什么，我们的属性就是什么；二是如果返回的对象是多层的，就需要手动的一层层解包，比较麻烦。</p>
<p>而Mentle完全解决了这些问题，并且提供了更多的功能（序列化什么的）。<br>首先，我们建立一个模型类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">json文件</div><div class="line">{</div><div class="line">    nickName = nmj;</div><div class="line">    phone = <span class="number">18512553387</span>;</div><div class="line">    photoUrl = <span class="string">"&lt;null&gt;"</span>;</div><div class="line">    state = <span class="string">"&lt;null&gt;"</span>;</div><div class="line">    userId = <span class="number">705363918947328</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//.h文件</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LoginUserModel</span> : <span class="title">MTLModel</span> &lt;<span class="title">MTLJSONSerializing</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSNumber</span> *userId;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *phone;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *nickName;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *avatarUrl;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *loginState;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//.m文件</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LoginUserModel</span></span></div><div class="line"></div><div class="line"><span class="comment">//此方法必须实现，用来标记本地属性名和接口key之间的匹配</span></div><div class="line"><span class="comment">//如果属性名和接口key完全一致，则返回nil，但方法一定要写。</span></div><div class="line">+ (<span class="built_in">NSDictionary</span> *)JSONKeyPathsByPropertyKey {</div><div class="line">    <span class="keyword">return</span> @{</div><div class="line">             <span class="string">@"avatarUrl"</span>: <span class="string">@"photoUrl"</span>,</div><div class="line">             <span class="string">@"loginState"</span>: <span class="string">@"state"</span></div><div class="line">             };</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>然后在请求的回调里面获得model</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSError *<span class="keyword">error</span> = nil;</div><div class="line">LoginUserModel* model = [MTLJSONAdapter modelOfClass:LoginUserModel.<span class="keyword">class</span> fromJSONDictionary:<span class="built_in">request</span>.responseJSONObject <span class="keyword">error</span>:&<span class="keyword">error</span>];</div></pre></td></tr></table></figure>

<p>如果是返回嵌套的对象，只需要增加一个方法，可以在CityGroupModel里面查到，它里面cityList对应的是一个数组，数组里面的每一个对象都是CityModel，Mantle会递归的进行解析，不用我们操心。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (NSValueTransformer *)cityListJSONTransformer</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> [NSValueTransformer mtl_JSONArrayTransformerWithModelClass:CityModel.<span class="keyword">class</span>];</div><div class="line">}</div></pre></td></tr></table></figure>

<h6 id="HUD">HUD</h6>
<p>HUD以前写起来比较麻烦，所以我把HUD的展示、消失、错误提示封装在请求里面了：一共两个属性，一个方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//是否展示HUD</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">BOOL</span> showHUD;</div><div class="line"></div><div class="line"><span class="comment">//hud的文字</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span>* HUDText;</div><div class="line"></div><div class="line"><span class="comment">//显示错去消息的方法</span></div><div class="line">- (<span class="keyword">void</span>)showHUDError:(<span class="built_in">NSString</span>*)msg;</div></pre></td></tr></table></figure>

<p>如果不需要显示HUD，那么请求的时候什么也不用做，否则需要设置以上两个属性。如果请求出错需要提示的话，就在failure的block里面提示一下。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">AACoinExchangeCodeApi* api = [[AACoinExchangeCodeApi alloc] initWithPayer:[UserInfoEntity shareEntity].phone tradeType:@<span class="string">"1"</span> accType:accType amount:amount];</div><div class="line">api.showHUD = YES;</div><div class="line">api.HUDText = NSLocalizedString(@<span class="string">"Obtaining verification code"</span>, nil);</div><div class="line">[api startWithCompletionBlockWithSuccess:^(LCBaseRequest *<span class="built_in">request</span>) {</div><div class="line">[self.getCodeButton beginCountDown];</div><div class="line">} failure:^(LCBaseRequest *<span class="built_in">request</span>) {</div><div class="line">[<span class="built_in">request</span> showHUDError:<span class="built_in">request</span>.errorMessage];</div><div class="line">}];</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>这周主要在做网络请求的重构，在参考了很多开源的项目之后，做了一个基本的Demo。本文主要讲一下基本的使用方法，不涉及原理。<br>]]>
    
    </summary>
    
      <category term="网络" scheme="http://linkageios.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
      <category term="AFNetworking" scheme="http://linkageios.github.io/categories/iOS/AFNetworking/"/>
    
      <category term="重构" scheme="http://linkageios.github.io/categories/iOS/AFNetworking/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FMDB简介及使用]]></title>
    <link href="http://linkageios.github.io/2014/11/27/FMDB%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://linkageios.github.io/2014/11/27/FMDB简介及使用/</id>
    <published>2014-11-27T05:38:14.000Z</published>
    <updated>2014-12-11T02:10:58.000Z</updated>
    <content type="html"><![CDATA[<p>FMDB是SQLite在oc下的封装，有三个主要的类。<br><a id="more"></a></p>
<h1 id="简介">简介</h1>
<p>FMDB是SQLite在oc下的封装，有三个主要的类<br>1.FMDatabase – 表示一个单独的SQLite数据库。 用来执行SQLite的命令。<br>2.FMResultSet – 表示FMDatabase执行查询后结果集<br>3.FMDatabaseQueue – 如果你想在多线程中执行多个查询或更新，你应该使用该类。这是线程安全的。</p>
<h1 id="使用">使用</h1>
<p>创建FMDatabase对象时参数为SQLite数据库文件路径。该路径可以是以下三种之一：<br>1.文件路径。该文件路径无需真实存在，如果不存在会自动创建。<br>2.空字符串@””。表示会在临时目录创建一个空的数据库，当FMDatabase 链接关闭时，文件也被删除。<br>3.NULL. 将创建一个in-memory数据库。同样的，当FMDatabase连接关闭时，数据会被销毁。</p>
<pre><code>
FMDatabase *db = [FMDatabase databaseWithPath:@"/tmp/tmp.db"];
</code></pre>
在和数据库交互 之前，数据库必须是打开的。如果资源或权限不足无法打开或创建数据库，都会导致打开失败。
<pre><code>
if (![db open]) {
[db release];
return;
}
</code></pre>
执行更新
一切不是SELECT命令的命令都视为更新。这包括  CREATE, UPDATE, INSERT,ALTER,COMMIT, BEGIN, DETACH, DELETE, DROP, END, EXPLAIN, VACUUM, and REPLACE  （等）。
简单来说，只要不是以SELECT开头的命令都是UPDATE命令。
执行更新返回一个BOOL值。YES表示执行成功，否则表示有那些错误 。你可以调用 -lastErrorMessage 和 -lastErrorCode方法来得到更多信息。

执行查询
SELECT命令就是查询，执行查询的方法是以 -excuteQuery开头的。

执行查询时，如果成功返回FMResultSet对象， 错误返回nil. 与执行更新相当，支持使用 NSError**参数。同时，你也可以使用 -lastErrorCode和-lastErrorMessage获知错误信息。

为了遍历查询结果，你可以使用while循环。你还需要知道怎么跳到下一个记录。使用FMDB，很简单，就像这样：
<pre><code>
FMResultSet *s = [db executeQuery:@"SELECT * FROM myTable"];
while ([s next]) {
//retrieve values for each record
}
</code></pre>


<p>FMResultSet  提供了很多方法来获得所需的格式的值：</p>
<pre><code>
- (int)intForColumn:(NSString*)columnName;
- (int)intForColumnIndex:(int)columnIdx;

- (long)longForColumn:(NSString*)columnName;
- (long)longForColumnIndex:(int)columnIdx;

- (long long int)longLongIntForColumn:(NSString*)columnName;
- (long long int)longLongIntForColumnIndex:(int)columnIdx;

- (unsigned long long int)unsignedLongLongIntForColumn:(NSString*)columnName;
- (unsigned long long int)unsignedLongLongIntForColumnIndex:(int)columnIdx;

- (BOOL)boolForColumn:(NSString*)columnName;
- (BOOL)boolForColumnIndex:(int)columnIdx;

- (double)doubleForColumn:(NSString*)columnName;
- (double)doubleForColumnIndex:(int)columnIdx;

- (NSString*)stringForColumn:(NSString*)columnName;
- (NSString*)stringForColumnIndex:(int)columnIdx;

- (NSDate*)dateForColumn:(NSString*)columnName;
- (NSDate*)dateForColumnIndex:(int)columnIdx;

- (NSData*)dataForColumn:(NSString*)columnName;
- (NSData*)dataForColumnIndex:(int)columnIdx;

- (const unsigned char *)UTF8StringForColumnIndex:(int)columnIdx;
- (const unsigned char *)UTF8StringForColumnName:(NSString*)columnName;

// returns one of NSNumber, NSString, NSData, or NSNull
- (id)objectForColumnName:(NSString*)columnName;
- (id)objectForColumnIndex:(int)columnIdx;
</code></pre>

<p>通常，你不需要调用[FMResultSet close]来关闭结果集，它会在自身deallocate或者父数据库关闭的时候自动关闭</p>
<p>使用FMDatabaseQueue 及线程安全<br>在多个线程中同时使用一个FMDatabase实例是不明智的。最好为每个线程创建一个FMDatabase对象。 不要让多个线程分享同一个实例，它无法在多个线程中同时使用。 如果你这么干了，会有不好的事发生，程序会时经常崩溃，或者发生异常，或者陨石会从天上掉下来砸到你Mac Pro（官方说法…）.  总之很崩溃。所以，不要初始化FMDatabase对象，然后在多个线程中使用。请使用 FMDatabaseQueue，它是你的朋友而且会帮助你。以下是使用方法<br><code><pre><br>FMDatabaseQueue <em>queue = [FMDatabaseQueue databaseQueueWithPath:aPath];<br>[queue inTransaction:^(FMDatabase 
</em>db, BOOL <em>rollback) {<br>[db executeUpdate:@”INSERT INTO myTable VALUES (?)”, [NSNumber numberWithInt:1]];<br>[db executeUpdate:@”INSERT INTO myTable VALUES (?)”, [NSNumber numberWithInt:2]];<br>[db executeUpdate:@”INSERT INTO myTable VALUES (?)”, [NSNumber numberWithInt:3]];<br>if (whoopsSomethingWrongHappened) {
</em>rollback = YES;<br>return;<br>}<br>// etc…<br>[db executeUpdate:@”INSERT INTO myTable VALUES (?)”, [NSNumber numberWithInt:4]];<br>}];<br></pre></code></p>
<p>FMDatabaseQueue  后台会建立GCD队列（依据类名），并执行你传给G-C-D队列的块。这意味着 你从多线程同时调用调用方法，GCD也会按它接收的块的顺序来执行</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>FMDB是SQLite在oc下的封装，有三个主要的类。<br>]]>
    
    </summary>
    
      <category term="FMDB" scheme="http://linkageios.github.io/tags/FMDB/"/>
    
      <category term="iOS,数据库" scheme="http://linkageios.github.io/categories/iOS-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UICollectionView简介]]></title>
    <link href="http://linkageios.github.io/2014/11/24/UICollectionView%E7%AE%80%E4%BB%8B/"/>
    <id>http://linkageios.github.io/2014/11/24/UICollectionView简介/</id>
    <published>2014-11-24T05:38:14.000Z</published>
    <updated>2014-12-11T02:10:58.000Z</updated>
    <content type="html"><![CDATA[<p>UICollectionView是iOS6添加的一个控件，是一种新的数据展示方式，简单来说可以把他理解成多列的UITableView，最简单的UICollectionView就是一个GridView，可以以多列的方式将数据进行展示。<br><a id="more"></a></p>
<h1 id="UICollectionView简介">UICollectionView简介</h1>
<p>标准的UICollectionView包含三个部分，它们都是UIView的子类：<br>Cells 用于展示内容的主体，对于不同的cell可以指定不同尺寸和不同的内容<br>Supplementary Views 追加视图，可以理解为每个Section的Header或者Footer，用来标记每个section的view<br>Decoration Views 装饰视图 这是每个section的背景</p>
<h1 id="实现一个简单的UICollectionView">实现一个简单的UICollectionView</h1>
<p>实现一个UICollectionView和实现一个UITableView基本没有什么大区别，它们都同样是datasource+delegate</p>
<p>￼￼￼￼基本的UICollectionViewDataSource提供</p>
<pre><code>
￼-numberOfSectionsInCollection:  //section的数量
￼-collectionView:numberOfItemsInSection:  //某个section里有多少个item
￼-collectionView:cellForItemAtIndexPath: // 对于某个位置应该显示什么样的cell 

-collectionView:viewForSupplementaryElementOfKind:atIndexPath: //提供Supplementary View
</code></pre>

<p>与UITableView中的情况一致，UICollectionView也需要对Cell进行重用，在iOS5中，Apple对UITableView的重用做了简化，以往要写类似这样的代码：</p>
<pre><code>
UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"MY_CELL_ID"];  
if (!cell) {     
cell = [[UITableViewCell alloc] init]; 
} 
//配置cell，blablabla 
return cell 
</code></pre>
在iOS5以后如果我们在TableView向数据源请求数据之前使用-registerNib:forCellReuseIdentifier:方法为@“MYCELLID"注册过nib的话，就可以省下每次判断并初始化cell的代码，要是在重用队列里没有可用的cell的话，runtime将自动帮我们生成并初始化一个可用的cell，还有以下类似方法
<pre><code>
- (void)registerNib:(UINib *)nib forCellReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(5_0);
- (void)registerClass:(Class)cellClass forCellReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(6_0);

- (void)registerNib:(UINib *)nib forHeaderFooterViewReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(6_0);
- (void)registerClass:(Class)aClass forHeaderFooterViewReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(6_0);
</code></pre>

<p>同样的 UICollectionView也有类似的方法</p>
<pre><code>
- (void)registerClass:(Class)cellClass forCellWithReuseIdentifier:(NSString *)identifier;
- (void)registerNib:(UINib *)nib forCellWithReuseIdentifier:(NSString *)identifier;

- (void)registerClass:(Class)viewClass forSupplementaryViewOfKind:(NSString *)elementKind withReuseIdentifier:(NSString *)identifier;
- (void)registerNib:(UINib *)nib forSupplementaryViewOfKind:(NSString *)kind withReuseIdentifier:(NSString *)identifier;
</code></pre>

<p>基本的UICollectionViewDelegate提供与数据无关的view的外形，用户交互之类：</p>
<p>cell的高亮<br>cell的选中状态<br>可以支持长按后的菜单<br>关于用户交互，UICollectionView也做了改进。每个cell现在有独立的高亮事件和选中事件的delegate，用户点击cell的时候，现在会按照以下流程向delegate进行询问：</p>
<pre><code>
-￼collectionView:shouldHighlightItemAtIndexPath: // 是否应该高亮？
-￼collectionView:didHighlightItemAtIndexPath:  //如果1答是，那么高亮
-￼collectionView:shouldSelectItemAtIndexPath:  //无论1结果如何，都询问是否可以被选中？
-collectionView:didUnhighlightItemAtIndexPath: // 如果1答是，那么现在取消高亮
-collectionView:didSelectItemAtIndexPath: // 如果3答是，那么选中cell
</code></pre>

<h3 id="Cell">Cell</h3>
<p>UICollectionViewCell结构比较简单， 由上至下<br>首先是cell本身作为容器view<br>然后是一个大小自动适应整个cell的backgroundView，用作cell平时的背景<br>再其上是selectedBackgroundView，是cell被选中时的背景<br>最后是一个contentView，自定义内容应被加在这个view上</p>
<h3 id="￼UICollectionViewLayout">￼UICollectionViewLayout</h3>
<p>这是UICollectionView和UITableView最大的不同。UICollectionViewLayout负责了将各个cell、Supplementary View和Decoration Views进行组织，为它们设定各自的属性。在展示之前，一般需要生成合适的UICollectionViewLayout子类对象，并将其赋予CollectionView的collectionViewLayout属性。<br>SDK为我们提供了一个最简单可能也是最常用的默认layout对象，￼￼￼UICollectionViewFlowLayout。Flow Layout简单说是一个直线对齐的layout，最常见的Grid View形式即为一种Flow Layout配置:</p>
<p>首先一个重要的属性是itemSize，它定义了每一个item的大小。通过设定itemSize可以全局地改变所有cell的尺寸，如果想要对某个cell制定尺寸，可以使用-collectionView:layout:sizeForItemAtIndexPath:方法。<br>间隔 可以指定item之间的间隔和每一行之间的间隔，和size类似，有全局属性，也可以对每一个item和每一个section做出设定：</p>
<p><pre><code><br>@property (CGSize) minimumInteritemSpacing<br>@property (CGSize) minimumLineSpacing<br>-collectionView:layout:minimumInteritemSpacingForSectionAtIndex:<br>-collectionView:layout:minimumLineSpacingForSectionAtIndex:<br></code></pre><br>滚动方向 由属性scrollDirection确定scroll view的方向，将影响Flow Layout的基本方向和由header及footer确定的section之间的宽度</p>
<p>UICollectionViewScrollDirectionVertical<br>UICollectionViewScrollDirectionHorizontal<br>Header和Footer尺寸 同样地分为全局和部分。需要注意根据滚动方向不同，header和footer的高和宽中只有一个会起作用。垂直滚动时section间宽度为该尺寸的高，而水平滚动时为宽度起作用，如图。</p>
<p><pre><code><br>@property (CGSize) headerReferenceSize<br>@property (CGSize) footerReferenceSize<br>-collectionView:layout:referenceSizeForHeaderInSection:<br>-collectionView:layout:referenceSizeForFooterInSection:<br></code></pre><br>缩进</p>
<p><pre><code><br>@property UIEdgeInsets sectionInset;<br>-collectionView:layout:insetForSectionAtIndex:<br></code></pre><br>通过自定义Layout可以实现各种nb布局，基本上常见的类似的第三方开源控件效果都可以实现，比如瀑布流、coverFlow，下面实现一个基本的瀑流效果</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>UICollectionView是iOS6添加的一个控件，是一种新的数据展示方式，简单来说可以把他理解成多列的UITableView，最简单的UICollectionView就是一个GridView，可以以多列的方式将数据进行展示。<br>]]>
    
    </summary>
    
      <category term="UICollectionView" scheme="http://linkageios.github.io/tags/UICollectionView/"/>
    
      <category term="iOS,瀑布流" scheme="http://linkageios.github.io/categories/iOS-%E7%80%91%E5%B8%83%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS代码规范]]></title>
    <link href="http://linkageios.github.io/2014/11/07/iOS%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://linkageios.github.io/2014/11/07/iOS编码规范/</id>
    <published>2014-11-07T05:38:14.000Z</published>
    <updated>2014-11-18T10:26:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="为什么要有代码规范？">为什么要有代码规范？</h1>
<p>对于团队，如果代码风格不统一，阅读或修改同事的代码会非常困难，造成潜在的风险。</p>
<p>对于个人，代码规范是对自身编码习惯的一种监督，如果没有这种监督，有时候因为偷懒，会写出难看的代码，时间长了自己都看不懂。这样对于代码的维护性是不利的。</p>
<h1 id="代码规范的内容？">代码规范的内容？</h1>
<p>代码规范包含的范围十分广泛。从一个变量的命名到一个类的设计，我觉得都属于代码规范的范畴。从实践的角度，可以把代码规范分成两个部分：</p>
<p>第一部分是规则，即一定要这么做。这里面没有对错，但需要统一。包含变量的命名、函数的命名、模块的组织、代码块的组织、宏、枚举、常量的声明、函数的粒度。</p>
<p>第二部分是风格，即一种模式化的代码设计结构。我们实现某个功能时，往往不止一种实现方式。每一种实现方式没有绝对的高低之分，不同角度的解读，就会有不同的偏好。所以这个层面上的代码规范，只能求同存异。但是不管怎样，每个人必须要有一致性的风格。就像不同的小区可以有不同的风格，但同一个小区只能有一种设计风格。风格包含代码设计中的抽象概念，比如接口、继承等等。<br><a id="more"></a></p>
<h1 id="为什么要有代码规范？-1">为什么要有代码规范？</h1>
<p>对于团队，如果代码风格不统一，阅读或修改同事的代码会非常困难，造成潜在的风险。</p>
<p>对于个人，代码规范是对自身编码习惯的一种监督，如果没有这种监督，有时候因为偷懒，会写出难看的代码，时间长了自己都看不懂。这样对于代码的维护性是不利的。</p>
<h1 id="代码规范的内容？-1">代码规范的内容？</h1>
<p>代码规范包含的范围十分广泛。从一个变量的命名到一个类的设计，我觉得都属于代码规范的范畴。从实践的角度，可以把代码规范分成两个部分：</p>
<p>第一部分是规则，即一定要这么做。这里面没有对错，但需要统一。包含变量的命名、函数的命名、模块的组织、代码块的组织、宏、枚举、常量的声明、函数的粒度。</p>
<p>第二部分是风格，即一种模式化的代码设计结构。我们实现某个功能时，往往不止一种实现方式。每一种实现方式没有绝对的高低之分，不同角度的解读，就会有不同的偏好。所以这个层面上的代码规范，只能求同存异。但是不管怎样，每个人必须要有一致性的风格。就像不同的小区可以有不同的风格，但同一个小区只能有一种设计风格。风格包含代码设计中的抽象概念，比如接口、继承等等。</p>
<h1 id="代码的规则">代码的规则</h1>
<p>规则如同法律，尽管从心底里很多人不认可，但每个人都必须遵守。看起来大家都受了束缚，但是对整个社会以及每一个人都是利大于弊。</p>
<h2 id="变量命名">变量命名</h2>
<p>变量命名历史上产生过很多方法，比较著名的有匈牙利命名法、驼峰命名法、下划线命名法。</p>
<ul>
<li>匈牙利命名法：szUserName</li>
<li>驼峰命名法：userName</li>
<li>下划线命名法：user_name</li>
</ul>
<p>用Objective-C开发，我们就参考苹果的官方命名方式即可，苹果采用的是驼峰命名法。</p>
<p>苹果的变量命名方式常常被其它语言的开发者所吐槽，因为它的名有时候是在太长了！！！下面是3个最长的Objective-C属性名：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">automaticallyEnablesStillImageStabilizationWhenAvailable</span></div><div class="line">availableMediaCharacteristicsWithMediaSelectionOptions</div><div class="line">outputObscuredDueToInsufficientExternalProtection</div></pre></td></tr></table></figure>

<p>变量声明最重要的是清晰其次才考虑长短，如果为了简短而含糊不清，是不可取的。</p>
<p>拿现有代码举例</p>
<table>
<thead>
<tr>
<th style="text-align:left">变量含义</th>
<th style="text-align:left">Not Good</th>
<th style="text-align:left">Good</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">昵称输入框</td>
<td style="text-align:left">tfNickName</td>
<td style="text-align:left">nickNameTextField</td>
</tr>
<tr>
<td style="text-align:left">密码ImageView</td>
<td style="text-align:left">imvPass</td>
<td style="text-align:left">passwordImageView</td>
</tr>
<tr>
<td style="text-align:left">我的搜索条</td>
<td style="text-align:left">mysearchBar</td>
<td style="text-align:left">mySearchBar</td>
</tr>
</tbody>
</table>
<p><strong>类变量</strong><br>前面加下划线，和系统框架保持一致</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">@interface UIViewController : UIResponder &lt;NSCoding, UIAppearanceContainer&gt; </span></div><div class="line">{</div><div class="line">    UIView           <span class="keyword">*</span>_view;</div><div class="line">    UITabBarItem     <span class="keyword">*</span>_tabBarItem;</div><div class="line">    UINavigationItem <span class="keyword">*</span>_navigationItem;</div><div class="line">    NSArray          <span class="keyword">*</span>_toolbarItems;</div><div class="line">    NSString         <span class="keyword">*</span>_title;</div><div class="line">    NSString         <span class="keyword">*</span>_nibName;</div><div class="line">    NSBundle         <span class="keyword">*</span>_nibBundle;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现有的例子</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CouponListTableViewCell</span> : <span class="title">UITableViewCell</span></span></div><div class="line">{</div><div class="line">    <span class="built_in">UIImageView</span> *imageIcon;</div><div class="line">    <span class="built_in">UIImageView</span> *imageCollect;</div><div class="line">    <span class="built_in">UILabel</span> *labelName;</div><div class="line">    <span class="built_in">UILabel</span> *labelPriceSale;</div><div class="line">    <span class="built_in">UILabel</span> *labelPriceOrigin;</div><div class="line">    <span class="built_in">UILabel</span> *labelSaleNumber;</div><div class="line">    <span class="built_in">UIImageView</span> *imageArrow;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>类变量与属性</strong><br>属性是Objective-C的一种高级语法，属性可以完全替换类变量，并且提供更强大的访问控制（strong、weak、nonatomic、readonly…）,而且属性也只需要用一行就能搞定，所以为什么还要用类变量呢？<br>属性声明后不用写@synthesize，且会自动生成类变量。<br><!--
 [资料>](http://stackoverflow.com/questions/12119284/xcode-4-automatically-generates-ivars-when-using-property-where-can-i-find-the)
--></p>
<p><strong>例外</strong></p>
<ul>
<li>一些局部变量允许用最简单的方式命名：i、j、temp</li>
<li>一些常用的缩写可以不用驼峰：RMB，OBD</li>
</ul>
<h2 id="函数命名">函数命名</h2>
<p>Objective-C中的函数不同于其他语言，函数名是按参数隔开的。初看起来是有点怪，但是习惯了就会发现这样和命名方式可读性极好，就像一句话一样。所以当你的函数名不能流利的读出来的话，那么它的命名肯定就有问题。<br>还是先举系统的例子</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>willAnimateFirstHalfOfRotationToInterfaceOrientation:<span class="params">(<span class="variable">UIInterfaceOrientation</span>)</span>toInterfaceOrientation </span></div><div class="line">                                                    duration:<span class="params">(<span class="variable">NSTimeInterval</span>)</span>duration</div></pre></td></tr></table></figure>

<p>这里面值得注意的几点：</p>
<ul>
<li>最左边的（+、-）和返回类型的左括号之间有一个空格，返回类型的右括号与第一个参数之间没有空格；</li>
<li>函数名中每一段描述都以小写字母开头，描述的写法要考虑清晰明确，参考变量命名；</li>
<li>如果函数名过长，应该换行，按冒号对齐；</li>
<li>从描述中可以看出对应参数的意义。</li>
</ul>
<p>再看看我们自己的命名</p>
<ol>
<li>最后一个参数描述Selector首字母大写了</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (<span class="tag">UIButton</span> *)<span class="tag">createButton</span><span class="pseudo">:(MUButtonItemAttribute</span> *)<span class="tag">attr</span> </div><div class="line">               <span class="tag">target</span><span class="pseudo">:(id)target</span> </div><div class="line">             <span class="tag">Selector</span><span class="pseudo">:(SEL)sel</span>;</div></pre></td></tr></table></figure>

<ol>
<li>有一些多余的空格</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="addition">+ (AppDelegate *) appDelegate;</span></div><div class="line"><span class="deletion">- (void)hideTabbar :(BOOL)status;</span></div></pre></td></tr></table></figure>

<ol>
<li>加减号和括号之间要有空格</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>pushEvent:<span class="params">(<span class="variable">NSDictionary</span>*)</span>dictionary target:<span class="params">(id)</span>target;</span></div></pre></td></tr></table></figure>


<ol>
<li>参数名和参数要对应，含义清晰</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>setNavBackButton:<span class="params">(<span class="variable">NSString</span> *)</span>string;</span></div><div class="line">- <span class="params">(id)</span>init:<span class="params">(<span class="variable">NSString</span>*)</span>nickName phoneNumber:<span class="params">(<span class="variable">NSString</span> *)</span>phoneNumber;</div><div class="line">- <span class="params">(void)</span>setTextFieldBackGroud:<span class="params">(<span class="variable">CGRect</span>)</span>rect;</div><div class="line">- <span class="params">(id)</span>init:<span class="params">(<span class="variable">NSInteger</span>)</span>flag;</div><div class="line">- <span class="params">(void)</span>requestHealthRecord:<span class="params">(<span class="variable">NSString</span> *)</span>typeStr;</div></pre></td></tr></table></figure>

<ol>
<li>函数名过长要换行</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(id)</span>initWithStyle:<span class="params">(<span class="variable">UITableViewCellStyle</span>)</span>style</span></div><div class="line">    reuseIdentifier:<span class="params">(<span class="variable">NSString</span> *)</span>reuseIdentifier</div><div class="line">containingTableView:<span class="params">(<span class="variable">UITableView</span> *)</span>containingTableView</div><div class="line"> leftUtilityButtons:<span class="params">(<span class="variable">NSArray</span> *)</span>leftUtilityButtons </div><div class="line">rightUtilityButtons:<span class="params">(<span class="variable">NSArray</span> *)</span>rightUtilityButtons;</div></pre></td></tr></table></figure>

<ol>
<li>命名风格混乱</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (NSInteger)GetServerBack:(NSString *)serverName</div><div class="line">                path_Param:(NSMutableDictionary*)path_Param</div><div class="line">               query_Param:(NSMutableDictionary*)query_Param</div><div class="line">                body_Param:(NSMutableDictionary*)body_Param</div><div class="line">                    <span class="function"><span class="keyword">method</span>:</span>(NSInteger)<span class="function"><span class="keyword">method</span></span></div><div class="line">               <span class="title">returnValue</span>:(NSMutableDictionary*)returnValue;</div></pre></td></tr></table></figure>

<ol>
<li>参数之间用and、with，多此一举</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(id)</span>initWithFrame:<span class="params">(<span class="variable">CGRect</span>)</span>frame </span></div><div class="line">       andImageView:<span class="params">(<span class="variable">UIImageView</span>*)</span>imageView </div><div class="line">     withImageFrame:<span class="params">(<span class="variable">CGRect</span>)</span>imageInitFrame </div><div class="line">       withImageUrl:<span class="params">(<span class="variable">NSURL</span>*)</span>imageUrl;</div></pre></td></tr></table></figure>


<p><strong>命名很重要！！！</strong><br>良好的命名是写出高质量代码的前提，命名的时候除了符合以上的规范，还需要找到合适的单词来表达含义，不要为了一时之快用拼音，也千万不要出现数字。</p>
<h2 id="代码模块组织">代码模块组织</h2>
<p>这个代码模块的组织是指文件级别的，即我们应该如何划分包。<br>现有的包结构是有些问题的，导致我们找某个功能的实现文件比较麻烦。<br><a href="!--
参考[别人的经验](http://www.cocoachina.com/industry/20140225/7879.html)，个人觉得这样的划分还是不错的。
--">!--
参考[别人的经验](http://www.cocoachina.com/industry/20140225/7879.html)，个人觉得这样的划分还是不错的。
--</a></p>
<p><strong>文件的命名</strong><br>我们自己创建的文件，应该有统一的前缀。比如HJMainViewController，这也符合系统的命名规范。Objective-C没有namespace，所以这样做的好处是当你引用了第三方的代码时，防止重名。而且当我们自己的代码越来越大时，内部也会出现冲突。</p>
<p><strong>一个文件一个类</strong><br>好处：</p>
<ul>
<li>减少单个文件的长度</li>
<li>定位文件更方便</li>
<li>便于重用</li>
</ul>
<h2 id="代码块的组织">代码块的组织</h2>
<p>作为一个程序员，大部分时间实在看代码而不是在写。所以代码的可读性严重影响到我们的工作效率。<br>当你看到超过1000行的实现文件时，你还有看下去的欲望吗？<br>所以千万不要写出超过1000行的代码，有的话也得重构。<br><!--[重构掉](http://www.objc.io/issue-1/)。 --></p>
<p>当代码控制到1000行以内后，只是具备了可读的基本条件。我们的屏幕一般只能一次显示50行代码，从头看到尾就是20屏，常常会看了后面忘了前面。所以我们要把一个文件里面的所有函数有秩序的组织起来，让人不用重头看到尾，就能很快定位到想看的地方。<br>这里提供一个小办法：用#pragma mark宏根据功能区分开:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pragma mark - Life Circle</div><div class="line">pragma mark - <span class="keyword">Public</span> <span class="keyword">Interface</span></div><div class="line">pragma mark - UI Actions</div><div class="line">pragma mark - Business Logic</div><div class="line">pragma mark - UITableViewDataSource</div><div class="line">pragma mark - UITableViewDelegate</div><div class="line">pragma mark - UIScrollViewDelegate</div><div class="line">pragma mark - Notification Handle</div><div class="line">pragma mark - <span class="keyword">Private</span> <span class="function"><span class="keyword">Method</span></span></div></pre></td></tr></table></figure>

<h2 id="宏、枚举、常量的声明">宏、枚举、常量的声明</h2>
<p>宏的命名方式参考变量的命名方式，大写，用下划线分开</p>
<figure class="highlight TARGET_OS_IPHONE```"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">枚举也有很多写法，这里推荐系统的方式</div></pre></td></tr></table></figure>

<p>typedef NS_ENUM(NSInteger, NSTextAlignment)<br>{<br>    NSTextAlignmentLeft      = 0,    // Visually left aligned<br>    NSTextAlignmentRight     = 1,    // Visually right aligned<br>    NSTextAlignmentCenter    = 2,    // Visually centered<br>    NSTextAlignmentJustified = 3,    // Fully-justified. The last line in a paragraph is natural-aligned.<br>    NSTextAlignmentNatural   = 4,    // Indicates the default alignment for script<br>} </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">常量以k开头，系统命名风格</div></pre></td></tr></table></figure>

<p>extern NSString <em>const kAPNetworkDidSetupNotification;     // 建立连接<br>extern NSString </em>const kAPNetworkDidCloseNotification;     // 关闭连接<br>extern NSString <em>const kAPNetworkDidRegisterNotification;  // 注册成功<br>extern NSString </em>const kAPNetworkDidLoginNotification;     // 登录成功</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如果是数值常量，用宏的话，也可以用k开头</div></pre></td></tr></table></figure>

<h1 id="define_kDistancePoint_10-0f_//_圆点、标志和正文的间距">define kDistancePoint  10.0f   // 圆点、标志和正文的间距</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">## 函数的粒度</span></div><div class="line">知道我们现在最长的函数有多少行吗？<span class="number">655</span>行。</div></pre></td></tr></table></figure>

<ul>
<li>(void)getShopDetail</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">一个函数最好不超过一屏（50行），千万不能超过两屏（100行）。</div><div class="line">因为从设计的角度来说，一个函数只需要干一件事，所以50行一般是够的，超长的函数往往干了很多事情，或者干了一件很大的事（拆成多件小事，交给子函数去干）。</div><div class="line"></div><div class="line"><span class="comment">## 其它</span></div><div class="line"></div><div class="line">- <span class="keyword">*</span><span class="keyword">*</span>Log<span class="keyword">*</span><span class="keyword">*</span>：不要使用NSLog，提交了会因想到别人，而且最后打包删起来麻烦。需要找一个Log工具，MyNSLog功能不够。</div><div class="line">- <span class="keyword">*</span><span class="keyword">*</span>代码中尽量不要出现数字<span class="keyword">*</span><span class="keyword">*</span>：据上下文推测出来的，还是计算的出为好（现在界面里面很多地方确实要写死数字，适配iPhone6会很困难）</div></pre></td></tr></table></figure>

<p>_contentBkg = [[UIView alloc] initWithFrame:CGRectMake(0, 1 / [UIScreen mainScreen].scale, 320, 68 - 1)];</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">*</span><span class="keyword">*</span>避免复杂的表达式<span class="keyword">*</span><span class="keyword">*</span>：</div></pre></td></tr></table></figure>

<pre><code><span class="keyword">if</span> (tfPassword.<span class="keyword">text</span>!=nil &amp;&amp;
    ![tfPassword.<span class="keyword">text</span> isEqualToString:@<span class="string">""</span>] &amp;&amp;
    tfRequestNumber.<span class="keyword">text</span>!=nil &amp;&amp;
    ![tfRequestNumber.<span class="keyword">text</span> isEqualToString:@<span class="string">""</span>]
    )
{
;    
}
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">*</span><span class="keyword">*</span>一个变量不在多个函数中出现，不要作为类变量：<span class="keyword">*</span><span class="keyword">*</span></div></pre></td></tr></table></figure>

<p>MBProgressHUD* hudProgress;<br>int result;</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">*</span><span class="keyword">*</span>每个类的.h开头的地方要有注释，说明这个类是干嘛的<span class="keyword">*</span><span class="keyword">*</span></div><div class="line">-</div></pre></td></tr></table></figure>

<p>/**</p>
<ul>
<li>SDImageCache maintains a memory cache and an optional disk cache. Disk cache write operations are performed</li>
<li>asynchronous so it doesn’t add unnecessary latency to the UI.<br>*/<br>@interface SDImageCache : NSObject</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">*</span><span class="keyword">*</span>if后面的语句哪怕只有一行，都加括号<span class="keyword">*</span><span class="keyword">*</span></div></pre></td></tr></table></figure>

<p>if ([key rangeOfString:@”热”].location != NSNotFound)<br>{<br>    titleLabel.text = @”热门城市”;<br>}<br>else<br>{<br>    titleLabel.text = key;<br>}</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="preprocessor"># 代码的风格</span></div><div class="line"></div><div class="line">风格如同习俗，不同地区有不同的习俗。你觉得入乡随俗好，就入乡随俗，这样避免了一些无谓的麻烦；但是你若坚持原有的习俗，社会也是能接受的，毕竟这些东西都是发展变化的，没有固定的模式，只有更好的模式。</div><div class="line"></div><div class="line"><span class="preprocessor">## 接口</span></div><div class="line">这里的接口指的是一个类公开的一组方法，良好设计的类是高内聚低耦合的，所以接口必须是简洁的。</div></pre></td></tr></table></figure>

<p>@interface PaySucceedViewController : LCBaseViewController</p>
<p>@property (nonatomic,retain) NSString *isSuccess;</p>
<p>@property (nonatomic,retain) NSString *shopName;</p>
<p>@property (nonatomic,retain) NSString *detailinfo;</p>
<p>@property (nonatomic,retain) NSString *amount;</p>
<p>@property (nonatomic,retain) NSString *omsOrderId;</p>
<p>/*</p>
<ul>
<li>支付订单类型<br>*</li>
<li>@since<br>*/<br>@property (nonatomic) ORDER_CATEGORY mCategory;</li>
</ul>
<p>@end<br>```<br>上面的例子是一个ViewController，但是它暴露了太多属性，属性很零碎，传值的时候要一个一个传。其实这里属性应该属于一个叫订单Model的对象，把这些属性封装在OrderModel中，复用性和可维护性都会好很多。（但是现在代码整体结构没有Model层，这里需要很大的重构）</p>
<h2 id="继承">继承</h2>
<p>继承不是为了少写代码，它的目的是抽象，顺便少写了代码。<br>举NavigationBar的例子，用宏可以实现，用基类也可以实现，但基类抽象出了一个共有的接口，以后发生共性的变化够可以通过修改基类来实现，你可以在基类里加一组方法，而宏做不到。</p>
<h2 id="其它">其它</h2>
<p>代码规范的路还长着，先走出第一步吧！</p>
<h1 id="参考资料">参考资料</h1>
<p><a href="./CodingGuidelines.pdf">Apple代码规范</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="为什么要有代码规范？">为什么要有代码规范？</h1>
<p>对于团队，如果代码风格不统一，阅读或修改同事的代码会非常困难，造成潜在的风险。</p>
<p>对于个人，代码规范是对自身编码习惯的一种监督，如果没有这种监督，有时候因为偷懒，会写出难看的代码，时间长了自己都看不懂。这样对于代码的维护性是不利的。</p>
<h1 id="代码规范的内容？">代码规范的内容？</h1>
<p>代码规范包含的范围十分广泛。从一个变量的命名到一个类的设计，我觉得都属于代码规范的范畴。从实践的角度，可以把代码规范分成两个部分：</p>
<p>第一部分是规则，即一定要这么做。这里面没有对错，但需要统一。包含变量的命名、函数的命名、模块的组织、代码块的组织、宏、枚举、常量的声明、函数的粒度。</p>
<p>第二部分是风格，即一种模式化的代码设计结构。我们实现某个功能时，往往不止一种实现方式。每一种实现方式没有绝对的高低之分，不同角度的解读，就会有不同的偏好。所以这个层面上的代码规范，只能求同存异。但是不管怎样，每个人必须要有一致性的风格。就像不同的小区可以有不同的风格，但同一个小区只能有一种设计风格。风格包含代码设计中的抽象概念，比如接口、继承等等。<br>]]>
    
    </summary>
    
      <category term="规范" scheme="http://linkageios.github.io/tags/%E8%A7%84%E8%8C%83/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LCBaseViewController相关]]></title>
    <link href="http://linkageios.github.io/2014/11/07/LCBaseViewController%E7%9B%B8%E5%85%B3/"/>
    <id>http://linkageios.github.io/2014/11/07/LCBaseViewController相关/</id>
    <published>2014-11-07T05:38:14.000Z</published>
    <updated>2014-11-18T09:20:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2>
<p>该基类参考原先项目中BaseViewController等几个类 进行修改 功能暂时满足目前项目需求 日后更新会根据项目迭代中提出的需求在进行修改</p>
<h2 id="属性和函数说明">属性和函数说明</h2>
<p>LCViewControllerShowType：viewController出现的方式 具体分为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LCViewControllerShowTypePush                （<span class="keyword">pop</span>/<span class="keyword">push</span>方式）（默认）</div><div class="line">LCViewControllerShowTypePresent             （present/dismiss方式）</div><div class="line">LCViewControllerShowTypePresentBasic        （作为没有登录的情况下，登陆界面返回按钮 跳转到首页的凭据）</div></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="简介-1">简介</h2>
<p>该基类参考原先项目中BaseViewController等几个类 进行修改 功能暂时满足目前项目需求 日后更新会根据项目迭代中提出的需求在进行修改</p>
<h2 id="属性和函数说明-1">属性和函数说明</h2>
<p>LCViewControllerShowType：viewController出现的方式 具体分为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LCViewControllerShowTypePush                （<span class="keyword">pop</span>/<span class="keyword">push</span>方式）（默认）</div><div class="line">LCViewControllerShowTypePresent             （present/dismiss方式）</div><div class="line">LCViewControllerShowTypePresentBasic        （作为没有登录的情况下，登陆界面返回按钮 跳转到首页的凭据）</div></pre></td></tr></table></figure>

<p>LCNavigationBarStyle： navigationBar 的样式 主要是背景色</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">LCNavigationBarRed</span>             navigationBar 一级,红色背景</div></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/79888-d6fa0aed379b25d2.png" alt="LCNavigationBarRed"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">LCNavigationBarWhite</span>          navigationBar 二级,白色背景（默认）</div></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/79888-6225382ae2b09d27.png" alt="LCNavigationBarWhite"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">LCNavigationBarNull</span>             navigationBar 二级,隐藏navigaitonbar</div></pre></td></tr></table></figure>

<p>提供函数方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//设置导航栏背景图片</div><div class="line"><span class="pp">- <span class="params">(void)</span>configNavigationBarBgImage;</span></div><div class="line">//设置左边的返回按钮</div><div class="line">- <span class="params">(void)</span>setLeftBackButton;</div><div class="line">- <span class="params">(void)</span>setLeftBackButtonAction:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//设置左边的返回按钮<span class="params">(图片按钮)</span></div><div class="line">- <span class="params">(void)</span>setLeftButtonWithImageName:<span class="params">(<span class="variable">NSString</span>*)</span>imageName action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//设置左边的返回按钮<span class="params">(文字按钮)</span></div><div class="line">- <span class="params">(void)</span>setLeftButtonWithTitle:<span class="params">(<span class="variable">NSString</span>*)</span>title action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//设置左边的返回按钮<span class="params">(通用按钮)</span></div><div class="line">- <span class="params">(void)</span>setLeftButton:<span class="params">(<span class="variable">UIButton</span>*)</span>button action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//设置中间的文本标题</div><div class="line">- <span class="params">(void)</span>setTitleViewWithText:<span class="params">(<span class="variable">NSString</span>*)</span>text;</div><div class="line">//设置右边的按钮<span class="params">(文字按钮)</span></div><div class="line">- <span class="params">(void)</span>setRightButtonWithTitle:<span class="params">(<span class="variable">NSString</span>*)</span>title action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//设置右边的按钮<span class="params">(图片按钮)</span></div><div class="line">- <span class="params">(void)</span>setRightButtonWithImageName:<span class="params">(<span class="variable">NSString</span>*)</span>imageName action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">- <span class="params">(void)</span>setRightButtonWithNormarlImageName:<span class="params">(<span class="variable">NSString</span>*)</span>normarName highlightedImageName:<span class="params">(<span class="variable">NSString</span> *)</span>highlightedName action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//设置右边的按钮</div><div class="line">- <span class="params">(void)</span>setRightButton:<span class="params">(<span class="variable">UIButton</span>*)</span>button action:<span class="params">(<span class="variable">SEL</span>)</span>selector;</div><div class="line">//多个按钮 分别有文字或图片 （btnStrs 中vo 为dic 具体参考下面栗子）</div><div class="line">- <span class="params">(void)</span>setRightButtons:<span class="params">(<span class="variable">NSArray</span> *)</span>btnStrs;</div><div class="line">- <span class="params">(void)</span>setRightButtonImages:<span class="params">(<span class="variable">NSArray</span> *)</span>images;</div><div class="line">- <span class="params">(void)</span>rightButtonAction:<span class="params">(id)</span>sender;</div><div class="line">//返回按钮的响应事件</div><div class="line">- <span class="params">(void)</span>backButtonPressed:<span class="params">(id)</span>sender;</div></pre></td></tr></table></figure>

<p>提供方法中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>setRightButtons:<span class="params">(<span class="variable">NSArray</span> *)</span>btnStrs;</span></div></pre></td></tr></table></figure>

<p>btnStrs为包含vo对象的一个数组</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">vo =</span> {</div><div class="line">@<span class="string">" title"</span>     : @<span class="string">"返回"</span>,</div><div class="line">@<span class="string">"normalImage"</span>:@<span class="string">"fanhui.png"</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>具体使用为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *rightbarButtonVos = @[@{<span class="string">@"title"</span>:<span class="string">@"第一个"</span>,<span class="string">@"normalImage"</span>:<span class="string">@"first.png"</span>},@{<span class="string">@"title"</span>:<span class="string">@"第二个"</span>,<span class="string">@"normalImage"</span>:<span class="string">@"second.png"</span>}];</div><div class="line">[<span class="keyword">self</span> setRightButtons: rightbarButtonVos];</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简介">简介</h2>
<p>该基类参考原先项目中BaseViewController等几个类 进行修改 功能暂时满足目前项目需求 日后更新会根据项目迭代中提出的需求在进行修改</p>
<h2 id="属性和函数说明">属性和函数说明</h2>
<p>LCViewControllerShowType：viewController出现的方式 具体分为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LCViewControllerShowTypePush                （<span class="keyword">pop</span>/<span class="keyword">push</span>方式）（默认）</div><div class="line">LCViewControllerShowTypePresent             （present/dismiss方式）</div><div class="line">LCViewControllerShowTypePresentBasic        （作为没有登录的情况下，登陆界面返回按钮 跳转到首页的凭据）</div></pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="LCBaseViewController" scheme="http://linkageios.github.io/tags/LCBaseViewController/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于iConsole在项目中的应用]]></title>
    <link href="http://linkageios.github.io/2014/11/07/%E5%85%B3%E4%BA%8EiConsole%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://linkageios.github.io/2014/11/07/关于iConsole在项目中的应用/</id>
    <published>2014-11-07T05:38:14.000Z</published>
    <updated>2014-12-03T02:51:18.000Z</updated>
    <content type="html"><![CDATA[<p>tips：方便程序没有连着Xcode跑时定位bug(目前觉得没什么好写的就是)</p>
<ul>
<li>安装</li>
</ul>
<p><img src="/images/79888-d9f0841d3cfac40e.png" alt="imag"></p>
<p>下载iconsole代码，将其中这两个文件拖入现有代码中</p>
<ul>
<li>配置<br>添加头文件</li>
</ul>
<figure class="highlight #import"><figcaption><span>"iConsole.h"```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在使用其功能之前有一点要注意,需要将AppDelegate里初始的<span class="built_in">UIWindow</span>需要以iConsoleWindow来初始化,并添加</div></pre></td></tr></table></figure>

<p>iConsoleDelegate</p>
<figure class="highlight 协议"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在</div></pre></td></tr></table></figure>

<p>AppDelegate.h</p>
<figure class="highlight 中"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="xml"><span class="comment">&lt;!--more--&gt;</span></span></div><div class="line">tips：方便程序没有连着Xcode跑时定位bug(目前觉得没什么好写的就是)</div><div class="line"><span class="bullet">- </span>安装</div><div class="line"></div><div class="line">![<span class="link_label">imag</span>](<span class="link_url">/images/79888-d9f0841d3cfac40e.png</span>)</div><div class="line"></div><div class="line">下载iconsole代码，将其中这两个文件拖入现有代码中</div><div class="line"><span class="bullet">- </span>配置</div><div class="line">添加头文件</div></pre></td></tr></table></figure>

<h1 id="import_“iConsole-h”">import “iConsole.h”</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在使用其功能之前有一点要注意,需要将AppDelegate里初始的<span class="built_in">UIWindow</span>需要以iConsoleWindow来初始化,并添加</div></pre></td></tr></table></figure>

<p>iConsoleDelegate</p>
<figure class="highlight 协议"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在</div></pre></td></tr></table></figure>

<p>AppDelegate.h</p>
<figure class="highlight 中"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) iConsoleWindow *window;</div></pre></td></tr></table></figure>

<p>在</p>
<figure class="highlight AppDelegate.m```的```didFinishLaunchingWithOptions"><figcaption><span>```方法中添加</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="variable">_window =</span> [[iConsoleWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];</div><div class="line"><span class="comment">/*</span></div><div class="line">*  iconsole</div><div class="line">*/</div><div class="line">[iConsole sharedConsole].<span class="variable">delegate =</span> self;</div><div class="line">[iConsole sharedConsole].<span class="variable">logSubmissionEmail =</span> @<span class="string">"xxx@126.com"</span>;</div></pre></td></tr></table></figure>

<p>添加协议方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">*iconsole</div><div class="line">*@param command</div><div class="line">*/</div><div class="line">- (<span class="keyword">void</span>)handleConsoleCommand:(<span class="built_in">NSString</span> *)command</div><div class="line">{</div><div class="line"><span class="keyword">if</span> ([command isEqualToString:<span class="string">@"version"</span>])</div><div class="line">{</div><div class="line">[iConsole info:<span class="string">@"%@ version %@"</span>,</div><div class="line">[[<span class="built_in">NSBundle</span> mainBundle] objectForInfoDictionaryKey:<span class="string">@"CFBundleName"</span>],</div><div class="line">[[<span class="built_in">NSBundle</span> mainBundle] objectForInfoDictionaryKey:<span class="string">@"CFBundleVersion"</span>]];</div><div class="line">}</div><div class="line"><span class="keyword">else</span></div><div class="line">{</div><div class="line">[iConsole error:<span class="string">@"unrecognised command, try 'version' instead"</span>];</div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>iConsole提供了4种记录日程的方式,分别是:<br>1:信息         </p>
<figure class="highlight [iConsole"><figcaption><span>info:@"记录一条普通级"];```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2:警告</div></pre></td></tr></table></figure>

<p>[iConsole warn:@”记录一条警告级”];</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3:错误</div></pre></td></tr></table></figure>

<p>[iConsole error:@”记录一条错误级”];</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4:崩溃</div></pre></td></tr></table></figure>

<p>[iConsole crash:@”记录一条崩溃级”];</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">iConsole</span> 默认记录的日志条数是<span class="number">1000</span>条. 如果日志记录到上限时,会删除最早的一条,如此循环,可通过如下属性设置上下限:</div></pre></td></tr></table></figure>

<p>[[iConsole sharedConsole] setMaxLogItems:2000];  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当我们需要查看iConsole的控制台时,可以通过三种方式来启动控制台:</div><div class="line">1:主动调用</div></pre></td></tr></table></figure>

<p>[iConsole show];  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2:三跟手指由下往上滑动. 模拟器两根手指,  默认启动</div></pre></td></tr></table></figure>

<p>[iConsole sharedConsole].simulatorTouchesToShow = YES;<br>[iConsole sharedConsole].deviceTouchesToShow = YES;  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3:摇动手机启动  默认禁用</div></pre></td></tr></table></figure>

<p>[iConsole sharedConsole].deviceShakeToShow = YES; ``` </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>tips：方便程序没有连着Xcode跑时定位bug(目前觉得没什么好写的就是)</p>
<ul>
<li>安装</li>
</ul>
<p><img src="/images/79888-d9f0841d3cfac40e.png" alt="imag"></p>
<p>下载]]>
    </summary>
    
      <category term="iconsole" scheme="http://linkageios.github.io/tags/iconsole/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LCDataManager相关说明]]></title>
    <link href="http://linkageios.github.io/2014/11/07/LCDataManager%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"/>
    <id>http://linkageios.github.io/2014/11/07/LCDataManager相关说明/</id>
    <published>2014-11-07T05:38:14.000Z</published>
    <updated>2014-11-18T10:35:55.000Z</updated>
    <content type="html"><![CDATA[<h6 id="#_文章参照cucuz的数据存储Library"># 文章参照cucuz的数据存储Library</h6>
<p><strong>类 的目的</strong></p>
<p>方便项目当中数据的存储，提供简单的接口供使用,根据存储的位置划分可以分为缓存和本地存储，<br>其中包括</p>
<pre><code><span class="built_in">NSArray</span>, <span class="built_in">NSDictionary</span>, NSData,<span class="built_in">NSString</span>,<span class="built_in">UIImage</span> 等常用数据类型，自定义Object(自行实现NSCoding协议)
</code></pre><p><strong>类的函数介绍</strong></p>
<ul>
<li>类初始化(单例)</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">LCDataManager *dataManager </span>=<span class="string"> [LCDataManager shareManager];</span></div></pre></td></tr></table></figure>

<p>首先，我们创建一个对象，下文将以它作为存储的一个依据</p>
<h2 id="Cache_block">Cache block</h2>
<p><a id="more"></a></p>
<h6 id="#_文章参照cucuz的数据存储Library-1"># 文章参照cucuz的数据存储Library</h6>
<p><strong>类 的目的</strong></p>
<p>方便项目当中数据的存储，提供简单的接口供使用,根据存储的位置划分可以分为缓存和本地存储，<br>其中包括</p>
<pre><code><span class="built_in">NSArray</span>, <span class="built_in">NSDictionary</span>, NSData,<span class="built_in">NSString</span>,<span class="built_in">UIImage</span> 等常用数据类型，自定义Object(自行实现NSCoding协议)
</code></pre><p><strong>类的函数介绍</strong></p>
<ul>
<li>类初始化(单例)</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">LCDataManager *dataManager </span>=<span class="string"> [LCDataManager shareManager];</span></div></pre></td></tr></table></figure>

<p>首先，我们创建一个对象，下文将以它作为存储的一个依据</p>
<h2 id="Cache_block-1">Cache block</h2>
<ul>
<li>Cache的存储</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>putObject:<span class="params">(id)</span>object inKey:<span class="params">(<span class="variable">NSString</span> *)</span>key underType:<span class="params">(<span class="variable">LCCACHETYPE</span>)</span>type;</span></div></pre></td></tr></table></figure>

<p>函数用意是 把</p>
<figure class="highlight object```以关键字```key```存储到```type```类型下。其实，本身```dataManager"><figcaption><span>```中存在一个```MutbaleDictionary *cacheMutableDictionary``` ，它是以```LCCACHETYPE ```中的类别为关键字建立的字典，该存储函数中的```key```则是这个```cacheMutableDictionary ```中对应```type```下的关键字，简单说就是“字典中字典的关键字”。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="undefined">其中</span></div></pre></td></tr></table></figure>

<p>LCCACHETYPE</p>
<figure class="highlight 是提供的数据分类"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>

<p>typedef NS_ENUM(NSInteger, LCCACHETYPE)<br>{<br>LCCacheImage            =  0,<br>LCCacheData             =  1,<br>LCCacheFile             =  2,<br>LCCacheTmp              =  3,<br>LCCacheNeverRelease     =  4,<br>};</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

<p>putObject</p>
<figure class="highlight 用法"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>

<p>NSArray *CacheLists = @[@”老大”,@”老二”,@”老三”];<br>BOOL ret = [dataManager  putObject:CacheLists inKey:@”order” underType:LCCacheData];</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">其他类型以此类推</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="deletion">- Cache的获取</span></div></pre></td></tr></table></figure>

<ul>
<li>(id)getObjectForKey:(NSString *)key underType:(LCCACHETYPE)type;</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">这个就是上面存储函数对应的一个<span class="keyword">get</span>函数，他的参数和上面函数是一样的，不过多说明</div><div class="line"></div><div class="line">-</div></pre></td></tr></table></figure>

<p>getObjectForKey</p>
<figure class="highlight 用法"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="protobuf"><span class="constant">	NSArray *fetchCacheLists</span> = [dataManager getObjectForKey:@<span class="string">"order"</span>] 	underType: LCCacheData;</span></div><div class="line"></div><div class="line">其他类型以此类推</div><div class="line"></div><div class="line">- Cache的清除</div><div class="line"></div><div class="line">这里提供了<span class="number">3</span>个清除方法，是针对需要清除的模块的范围划分的:</div></pre></td></tr></table></figure>

<ul>
<li>(void)clearObjectForKey:(NSString *)key underType:(LCCACHETYPE)type;</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面这个方法是最细的一个清除，他是清除到类别下面的关键字对应的数据</div></pre></td></tr></table></figure>

<ul>
<li>(void)clearObjectsUnderType:(LCCACHETYPE)type;</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">上面这个方法清除的是一个类别下所有的关键字包含的数据</div></pre></td></tr></table></figure>

<ul>
<li>(void)clearAllCache;</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">上面这个方法顾名思义就是清空Cache</div><div class="line"><span class="deletion">- 清除用法</span></div></pre></td></tr></table></figure>

<p>[dataManager clearObjectForKey:@”order” underType: LCCacheData];<br>[dataManager clearObjectsUnderType: LCCacheData];<br>[dataManager clearAllCache];</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></div></pre></td></tr></table></figure>

<p>i’m 华 丽 的 分 割 线 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-<span class="ruby">----------------------------------------------------------------------------</span></div><div class="line">##disk block</div><div class="line">disk上的存储</div><div class="line">它包括了</div></pre></td></tr></table></figure>

<p>NSFileManager NSUserDefaults NSKeyedArchiver</p>
<figure class="highlight 对数据"><figcaption><span>的操作，目前除了对```UIImage```的存储位置放在```tmp```中，其他数据存储位置在```Library/Caches```中</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

<p>NSFileManager </p>
<figure class="highlight 上的操作"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

<p>NSFileManager </p>
<figure class="highlight 存数据"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>storeImage:<span class="params">(<span class="variable">UIImage</span> *)</span>image withFileName:<span class="params">(<span class="variable">NSString</span> *)</span>fileName;</span></div><div class="line">- <span class="params">(<span class="variable">BOOL</span>)</span>storeArray:<span class="params">(<span class="variable">NSArray</span> *)</span>array withFileName:<span class="params">(<span class="variable">NSString</span> *)</span>fileName;</div><div class="line">- <span class="params">(<span class="variable">BOOL</span>)</span>storeDictionary:<span class="params">(<span class="variable">NSDictionary</span> *)</span>dictionary withFileName:<span class="params">(<span class="variable">NSString</span> *)</span>fileName;</div><div class="line">- <span class="params">(<span class="variable">BOOL</span>)</span>storeData:<span class="params">(<span class="variable">NSData</span> *)</span>data withFileName:<span class="params">(<span class="variable">NSString</span> *)</span>fileName;</div></pre></td></tr></table></figure>

<p>它的用法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="constant">NSArray *diskLists</span> = @[@<span class="string">"disk_1"</span>,@<span class="string">"disk_2"</span>,@<span class="string">"disk_3"</span>];</div><div class="line"><span class="constant">BOOL ret</span> = [dataManager storeArray:diskLists withFileName:@<span class="string">"order"</span>];</div></pre></td></tr></table></figure>

<p>其他类型以此类推</p>
<ul>
<li><figure class="highlight NSFileManager"><figcaption><span>```取数据</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="code">```</span></div><div class="line"><span class="bullet">- </span>(UIImage <span class="emphasis">*)fetchImageNamedString:(NSString *</span>)name;</div><div class="line"><span class="bullet">- </span>(NSArray <span class="emphasis">*)fetchArrayNamedString:(NSString *</span>)name;</div><div class="line"><span class="bullet">- </span>(NSDictionary <span class="emphasis">*)fetchDictionaryNamedString:(NSString *</span>)name;</div><div class="line"><span class="bullet">- </span>(NSData <span class="emphasis">*)fetchDataNamedString:(NSString *</span>)name;</div></pre></td></tr></table></figure>

</li>
</ul>
<p>它的用法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="constant">NSArray *fetchDiskLists</span> = [dataManager fetchArrayNameString:@<span class="string">"order"</span>];</div></pre></td></tr></table></figure>

<p>其他类型以此类推</p>
<ul>
<li><figure class="highlight NSFileManager"><figcaption><span>```删数据</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>removeImageNamedString:<span class="params">(<span class="variable">NSString</span> *)</span>name;</span></div><div class="line">- <span class="params">(<span class="variable">BOOL</span>)</span>removeArrayNamedString:<span class="params">(<span class="variable">NSString</span> *)</span>name;</div><div class="line">- <span class="params">(<span class="variable">BOOL</span>)</span>removeDictionaryNamedString:<span class="params">(<span class="variable">NSString</span> *)</span>name;</div><div class="line">- <span class="params">(<span class="variable">BOOL</span>)</span>removeDataNamedString:<span class="params">(<span class="variable">NSString</span> *)</span>name;</div></pre></td></tr></table></figure>

</li>
</ul>
<p>它的用法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL <span class="keyword">ret</span> = [dataManager removeArrayNameStrin<span class="variable">g:</span>@<span class="string">"order"</span>];</div></pre></td></tr></table></figure>

<p>其他类型以此类推</p>
<ul>
<li><figure class="highlight NSFileManager"><figcaption><span>```清空</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">-<span class="ruby"> (<span class="constant">BOOL</span>)clearDiskUnderImages;</span></div><div class="line">-<span class="ruby"> (<span class="constant">BOOL</span>)clearDiskUnderDatas;</span></div><div class="line">-<span class="ruby"> (void)clearAllDataOnDisk;</span></div></pre></td></tr></table></figure>

</li>
</ul>
<p>它的用法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">BOOL ret </span>=<span class="string"> [dataManager clearDiskUnderDatas];</span></div></pre></td></tr></table></figure>

<p>其中</p>
<figure class="highlight clearDiskUnderDatas```是清除Data目录中所有数据；"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="escape">``</span><span class="escape">`c</span>learDiskUnderImages</div></pre></td></tr></table></figure>

<p>是清除Image目录中所有数据</p>
<figure class="highlight clearAllDataOnDisk```是清除Disk上所有数据"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

<p>NSFileManager </p>
<figure class="highlight 获取数据大小"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">-<span class="ruby"> (<span class="constant">NSString</span>*)imageOndiskSize;</span></div><div class="line">-<span class="ruby"> (<span class="constant">NSString</span>*)dataOndiskSize;</span></div><div class="line">-<span class="ruby"> (<span class="constant">NSString</span>*)tmpOndiskSize;</span></div></pre></td></tr></table></figure>

<ul>
<li><figure class="highlight NSUserDefaults"><figcaption><span>```上的操作</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

</li>
</ul>
<p>NSUserDefaults </p>
<figure class="highlight 存数据"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>storeValue:<span class="params">(id)</span>value keyValue:<span class="params">(<span class="variable">NSString</span>*)</span>key;</span></div></pre></td></tr></table></figure>

<ul>
<li><figure class="highlight NSUserDefaults"><figcaption><span>```取数据</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="pp">- <span class="params">(id)</span>fetchValueUnderKeyValue:<span class="params">(<span class="variable">NSString</span> *)</span>key;</span></div></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<figure class="highlight NSUserDefaults"><figcaption><span>```用法</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="constant">BOOL ret</span> = [dataManager storeValue:@<span class="string">"LinkAge"</span> keyValue:@<span class="string">"Co.,Ltd."</span>];</div><div class="line"><span class="constant">NSString *corp</span> = [dataManager fetchValueUnderKeyValue:@<span class="string">"Co.,Ltd."</span>];</div></pre></td></tr></table></figure>

<ul>
<li><figure class="highlight NSKeyedArchiver"><figcaption><span>```上的操作(对有序列化要求的数据提供存储方法)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

</li>
</ul>
<p>NSKeyedArchiver </p>
<figure class="highlight 存数据"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>storeObject:<span class="params">(id)</span>object withFileName:<span class="params">(<span class="variable">NSString</span> *)</span>fileName;</span></div></pre></td></tr></table></figure>

<ul>
<li><figure class="highlight NSKeyedArchiver"><figcaption><span>```取数据</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="pp">- <span class="params">(id)</span>fetchObjectNamedString:<span class="params">(<span class="variable">NSString</span> *)</span>name;</span></div></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<figure class="highlight NSKeyedArchiver"><figcaption><span>```删数据</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">放在</div></pre></td></tr></table></figure>

<p>NSFileManager </p>
<figure class="highlight 对Data操作一致"><figcaption><span>他们的存储目录一样</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="deletion">-</span></div></pre></td></tr></table></figure>

<p>NSKeyedArchiver </p>
<figure class="highlight 用法"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"><span class="built_in">NSDictionary</span> *dic ...{为后台返回回来的jsonDic}</div><div class="line"><span class="built_in">BOOL</span> ret = [dataManager storeObject:dic withFileName:<span class="string">@"washCarList"</span>];</div><div class="line"><span class="built_in">NSDictionary</span> *fetchDic = [dataManager fetchObjectNamedString:<span class="string">@"washCarList"</span>];</div></pre></td></tr></table></figure>

<p>其余自定义类需要调用函数的 完成NSCoding协议后在调用</p>
]]></content>
    <summary type="html">
    <![CDATA[<h6 id="#_文章参照cucuz的数据存储Library"># 文章参照cucuz的数据存储Library</h6>
<p><strong>类 的目的</strong></p>
<p>方便项目当中数据的存储，提供简单的接口供使用,根据存储的位置划分可以分为缓存和本地存储，<br>其中包括</p>
<pre><code><span class="built_in">NSArray</span>, <span class="built_in">NSDictionary</span>, NSData,<span class="built_in">NSString</span>,<span class="built_in">UIImage</span> 等常用数据类型，自定义Object(自行实现NSCoding协议)
</code></pre><p><strong>类的函数介绍</strong></p>
<ul>
<li>类初始化(单例)</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">LCDataManager *dataManager </span>=<span class="string"> [LCDataManager shareManager];</span></div></pre></td></tr></table></figure>

<p>首先，我们创建一个对象，下文将以它作为存储的一个依据</p>
<h2 id="Cache_block">Cache block</h2>
<p>]]>
    
    </summary>
    
      <category term="LCDataManager" scheme="http://linkageios.github.io/tags/LCDataManager/"/>
    
      <category term="iOS" scheme="http://linkageios.github.io/categories/iOS/"/>
    
  </entry>
  
</feed>
